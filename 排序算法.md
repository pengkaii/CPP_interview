# 算法总结

# 十大排序算法

![查看源图像](https://pic3.zhimg.com/v2-d7f37e654f8b13555d2fbf5fe18eb6a6_r.jpg)

### 排序算法的比较，选择及其改进

- [ ] 从三个方向进行考虑：时间复杂度 + 空间复杂度 + 稳定性

- **平均时间复杂度**
  1. O(n^2)：选择排序、插入排序、冒泡排序
  2. O(nlogn)：快速排序、归并排序、堆排序
  3. O(n * k)：基数排序
- **空间复杂度**
  1. O(logn)：快速排序
  2. O(1)：选择排序、插入排序、堆排序
  3. O(n): 归并排序
  4. O(n + k)：基数排序
- **稳定性**
  1. **稳定**：插入排序、归并排序、冒泡排序、基数排序
  2. **不稳定**：选择排序、快速排序、堆排序、希尔排序

> 改进方法

1. 将选择排序改进为二元选择排序，每次循环选出最大值和最小值。
2. 在冒泡排序中加入标志，记录某一趟排序过程中是否有数据交换。没有的话直接退出循环。
3. 快速排序中，随机取基数，保证平均时间复杂度



### 选择排序O(n^2)

- 基本思路：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至**当前待排序区间**的首位。

- 优化：既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。使用二元选择排序，**每轮选择时记录最小值和最大值**，可以把数组需要遍历的范围缩小一倍。

- **思路：**每一次从待排序的数据元素中选择最小（最大）的一个元素作为有序的元素。如果是升序排序，则每次选择最小值就行，这样已经排好序的部分都是生序排序选择排序是不稳定的，比如说（55231这种情况，两个5的相对顺序会变）

- **选择排序的主要思想是在未排序的部分找到最小（或最大）的元素，将其放到已排序部分的末尾。这个过程会重复n-1次（n是数组的长度）。**

- 选择排序的时间复杂度为O(n²)，它不是一个稳定的排序算法，即相等的元素可能会在排序后改变它们的相对位置。但是选择排序是一个原地排序算法，不需要额外的存储空间来存储排序过程中的中间状态。

- 图解：

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210829105353.png" alt="在这里插入图片描述" style="zoom: 33%;float:left" />

```c++
#include <iostream>
#include <vector>
using namespace std;

/*
* 选择排序(Selection Sort)
* 思路：遍历数组，找到最小(或最大)的元素，将其放到排序序列的起始位置
* 特点：时间复杂度：O(n²)，非稳定排序，原地排序（不需要额外的存储空间）
* 适用：数据量小且对稳定性要求不高的场景
*/
class Select
{
public:
    // 定义排序函数，对传入的整型数组进行排序
    void mysort(vector<int> &nums)
    {
        int n = nums.size();  // 获取数组的长度
        for (int i = 0; i < n - 1; i++)  // 外层循环，用于控制排序的轮次，总共需要进行n-1轮
        {
            int minPos = i;  // 假设当前位置i为最小值的位置
            // 内层循环，从i+1位置开始，寻找比位置i小的元素
            for (int j = i + 1; j < n; j++)
            {
                // 如果发现更小的元素，更新最小元素的位置
                if (nums[j] < nums[minPos])
                {
                    minPos = j;
                }
            }
            // 如果最小元素的位置不是i，交换两个位置的元素
            if (minPos != i)
            {
                int temp = nums[i];
                nums[i] = nums[minPos];
                nums[minPos] = temp;
            }
        }
    }
};

int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};  // 创建一个整型数组
    Select select;  // 创建选择排序类的对象
    select.mysort(nums);  // 调用排序函数，对数组进行排序
    // 遍历排序后的数组，并打印每个元素
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;  // 程序正常结束
}



```

### **插入排序O(n^2)**

- 基本思想：有新数字加入时，将新数字插入合适的位置
- **交换法：**在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。
- **移动法：**在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。
- 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

```c++
/*
* 插入排序
* 思路：抓牌一样，插入当前手牌中的适当位置
* 特点：时间：O(n²)
* 适用：基本有序
*/
#include <iostream>
#include <vector>

using namespace std;

// 插入排序类
class Insert
{
public:
    // 插入排序函数
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        // 从第二个元素开始，向前插入排序
        for (int i = 1; i < n; i++)
        {
            int pos = i - 1; // 从当前元素的前一个位置开始比较
            int cur = nums[i]; // 当前需要排序的元素
            // 当前一个位置大于等于0且当前需要排序的元素小于前一个元素时
            while (pos >= 0 && cur < nums[pos])
            {
                nums[pos + 1] = nums[pos]; // 将前一个元素后移
                pos--; // 继续比较前一个位置
            }
            nums[pos + 1] = cur; // 插入当前需要排序的元素到正确位置
        }
    }
};

int main()
{
    // 初始化一个整数数组
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    // 创建插入排序对象
    Insert insert;
    // 进行插入排序
    insert.mysort(nums);
    // 输出排序后的数组
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
插入排序是一种简单直观的排序算法，其工作原理如下：

初始状态：假设数组的第一个元素已经被排序，剩下的元素未排序。因此，排序的部分是nums[0]，未排序的部分是nums[1]到nums[n-1]（其中n是数组的长度）。

排序过程：

从第二个元素开始，依次将每个未排序的元素插入到已排序的部分。
在插入的过程中，我们从已排序的部分的末尾开始，将当前元素与已排序元素进行比较。
如果当前元素小于已排序的元素，我们就将已排序的元素向后移动一个位置，为当前元素腾出空间。while重复这个过程，直到找到当前元素应该插入的位置。
将当前元素插入到找到的位置上。
重复步骤：

重复以上步骤，直到所有元素都被插入到已排序的部分。
排序完成：

当所有元素都插入到已排序的部分后，整个数组就变成了有序的状态。
插入排序的优点是实现简单，对于小规模的数组或者部分有序的数组，效率高。它的时间复杂度为O(n^2)，但是在最好的情况下（数组已经是有序的），时间复杂度可以达到O(n)。其主要缺点是当处理大数据集时，效率不是很高
```





### 快速排序O(nlogn)

基本思想：

- 从数组中取出一个数，称之为基数（pivot）
- 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域
- 将左右两个区域视为两个数组，重复前两个步骤，然后依次递归，直到排序完成。
- 基数值的选取随机的，一般选择数组的第一个或者数组的最后一个，然后有两个指针low和high.



快速排序是一种分治策略的排序算法，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。



快速排序是不稳定的排序方法，平均时间复杂度为O(nlogn)，但在最坏的情况下时间复杂度为O(n^2)，所以为了防止最坏情况的发生，通常会在排序前随机打乱数组，或者像这段代码中一样采用随机选择pivot的策略。

```c++
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
using namespace std;
/*
* 快速排序(Quick Sort)
* 思路：选择中轴基数(pivot)，比它小的放左，比它大的放右。
* 特点：时间复杂度：平均O(nlogn)，最差O(n^2)；空间复杂度：O(logn)；非稳定排序；
* 适用：数据量大的场景，是目前应用最广泛的排序算法之一。
*/
class Quick
{
public:
    // 快速排序的主函数
    void mysort(vector<int> &nums, int left, int right)
    {
        // 当左边界小于右边界时进行排序，否则结束递归
        if (left < right)
        {
            // 选取pivot，并进行一次划分
            int mid = ramdomPartition(nums, left, right);
            // 对左半部分进行快速排序
            mysort(nums, left, mid - 1);
            // 对右半部分进行快速排序
            mysort(nums, mid + 1, right);
        }
    }
    // 划分函数，选取数组的第一个元素作为pivot，进行划分
    int partition(vector<int>& nums, int left, int right) {
        int temp = nums[left];  // 将数组第一个元素作为基数
        while(left < right) {
            // 从右向左找到第一个小于pivot的元素
            while(left < right && nums[right] >= temp)
                --right;
            nums[left] = nums[right];
            // 从左向右找到第一个大于pivot的元素
            while(left < right && nums[left] <= temp)
                ++left;
            nums[right] = nums[left];
        }
        nums[left] = temp; // 将pivot放到正确的位置
        return left; // 返回pivot的位置  中间基数的位置
    }
    // 随机划分函数，避免最坏情况的发生
    int ramdomPartition(vector<int>& nums, int left, int right) {
        // 在[left, right]区间内生成一个随机数
        int mid = rand() % (right - left + 1) + left;
        // 将随机选取的元素与第一个元素交换
        swap(nums[mid], nums[left]);
        // 调用划分函数进行划分
        return partition(nums, left, right);
    }
};
int main()
{
    // 设置随机数种子
    srand(time(0));
    // 初始化待排序的数组
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    // 创建快速排序类的对象
    Quick quick;
    // 调用排序函数进行排序
    quick.mysort(nums, 0, nums.size() - 1);
    // 打印排序后的数组
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}

```

> 快速排序和归并排序的共同点和区别？

**归并排序和快排的相同点：**

1. 利用分治思想

2. 具体实现都用递归

**归并排序和快排的不同点：**

1. **自顶向下和自底向上**
   - **先分解再合并**：归并排序先递归分解到最小粒度，然后从小粒度开始合并排序，自下而上的合并排序；
   - **边分解边排序**：快速排序每次分解都实现整体上有序，即参照值左侧的数都小于参照值，右侧的大于参照值；是自上而下的排序；
2. **原地排序**
   - 归并排序不是原地排序，因为两个有序数组的合并一定需要额外的空间协助才能合并；
   - 快速排序是原地排序，原地排序指的是空间复杂度为O(1)；
3. **归并排序每次将数组一分为二，快排每次将数组一分为三**





### 归并排序O(nlogn)

- 基本思想：将两个有序的列表合并成一个有序列表

- 分治思想，先逐步分解成最小(递归)再合并图解：

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210829134401.jpeg" alt="在这里插入图片描述" style="zoom:67%;float:left" />
  
  归并排序是一种稳定的排序算法，它将数组递归地分成两半，对每一半进行排序，然后将排序好的两半合并。归并排序的时间复杂度是O(nlogn)，但它需要一个与原数组同样大小的临时数组来进行合并操作，因此空间复杂度为O(n)。
  
  
  
  代码中的mergeSort函数是递归进行的，它首先计算数组的中点，然后对左半部分和右半部分分别进行排序，最后调用merge函数将两个已排序的部分合并。merge函数通过比较两个部分的元素，将较小的元素先放入临时数组，最后再将临时数组的内容复制回原数组。

```c++
#include <iostream>
#include <vector>
using namespace std;

/*
* 归并排序(Merge Sort)
* 思路：递归地将数组分成两半，分别进行排序，然后将排序好的两半合并。
* 特点：时间复杂度：O(nlogn)，空间复杂度：O(n)（需要额外的数组进行合并操作），稳定排序
* 适用：处理大数据量的情况，对稳定性有要求，空间复杂度可接受。
*/
class Merge
{
public:
    // 归并排序的主函数
    void mergeSort(vector<int>& nums, int left, int right) {
        // 当左边界小于右边界时进行排序，否则结束递归
        if (left >= right) return;
        // 计算中点位置
        int mid = left + (right - left) / 2;
        // 对左半部分进行归并排序
        mergeSort(nums, left, mid);
        // 对右半部分进行归并排序
        mergeSort(nums, mid + 1, right);
        // 合并两个已排序的部分
        merge(nums, left, right);
    }
    // 合并两个有序数组的函数
    void merge(vector<int>& nums, int left, int right) {
        // 创建一个临时数组保存原数组数据
        vector<int> temp(nums);
        // 计算中点位置
        int mid = left + (right - left) / 2;
        // 初始化两个指针，分别指向两个有序数组的起始位置
        int p = left, q = mid + 1;
        int index = left;//遍历位置
        // 开始归并过程
        while (p <= mid && q <= right) {
            if (nums[p] < nums[q]) {
                temp[index++] = nums[p++];
            }
            else {
                temp[index++] = nums[q++];
            }
        }
        // 处理剩下的元素
        while (p <= mid)    temp[index++] = nums[p++];
        while (q <= right)  temp[index++] = nums[q++];

        // 将合并后的数据复制回原数组
        for (int i = left; i <= right; ++i) {
            nums[i] = temp[i];
        }
    }
};

int main()
{
    // 初始化待排序的数组
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    // 创建归并排序类的对象
    Merge merge;
    // 调用排序函数进行排序
    merge.mergeSort(nums, 0, nums.size() - 1);
    // 打印排序后的数组
    for (int num : nums)
        cout << num << " ";
    return 0;
}

```



### 堆排序O(nlogn)

基本思想：

- 用数列构建出一个大顶堆，取出堆顶的数字
- 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字
- 循环往复，完成整个排序

思路：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。



堆排序分为两步：首先将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。随后第二步将其与末尾元素进行交换，此时末尾就为最大值。然后将这个堆结构映射到数组中后，就会变成升序状态了。**（即升序—大根堆）**

> 当数组元素映射成为堆时：
>
> 1. 父结点索引：(i-1)/2
> 2. +左孩子索引：2*i+1
> 3. 左孩子索引：2*i+2

图解：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210829112449.gif" alt="在这里插入图片描述" style="zoom:50%;float:left" />

基本思想：

1. 首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端
2. 将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1
3. 将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组



堆排序算法。堆排序利用了大顶堆（或小顶堆）的性质进行排序，适合用于处理大数据量的情况。堆排序的基本思想是先将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。将它与堆的最后一个元素交换，然后将堆的大小减1，再调整堆。重复这个过程，直到堆的大小为1，排序完成。



在heapAdjust函数中，通过循环，将当前节点的值调整到合适的位置，保持大顶堆的性质。然后在mysort函数中，首先调用heapAdjust函数构建初始堆，然后通过交换堆顶元素和堆底元素，再调整堆，最终实现排序。

```c++
/*
* 堆排序(Heap Sort)
* 思路：利用大顶堆(或小顶堆)的性质进行排序，升序排序使用大顶堆，降序排序使用小顶堆。
* 特点：时间复杂度：O(nlogn)，非稳定排序
* 适用：数据量较大时。但在实际应用中不如快速排序和归并排序常用。
*/
class Heap
{
public:
    // 堆排序主函数
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        // （1）构造初始堆，从最后一个非叶子节点开始调整
        for (int i = n / 2 - 1; i >= 0; i--)
        {
            heapAdjust(nums, n, i);//调整以i为根节点的子树，使其满足堆的性质
        }
        // （2）排序，每次将堆顶元素(最大值)与堆的最后一个元素交换，然后调整堆
        for (int i = n - 1; i > 0; i--)
        {
            // 交换堆顶元素与堆的最后一个元素
            //nums[0]存的是当前堆中的最大值，而nums[i]是当前堆的最后一个元素。通过交换它们的位置，最大值被放到了数组的正确位置上。交换后，我们将堆的大小减1（即不再考虑数组最后的元素，因为它已经是最大值了），然后再次调整剩下的元素，使其成为一个大顶堆。
            //nums[0]在执行交换操作之前是堆顶元素，表示当前堆中的最大值；而nums[i]是堆的最后一个元素。通过交换，将最大值放到了数组的末尾。
            swap(nums[i], nums[0]);
            // 调整堆，此时堆的大小为i
            heapAdjust(nums, i, 0);
        }
    }
    // 辅助函数：调整堆
    void heapAdjust(vector<int> &nums, int len, int i)
    {
        int index = 2 * i + 1;  // i的左孩子节点位置
        while (index < len)
        {
            // 如果有右孩子，并且右孩子大于左孩子，则index指向右孩子
            if (index + 1 < len && nums[index + 1] > nums[index])
            {
                index = index + 1;
            }
            // 如果孩子节点大于父节点，则交换
            if (nums[index] > nums[i])
            {
                swap(nums[i], nums[index]);
                // 更新i和index，继续调整下一层
                i = index;
                index = 2 * i + 1;
            }
            else
            {
                break;
            }
        }
    }
};

int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Heap heap;
    heap.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```



### 为什么都在用快排而不是归并，堆？

**问：我们知道，快排平均复杂度为nlogn，最坏时间复杂度为n^2，而归并排序最坏才是nlogn。那么为什么还是用快排多，用归并少呢？**

我觉得原因有以下几个：

1. 首先了解O的含义，即O(nlgon)的O。大O符号又称为渐进符号，在数学上表示一个函数的渐进行为的符号，描述一个函数数量级的渐进下界，不考虑首项系数和低阶项。比如说有一个规模n的算法花费时间T(n)=n^2+2n+c，可以看到当n增大的时候n^2开始占据主导地位，因此O(n)=n^2。在实际的生产生活中我们所用的n并没有达到那么大的规模，因此这个2n+c这个点是不可以忽略的。

2. 快速排序一般是原地排序，不需要创建任何的辅助数组来保存临时变量。而归并排序需要用到两个额外的数组进行存储，同时将数组合并成为一个也会花费点时间。

3. 就常数项来说，快排< 归并 < 堆

   <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20211210114013.png" alt="image-20211210114012869" style="zoom:80%;" />

**问：什么场景下用归并比用快排好？**

当对连链表结构进行排序的时候，归并排序比快排高效。因为链表的存储空间时分散的，必须到每个节点的地址再连接起来，这就导致快排依靠数组的优势不存在了。同时归并使用链表结构的话，直接连接就行，不需要额外的辅助空间。

# 剩下排序：

### 冒泡排序

- 基本思路：一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位，每轮遍历后收缩待排序区间
- 优化：使用一个**变量记录当前轮次的比较是否发生过交换**，如果没有发生交换表示已经有序，不再继续排序

```c++
//在冒泡排序中，程序会多次遍历整个数组。在每次遍历中，它会比较相邻的元素，并在它们的顺序错误时交换它们。这个过程会重复进行，直到整个数组被排序。
#include <iostream>
#include <vector>
using namespace std;
/*
* 冒泡排序
* 比较和交换相邻的元素来进行排序
* 算法复杂度：O(n^2)
* 特点：简单，但不适合大数据量的排序
*/
class Bubble
{
public:
    // 排序函数
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        // 外层循环，控制排序的轮数，一共n-1轮
        for (int i = 0; i < n - 1; i++)
        {
            // 内层循环，进行单轮的比较和交换
            for (int j = 0; j < n - i - 1; j++)
            {
                // 如果左边的数比右边的数大，就交换它们的位置
                if (nums[j] > nums[j + 1])
                {
                    swap(nums[j], nums[j + 1]);
                }
            }
        }
    }
};

int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Bubble bubble;
    bubble.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}

```



### 计数排序

基本思想：

- 数组中每个元素都是 [1, 9]区间内的整数。那么我们可以构建一个长度为9的数组用于计数，计数数组的下标分别对应区间内的 9个整数。

- 然后遍历待排序的数组，将区间内每个整数出现的次数统计到计数数组中对应下标的位置。最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数。

```c++
/*
* 计数排序
* 思路：借助足够大的辅助数组，把数字排在一个相对位置不会错的地方，最后并拢
* 特点：时间：O(n+k)、空间：O(n+k)——非原地
* 适用：max和min的差值不大
*/
class Count
{
public:
    void mysort(vector<int> &nums, int min, int max)
    {
        vector<int> temp(max - min + 1);
        for (int num : nums)
        {
            temp[num - min]++;
        }
        int index = 0;
        for (int i = 0; i < temp.size(); i++)
        {
            int cnt = temp[i];
            while (cnt != 0)
            {
                nums[index] = i + min;
                index++;
                cnt--;
            }
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Count count;
    count.mysort(nums, 0, 9);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```

### 桶排序

基本思想：

- 将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶
- 遍历数组，将每个数字装入桶中
- 对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等
- 最后按照顺序将所有桶内的数字合并起来

```c++
/*
* 桶排序
* 思路：先粗略分类分桶，再各桶排序
* 特点：时间：O(n+k)、空间：O(n+k)——非原地
* 适用：均匀分布的数据
*/
class Bucket
{
public:
    void mysort(vector<int> &nums)
    {
        //（1）初始化桶
        int n = nums.size();
        vector<list<int>> buckets(n);
        //（2）数据放入桶并完成排序
        for (int num : nums)
        {
            int index = getBucketIndex(num);
            insertSort(buckets[index], num);
        }
        //（3）从桶取数据，放入nums
        int index = 0;
        for (list<int> bucket : buckets)
        {
            for (int num : bucket)
            {
                nums[index] = num;
                index++;
            }
        }
    }
    //辅助函数一：获得桶的序号
    int getBucketIndex(int num)
    {
        return num / 3;
    }
    //辅助函数二：把数据插入对应桶(这里用的插入排序)
    void insertSort(list<int> &bucket, int num)
    {
        int n = bucket.size();
        bool flag = true;
        for (auto it = bucket.begin(); it != bucket.end(); it++)
        {
            if (num <= *it)
            {
                bucket.insert(it, num);
                flag = false;
                break;
            }
        }
        if (flag)
            bucket.push_back(num);
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Bucket b;
    b.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}

```



### 基数排序

基本思想：我们大脑中对日期排序的思维过程是：先看年份，再比较一下月份，最后比较具体几号。**利用多关键字进行排序**的思想就是基数排序。

- 找出数组中最大的数字的位数 maxDigitLength
- 获取数组中每个数字的基数
- 遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序（每轮对基数进行排序非常适合使用我们在上面学习的**计数排序**算法）

```c++
/*
* 基数排序
* 思路：桶排序的一种。 按数位分桶：从低位开始 -> 分桶、收集 -> 下一位...
* 特点：时间：O(kn)、空间：O(n+k)——非原地
* 适用：max和min的差值不大
*/
class Radix
{
public:
    void mysort(vector<int> &nums, int d)
    {
        int p = 1;
        int n = nums.size();
        vector<vector<int>> buckets(10, vector<int>(n));
        vector<int> order(10);
        while (p < d)
        {
            //（1）进行一轮分桶
            for (int num : nums)
            {
                int index = num / p % 10;           //获取桶号
                buckets[index][order[index]] = num; // num放入index号桶的第
                order[index] 位置
                    order[index]++; //位置++
            }
            //（2）进行一轮排序
            int k = 0;
            for (int i = 0; i < 10; i++)
            {
                if (order[i] == 0)
                    continue;
                for (int j = 0; j < order[i]; j++)
                {
                    nums[k] = buckets[i][j];
                    k++;
                }
                order[i] = 0; //各桶计数器清零
            }
            p *= 10;
        }
    }
};
int main()
{
    vector<int> nums = {999, 765, 780, 215, 13, 66, 230, 450, 699, 21};
    Radix radix;
    radix.mysort(nums, 1000);
    for (int num : nums)
        cout << num << " ";
    return 0;
}
```



### 希尔排序

希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又**克服了插入排序每次只交换相邻两个元素**的缺点。它的基本思想是：

- 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是**每跳跃一定间隔取一个值组成一组**
- **逐渐缩小间隔**进行下一轮排序
- 最后一轮时，取**间隔为 1，也就相当于直接使用插入排序**。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成

```c++
/*
* 希尔排序
* 思路：间隔分组+自定义排序（这里给出的是冒泡）
* 特点：时间：O(nlogn)、非稳定排序
* 适用：数据量大
*/
class Shell
{
public:
    void mysort(vector<int> &nums)
    {
        int n = nums.size();
        int gap = n / 2;
        while (gap > 0)
        {
            for (int j = gap; j < n; j++)
            {
                int i = j;
                while (i >= gap && nums[i] < nums[i - gap])
                {
                    int temp = nums[i];
                    nums[i] = nums[i - gap];
                    nums[i - gap] = temp;
                    i -= gap;
                }
            }
            gap /= 2;
        }
    }
};
int main()
{
    vector<int> nums = {9, 7, 5, 3, 1, 0, 8, 4, 6, 2};
    Shell shell;
    shell.mysort(nums);
    for (int num : nums)
    {
        cout << num << " ";
    }
    return 0;
}
```



# 常用库函数的实现

## 系统调用相关

### 实现 memcpy()

**实现要点**（类似 `strcpy()` ）：

用于将内存从一个位置复制到另一个位置

1. 在函数入口处要检查源字符串指针和目标字符串指针是否有为空的，否则会产生不可预料的错误；
2. 如果按照一个字节拷贝，那就要把形参转换成 `char*` 类型来操作；
3. 要检查源内存和目标内存是否存在内存重叠，如果目标内存首地址在源内存的中间，则要从后往前拷贝，因为如果从前往后拷贝，那从目标内存首地址开始的地方就会被覆盖掉，如果没有重叠，或者源内存地址在目标内存的中间，那没有关系，可以从前往后拷贝；
4. 不能使用 `'\0'` 来判断拷贝的结束，因为它是对一整块内存的拷贝，举一个浅显的例子，假设拷贝一个结构体，类似上面代码，那么它很可能拷贝到中间的某个地方就停止了，这个拷贝就相当于没有完成；
5. 返回目标字符串的首地址；

```c++
// memcpy的实现1（一次拷贝一个字节）
void* mymemcpy(void* dest, const void* src, size_t n)
{
    if (dest == nullptr || src == nullptr)  
        // 检查源指针和目的指针是否为null，如果是则返回null。
        return nullptr;

    char *pDest = static_cast <char*>(dest);  
    // 将void*类型的dest转换为char*类型，以便按字节操作。
    const char *pSrc = static_cast <const char*>(src);  
    // 将const void*类型的src转换为const char*类型，以便按字节操作。

    if (pDest > pSrc && pDest < pSrc + n) {  
        // 检查是否有内存重叠，并且目的地址在源地址的后面。
        // 如果出现内存重叠的情况，从后往前复制
        pDest = pDest + n - 1;  
        // 将目的指针移到要复制的块的最后一个字节。
        pSrc = pSrc + n - 1;  
        // 将源指针移到要复制的块的最后一个字节。
        while(n--)  
            // 循环n次，每次复制一个字节，从后往前复制。
            *pDest-- = *pSrc--;  
        // 复制一个字节，并将源指针和目的指针都向前移动一个字节。
    }
    else {  
        // 如果没有内存重叠，或者目的地址在源地址的前面。
        // 否则从前往后复制
        while(n--)  
            // 循环n次，每次复制一个字节，从前往后复制。
            *pDest++ = *pSrc++;  
            // 复制一个字节，并将源指针和目的指针都向后移动一个字节。
    }
    return dest;  // 返回目的地址的指针。
}
```

- **如果面试官问，按照四个字节来拷贝，应该怎么处理？**

按照4个字节判断，一个清晰的思路是满足4个字节的按照 int 类型去拷贝，不满足4个字节的就还是按照 char 类型去拷贝。

如果按照4个字节来拷贝，就没办法去判断内存重叠的情况了，因为内存的基本单位是一个字节，4个字节是没有办法避免覆盖情况的。

```c++
// memcpy的实现1（一次拷贝四个字节）
void* mymemcpy(void* dest, const void* src, size_t n) {
    if (dest == NULL || src == NULL)  
        // 检查源指针和目的指针是否为null，如果是则返回null。
        return NULL;
    int *pDest = (int*)dest;  
    // 将void*类型的dest转换为int*类型，以便按整数操作。
    int *pSrc = (int*)src;  
    // 将const void*类型的src转换为const int*类型，以便按整数操作。
    int iWordNum = n / 4;  // 计算有多少个整数（4字节）需要复制。
    int iSlice = n % 4;  // 计算剩余的字节数。
    while(iWordNum--) {  // 循环复制整数。
        *pDest++ = *pSrc++;  
        // 复制一个整数，并将源指针和目的指针都向后移动一个整数的位置。
    }
    char* pcDest = (char*)pDest;  
    // 将int*类型的目的指针转换为char*类型，以便按字节操作。
    char* pcSrc = (char*)pSrc;  
    // 将const int*类型的源指针转换为const char*类型，以便按字节操作。
    while(iSlice--) {  
        // 循环复制剩余的字节。
        *pcDest++ = *pcSrc++;  
        // 复制一个字节，并将源指针和目的指针都向后移动一个字节的位置。
    }
    return dest;  // 返回目的地址的指针。
}
```



## 字符串相关

### 实现strcpy()

把从strsrc地址开始且含有'\0'结束符的字符串复制到以strdest开始的地址空间，返回值的类型为char*

**注意的点：**

1. 源字符串使用const，避免被修改
2. 函数入口加入空指针判断
3. 返回值为 `char*`，使函数支持链式表达式

**缺陷：**

1. 当src的长度超过dest的长度，导致数据写入未知内存->最好使用 `strncpy()`（用户自己声明拷贝多少个字符）

```c++
char* strcpy(char* dest, const char* src) {
    assert(dest != nullptr && src != nullptr);  // 确保源指针和目的指针都不是空指针。
    char* address = dest;  // 保存目的字符串的起始地址，用于最后的返回。
    while((*dest++ = *src++) != '\0');  // 复制字符串，直到遇到空字符。
    return address;  // 返回目的字符串的起始地址。
}

char* strncpy(char* dest, const char* src, size_t n) {
    assert(dest != nullptr && src != nullptr);  // 确保源指针和目的指针都不是空指针。
    char* ret = dest;  // 保存目的字符串的起始地址，用于最后的返回。
    while(n-- && (*dest++ = *src++) != '\0');  // 复制字符串，直到遇到空字符或复制了n个字符。
    return ret;  // 返回目的字符串的起始地址。
}


新复制
//把src所指向的字符串复制到dest，注意：dest定义的空间应该⽐src⼤。
char* strcpy(char *dest, const char *src) {
     char *ret = dest;
     assert(dest!=NULL);//优化点1：检查输⼊参数
     assert(src!=NULL);
     while(*src != '\0'){
        *(dest++)=*(src++);
     }
    *dest = '\0';//优化点2：⼿动地将最后的'\0'补上
     return ret;
}

//考虑内存重叠的字符串拷⻉函数优化的情况
char* strcpy(char *dest,char *src) {
     char *ret = dest;
     assert(dest!=NULL);
     assert(src!=NULL);
     memmove(dest,src,strlen(src)+1);
     return ret;
}

//对于以上代码，我们可以看出来，它是存在隐患的
//当源字符串的长度超出目标字符串时，会导致把数据写入到我们无法控制的地址中去，存在很大的风险，所以就有了strncpy
char *strncpy(char* dest, const char* src, size_t n)
{
    assert( (dest != NULL) && (src != NULL));
    char *address = dest;
    while ( n-- && (*src++ != '\0')){
        *dest++ = *src++;
    }
    *dest = '\0';
    return address;
}
```



### 实现strStr()

```cpp
int strStr(string haystack, string needle) {
    // kmp 大法
    if (needle.size() == 0) return 0;
    if (haystack.size() < needle.size())    return -1;

    vector<int> next = getNext(needle);
    int j = -1;
    for (int i = 0; i < haystack.size(); ++i) {
        while (j >= 0 && haystack[i] != needle[j + 1]) {  // 前后缀不相同
            j = next[j];  // 回退
        }
        if (haystack[i] == needle[j + 1]) {  // 匹配的话，i和j同时向后移动
            ++j;
        }
        if (j + 1 == needle.size()) {  // 匹配完成
            return (i - j);
        }
    }

    return -1;
}


vector<int> getNext(const string& s) {
    vector<int> next(s.size(), 0);
    int j = -1;
    next[0] = j;
    for (int i = 1; i < s.size(); ++i) {
        while (j >= 0 && s[i] != s[j + 1]) {  // 前后缀不相同
            j = next[j];  // 回退
        }
        if (s[i] == s[j + 1]) {  // 找到相同的前后缀
            ++j;
        }
        next[i] = j;
    }

    return next;
}
```



### 实现strlen()

计算给定字符串的长度。

```c++
size_t strlen(const char* str) {
    assert(str != nullptr);  // 使用断言确保源指针不为null。
    size_t len = 0;  // 初始化长度为0。

    while(*str++ != '\0') {  // 遍历字符串，直到找到空字符。
        ++len;  // 对于每个非空字符，增加长度计数。
    }
    return len;  // 返回字符串的长度。
}
```



### 实现strcat()

把src所指字符串添加到dest结尾处。

```c++
char* strcat(char* dest, const char* src) {
    assert(dest != nullptr && src != nullptr);  // 使用断言确保源指针和目的指针不为null。
    char* ret = dest;  // 保存dest的原始指针，用于最后返回。

    // 找到dest的结尾
    while(*dest != '\0') {  // 遍历dest字符串，直到找到空字符。
        dest++;
    }

    while((*dest++ = *src++) != '\0') {}  // 将src字符串的字符复制到dest字符串的末尾，直到遇到src的空字符。

    return ret;  // 返回连接后的字符串。
}


//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
char* strcat(char *dest,const char *src) {
    //1. 将目的字符串的起始位置先保存，最后要返回它的头指针
    //2. 先找到dest的结束位置,再把src拷⻉到dest中，记得在最后要加上'\0'
    char *ret = dest;
    assert(dest!= nullptr);
    assert(src!= nullptr);
    while(*dest!='\0')
        dest++;
    while(*src!='\0')
        *(dest++)=*(src++);
    *dest='\0';
    return ret;
}
```



### 实现strcmp()

比较两个字符串设这两个字符串为str1，str2

若`str1 == str2`，则返回零

若`str1 < str2`，则返回负数

若`str1 > str2`，则返回正数

```c++
int strcmp(const char* str1, const char* str2) {
    assert(str1 != nullptr && str2 != nullptr);
    // 找到首个不相等的字符
    while(*str1 != '\0' && *str2 != '\0' && *str1 == *str2) {
        str1++;
        str2++;
    }
    if(*str1 > *str2) {
        return 1;
    }
    else if(*str1 < *str2) {
        return -1;
    }
    else {
        return 0;
    }
}



//把 str1 所指向的字符串和 str2 所指向的字符串进⾏⽐较。
//该函数返回值如下：
//如果返回值 < 0，则表示 str1 ⼩于 str2。
//如果返回值 > 0，则表示 str1 ⼤于 str2。
//如果返回值 = 0，则表示 str1 等于 str2。
//'\0'的ascii码是0
int strcmp(const char* str1, const char*str2){
	assert(str1 != nullptr && str2 != nullptr);
    while (*str1 != '\0' && *str2 != '\0' && *str1 == *str2){
        str1++;
        str2++;
    }
    if(*(unsigned char*)str1 < *(unsigned char*)str2){
        return -1;
    }
    else if (*(unsigned char*)str1 > *(unsigned char*)str2){
        return 1;
    }
    return 0;
    //return *str1 - *str2;
}
```



### 实现atoi()

#### 实现要点

1. 删除前导空格
2. 检查正负号
3. 从第一个非空格字符开始转换（如果不是数字，直接返回0）
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 [ $$−2^{31}$$ ,  $$2^{31} − 1$$ ] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $$−2^{31}$$ 的整数应该被固定为 $$−2^{31}$$ ，大于 $$2^{31} − 1$$ 的整数应该被固定为 $$2^{31} − 1$$ 。

```c++
int myAtoi(string s) {
    int index = 0, n = s.size();
    bool negative = false;
    
    // 去除前导空格
    while (index < n && s[index] == ' ')    ++index;
    if (index == n) return 0;

    // 判断正负号
    if (s[index] == '-') {
        negative = true;
        ++index;
    }
    else if (s[index] == '+') {
        ++index;
    }

    int sum = 0;
    for (; index < n; ++index) {
        // s[index] 不为数字就终止
        if (s[index] < '0' || s[index] > '9')   break;
        if (sum > (INT_MAX - s[index] + '0') / 10) {  // 防止溢出
            return negative ? INT_MIN : INT_MAX;
        }
        sum = sum * 10 + s[index] - '0';
    }

    return negative ? -sum : sum;
}
```



# TOP K 问题

#### 10 亿个数中找出最大的 10000 个数

因为 10 亿个数没有办法全部读入内存，可以考虑使用**堆排序**。

**思路：**堆排序 + 分治优化

1. 先拿 10000 个数建小顶堆，然后依次添加剩余的数，如果大于堆顶的数，就将这个数替换堆顶的数，然后调整小根堆的结构。这样，遍历完后，堆中的10000个数就是所需的最大的10000个。
2. 优化：将 10 亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果（归并排序）。

时间复杂度：O(m*logm) + O(n\*m\*logm)



#### 如何从 5 亿个数中找出中位数？

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为第 `(N+1)/2` 个数；当样本数为偶数时，中位数为第 `N/2` 个数与第 `1+N/2` 个数的均值。

思路：如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)` 。这里使用其他方法。**双堆法（小量数据）或者分治法（大量数据）**。

**（1）双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

**（2）分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。



# 如何判断本机是大端序还是小端序

1. 大端
   - 数据的高位字节存储在低内存地址，
   - 假设我们有一个32位整数0x12345678（16进制），在内存中的存储顺序将会是：0x12 0x34 0x56 0x78。
2. 小端
   - 数据的高位字节存储在高内存地址，
   - 在小端模式下32位整数0x12345678将会被存储为：0x78 0x56 0x34 0x12。

- 使用一个联合（union）来检查
- 利用一个联合体（union）来存储一个short类型的数据和一个char数组类型的数据。联合体的特点是它的所有成员共享同一块内存，因此short类型和char数组类型实际上是使用相同的内存空间。
- 总结一下检测字节序的原理：
- 1. 首先，将short类型变量un.s初始化为0x0102。这个值在内存中会按照机器的字节序进行存储。
  2. 接下来，代码检查sizeof(short)是否等于2，以确保short类型在内存中占用2个字节。
  3. 如果sizeof(short)确实等于2，那么代码会进一步检查un.c数组的内容。un.c[0]和un.c[1]分别表示short类型变量un.s的低字节和高字节。
  4. 如果un.c[0]等于1高位且un.c[1]等于2，说明在内存中按照大端序存储，因为高字节（1）存储在低地址，低字节（2）存储在高地址。
  5. 如果un.c[0]等于2且un.c[1]等于1，说明在内存中按照小端序存储，因为低字节（2）存储在低地址，高字节（1）存储在高地址。
  6. 如果以上两种情况都不满足，那么代码会输出"未知"，表示无法确定字节序。

```c++
#include <stdio.h>
int main() {
    // 定义一个联合体（union），用于存储short类型和char数组类型的数据
    union {
        short s;            // 使用short类型来存储数据
        char c[sizeof(short)]; // 使用char数组类型来按字节存储数据
    } un;
    un.s = 0x0102; 
    // 初始化short类型的数据，0x0102在内存中会按照字节序存储
    if (sizeof(short) == 2) { 
        // 检查short类型是否占用2个字节
        if (un.c[0] == 1 && un.c[1] == 2) {
            printf("大端序\n"); 
            // 如果第一个字节存储1，第二个字节存储2，说明是大端序
        } else if (un.c[0] == 2 && un.c[1] == 1) {
            printf("小端序\n"); 
            // 如果第一个字节存储2，第二个字节存储1，说明是小端序
        } else {
            printf("未知\n"); 
            // 如果不满足以上两种情况，打印未知
        }
    } else {
        printf("sizeof(short) = %lu\n", sizeof(short)); 
        // 如果short类型不占用2个字节，打印其大小
    }

    return 0;
}
```



# 设计题

## 栈相关

### 最小栈的实现

基本功能与栈相同，但是多了一个 `getMin()` 获取最小值

**例题：**[155. 最小栈](https://leetcode.cn/problems/min-stack/)

**基本思路：**

- 两个栈（一个实现栈的基本功能，一个存放最小值）
- 一个栈
  - 栈内放的是 `pair<int, int>` 第一个是放入的元素，第二个是最小值
  - 栈内放的是 `当前元素 - 最小值` 
- 直接使用链表，链表内存放当前元素和最小值



```c++
class MinStack {
public:
    stack<long long> stk;  // 使用long long类型的栈，以支持较大范围的整数运算。
    long long diff;  // 用来存储栈顶元素与当前最小元素的差值。
    long long min;  // 用来存储当前的最小元素。
    bool block = true;  // 用来标记栈是否为空，如果为true表示栈为空。

    MinStack() {
    }
    
    void push(int val) {
        // 如果栈为空且push的值大于0，设置min为INT_MAX并解锁。
        if (block && val > 0) {
            min = INT_MAX;
            block = false;
        }
        // 如果栈为空且push的值小于或等于0，设置min为0并解锁。
        else if (block && val <= 0) {
            min = 0;
            block = false;
        }
        diff = (long long)val - min;
        stk.push(diff);
        stk.push(val);
        // 如果diff小于0，说明push的值是当前最小值，更新min。
        if (diff < 0)
            min = val;
    }
    
    void pop() {
        int top = stk.top();  // 获取栈顶元素的值。
        stk.pop();
        int d = stk.top();  // 获取属于栈顶元素的diff。
        stk.pop();
        min = (long long)top - d;  // 更新当前最小值。
        // 如果出栈操作导致栈空，设置block为true。
        if (stk.empty()) 
            block = true;
    }
    
    int top() {
        return stk.top();  // 返回栈顶元素的值。
    }
    
    int getMin() {
        return min;  // 返回当前最小值。
    }
};

```



```java
// 链表
class MinStack {
    class Node{
        int value;
        int min;
        Node* next;

        Node(int x, int min){
            this.value=x;
            this.min=min;
            next = null;
        }
    }
    Node head;
    //每次加入的节点放到头部
    public void push(int x) {
        if(null==head){
            head = new Node(x,x);
        }else{
            //当前值和之前头结点的最小值较小的做为当前的 min
            Node n = new Node(x, Math.min(x,head.min));
            n.next=head;
            head=n;
        }
    }

    public void pop() {
        if(head!=null)
            head =head.next;
    }

    public int top() {
        if(head!=null)
            return head.value;
        return -1;
    }

    public int getMin() {
        if(null!=head)
            return head.min;
        return -1;
    }
}
```







## 队列相关

### 实现循环队列

例题：

1. [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)（链表/循环数组）

```cpp
class MyCircularQueue {
public:
    MyCircularQueue(int k) : buffer(k + 1, 0), size(k + 1), readIndex(0), writeIndex(0) {

    }
    
    bool enQueue(int value) {
        if (isFull())   return false;

        buffer[writeIndex] = value;
        writeIndex = (writeIndex + 1) % size;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty())  return false;

        readIndex = (readIndex + 1) % size;
        return true;
    }
    
    int Front() {
        if (isEmpty())  return -1;

        return buffer[readIndex];
    }
    
    int Rear() {
        if (isEmpty())  return -1;

        return buffer[(writeIndex - 1 + size) % size];
    }
    
    bool isEmpty() {
        return readIndex == writeIndex;
    }
    
    bool isFull() {
        return readIndex == (writeIndex + 1) % size;
    }

private:
    vector<int> buffer;
    int size;
    int readIndex, writeIndex;
};
```



## 链表相关

### LFU

### LRU

```c++
/********************不用API的版本*************************/
/********************简单说一下思路*************************/
//1.首先hash表用的是unordered_map来实现，用来查找key对应的node节点，所以hash表应该是[key,node]形式存储
//2.LRUCache这个类实现双向链表的添加，删除，更新和遍历
//3.同时这个类还要实现get和put两个功能
//4.我这里用的是循环双向链表，因此查找链表尾端的元素为O(1)，正常的双向链表是O(n)
//总结：最重要的就是hash表中的key对应的不是int而是一个node节点，这个要记住
#include<unordered_map>
#include<iostream>
struct Node{
    int key;
    int value;
    Node* pre;
    Node* next;
    Node(){}
    Node(int k, int v):key(k), value(v), pre(nullptr), next(nullptr){}
};

class LRUCache{
private:
    //通过key可以找到位于链表中的节点
    std::unordered_map<int, Node*> hash;
    int capacity;
    Node* head_node;
public:
    LRUCache(int cap){
        capacity = cap;
        head_node = new Node();
        //初始化dummy_Node,next和pre都指向自己
        head_node->next = head_node->pre = head_node;
    }
    //将新来的插入双向链表头部
    void add_Node(Node* n);
    //将某个节点拿出来重新插入头部
    void update_Node(Node* n);
    //移除链表中最后一个（最久未使用）
    void pop_back();
    //输出LRU结构
    void show();
    int get(int key);
    void put(int key, int value);
};

//注意，该节点可能是新节点，也可能是已经存在的有重新入链表的节点
void LRUCache::add_Node(Node* n){
    //表示当前节点n就是dummy的next节点，不用加入
    if(n->pre == head_node){
        return;
    }
    //将节点n插入head_node后面
    n->pre = head_node;
    n->next = head_node->next;
    head_node->next->pre = n;
    head_node->next = n;
}

void LRUCache::update_Node(Node* n){
    //表示当前节点n就是dummy的next节点，不用断掉
    if(n->pre == head_node){
        return;
    }
    n->next->pre = n->pre;
    n->pre->next = n->next;
    add_Node(n);
}

//弹出链表的最后一个，由于是循环链表，就是head_node->pre
void LRUCache::pop_back(){
    Node* tmp = head_node->pre;
    head_node->pre = tmp->pre;
    tmp->pre->next = head_node;
    //删除unordered_map中的key
    hash.erase(tmp->key);
}

void LRUCache::show(){
    //链表中没有节点，退出
    if(head_node->next = head_node){
        return;
    }
    Node* tmp = head_node->next;
    while(tmp->next != head_node){
        std::cout<<"key:"<<tmp->key<<",vlaue:"<<tmp->value<<std::endl;
    }
}
int LRUCache::get(int key){
    auto it = hash.find(key);
    if(it == hash.end()){
        std::cout<<"there is no key"<<std::endl;
        return -1;
    }
    //取出key对应的node节点
    Node* node = it->second;
    update_Node(node);
    return node->value;

}
void LRUCache::put(int key, int value){
    auto it = hash.find(key);
    if(it == hash.end()){
        Node* node = new Node(key, value);
        add_Node(node);
        hash.insert({key, node});
        if(hash.size() > capacity){
            
            pop_back();
        }
    }else{
        it->second->value = value;
        update_Node(it->second);
    }
}
```



# 十进制转十六进制

```c++
#include <string>
#include <algorithm>  // 引入std::reverse函数
std::string convert_to_hex(int number) {
    if (number == 0) return "0";  // 处理输入为0的情况
    std::string result;
    while (number > 0) {
        int y = number % 16;  // 取余数得到当前的十六进制位
        if (y < 10) {
            result += char('0' + y);  // 如果小于10，直接转为字符'0'到'9'
        } else {
            result += char('A' - 10 + y);  // 如果大于等于10，转为字符'A'到'F'
        }
        number = number / 16;  // 除以16进入下一轮计算
    }
    std::reverse(result.begin(), result.end());  // 将结果字符串反转，因为我们是从低位开始构建的
    return result;
}


特殊情况处理：首先检查输入的整数是否为0，因为0是唯一会导致结果为空字符串的情况。如果输入是0，直接返回字符串"0"。

初始化结果字符串：创建一个空字符串result，用于存放最终的十六进制字符串结果。

循环处理每一位：

使用while循环，条件是输入的整数number大于0。
在循环体内，使用%操作符取得number除以16的余数，这个余数即为当前十六进制位的值。将其存储为变量y。
判断y的值：
如果y小于10，直接将y转换为对应的字符（'0'到'9'），并将其添加到结果字符串result的末尾。
如果y大于或等于10，将y转换为对应的字符（'A'到'F'），并将其添加到结果字符串result的末尾。
使用/操作符将number除以16，为处理下一位做准备。
反转结果字符串：由于在循环中我们是从低位到高位构建字符串的，所以最后需要使用std::reverse函数将结果字符串反转过来，确保高位在前。

返回结果：返回存储十六进制表示的字符串result。

```









# 七大查找算法

### 顺序查找

顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

**顺序查找的时间复杂度为O(n)。**



### 二分查找

**说明：元素必须是有序的，如果是无序的则要先进行排序操作。**

要查找的元素必须是有序的

**时间复杂度为O(logn)**



### 插值查找

**基本思想：**基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。

对于差值查找来说，二分查找更近似于一种傻瓜式的查找方式。因为二分查找每次都从mid开始的，这样比较呆，没有很大的自主性。

因此对于差值查找：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，这种方式来自适应选择，减少比较次数



### 斐波那契查找

**基本思想：**也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。



### **二叉查找树（BST）**

> 二叉查找树的性质：
>
> 1. 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> 2. 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> 3. 任意节点的左、右子树也分别为二叉查找树。
>
> **它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。**
>
> 
>
> 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。





### AVL树（平衡二叉树）

> AVL是一种高度平衡的二叉树，本质也是一颗二叉查找树，有以下两个特点：
>
> 1. 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
> 2. 左右两个子树也都是一棵平衡二叉树。
>
> 这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多

AVL树主要的难点在于插入和删除

- 插入

| 插入位置                                              | 状态   | 操作   |
| ----------------------------------------------------- | ------ | ------ |
| 在结点T的左结点（L）的 **左子树（L）** 上做了插入元素 | 左左型 | 右旋   |
| 在结点T的左结点（L）的 **右子树（R）** 上做了插入元素 | 左右型 | 左右旋 |
| 在结点T的右结点（R）的 **右子树（R）** 上做了插入元素 | 右右型 | 左旋   |
| 在结点T的右结点（R）的 **左子树（L）** 上做了插入元素 | 右左型 | 右左旋 |

[参考链接](https://blog.csdn.net/xiaojin21cen/article/details/97602146)

又回看了以便，其实插入位置为左左型和右右型的其实是一个东西，本质上都是一次旋转就行了，注意有个节点需要断开原先的连接

像左右型和右左型这种都需要两次旋转，但是这两次旋转本质上和一次旋转一模一样，所以说这四种插入位置其实本质上都差不多的。



### 字典树

- 什么是字典树？

  字典树我愿意给他叫做单词查找树，利用字符串的公共前缀来降低查询时间进而提高效率。有以下三个性质：

  1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
  2. 总根节点到某一个节点，路径上的字符连接起来为该节点对应的字符串。
  3. 每个节点所有子节点包含的字符都不同。

- 字典树的使用范围

  1. 词频统计

     如果内存有限，hash表所占的空间很大，我们就可以用trie树来压缩下空间，因为公共前缀都是用一个节点保存的。

  2. 前缀匹配

     ​	

### 2-3查找树

- 定义

  相比于AVL树对平衡性的严格要求，2-3查找树相对灵活一些。这里面2-3查找树允许一个节点保存多个键。

  通常我们将一棵标准的二叉查找树成为2-节点，因为每个节点都只有一个键（关键字）和两个链接

  但是2-3查找树引入了3节点，表示一个节点中有两个关键字和三个节点。

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210830095228.jpeg" alt="img" style="zoom:67%;" />

- 性质

  1. 任意一个节点都有1个或者2个关键码
  2. 当节点有1个关键码的时候，节点有2个子树
  3. 当节点有两个关键码的时候，节点有3个子树
  4. 所有叶子节点都在树的同一层



### 红黑树

> 

线性查找 —性能低—>二分查找— 二查叉树会出现退化成链表的问题—>出现AVL平衡二叉树—数据变化有频繁更新节点问题(即AVL变态的平衡)—>出现红黑树

AVL树和红黑树都是由二叉树繁衍而来，这两个数有不同的适用条件：

1. 如果有频繁的插入和删除的话，不要用AVL数，因为其变态的平衡要求
2. 如果频繁的查找，但是插入和删除不多的话用AVL树的话是可以的

[参考链接](https://www.cnblogs.com/skywang12345/p/3245399.html)

红黑树本质上也是一种二叉查找树，但是他是自平衡的，在插入和删除可能会破坏树的结构的情况下需要自行处理以达到平衡状态。

红黑树有以下特性：

1. 每个节点不是黑色就是红色
2. 根节点是黑色
3. 如果一个节点为红色，则子节点必为黑色
4. 任意一个节点到每个叶子节点的路径上都包含数量相同的黑节点（这个时候null节点不算进去）
5. 每个叶子节点（NULL）都是黑色的。（红黑树吧null节点当做了叶子节点）

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210830101402.jpeg" alt="img" style="zoom:67%;float:left" />

- 左旋和右旋

  左旋和右旋是一个相对的概念，但是只要记住：对一个节点左旋的时候，意味着将这个节点变成左节点，如果这个节点是根节点的话，那么也变成左节点，他的右节点就是这个节点的根节点

  ```c++
                                 z
     x                          /                  
    / \      --(左旋)-->       x
   y   z                      /
                             y
  ```

  右旋也是一样的，x节点变成右孩子节点，左旋就是变成左孩子节点。然后x节点的左孩子节点变成x节点的根节点

  ```c++
                                 y
     x                            \                 
    / \      --(右旋)-->           x
   y   z                            \
                                     z
  ```

- 插入

- 删除



### B-tree

对于树结构的查找来说，有以下几种：二叉查找树，平衡二叉查找树，红黑树，B-tree等等。对于二叉树来说，查找的为log2N，很明显和树的深度有关，因此在数据量特别大的时候，我们需要尽可能降低树的深度来提高查询效率。但是如果减少树的深度，那么每棵树上的节点数就会很多，这样还是退化到了对于节点的线性查找，可能时间复杂度还会增加，怼到线性的。因此我们想要降低树的深度就要采用多叉树结构。因此B树就是一个多叉树，为了降低磁盘频繁的查找操作而设计的。



B树也称B-树,它是一颗多路平衡查找树。二叉树我想大家都不陌生，其实，B树和后面讲到的B+树也是从最简单的二叉树变换而来的

B树有用度定义的，有用阶定义的。在这里我写的话就用阶的概念来定义，阶就是说这个树最多有多少个子节点数，用m表示。m取2的时候就表示我们的二叉树

> **度数：**每个节点子节点的个数称为该树的度。
>
> **阶数：**一个节点的子节点数目最大值。 



用阶定义B数如下图：

1. 根节点不是叶子节点至少要有两个子节点，非根节点至少有m/2个子节点，取上限。
2. 有n个子节点的节点恰好包含n-1个关键字
3. 每个节点中的关键字都是按照从小到大的顺序排列的，同时每个关键字的左子树中的关键字均小于它，右子树中的关键字均大于它。
4. 所有叶子节点都在同一层中

下图所示就是一个阶为4的B树：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210829202308.png" alt="clip_image002" style="float: left;" />

B+树的叶子节点内部结构如下图：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271806151.jpeg" alt="img" style="zoom:67%;float:left" />

本质上说叶子节点存储的也不是数据，而是数据指针，指向磁盘中的数据。

> 通常在实际应用中B树的阶都很大，通常大于100。因此即使存储了大量的数据，B树的高度仍然比较小。**每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。**

- **查找**

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203121123001.png" alt="img" style="zoom:150%;float:left" />

  如上图所示，根据根节点004和008可得，有小于004，大于004小于008和大于008三种情况，分别对应三个子树，就这样查找如果树结构里面没有包含所要查找的节点则返回null，总体来说，B树的搜索流程跟普通二叉搜索树的搜索流程大体类似。

  所以B树的查询并不稳定，根节点中关键字可能只需要1次IO操作，但是如果在叶子节点中可能需要树高度次磁盘IO操作

- **插入操作**

  1. 树中已经存在当前的key，则更新value

  2. 若当前节点的关键字个数小于m-1，则正常插入

  3. 若加入key后当前节点的个数大于m-1， 则以当前节点中所有关键字的中间为基准点开始分裂，将基准点的key值放入到父节点（因为B数要求左边小于父节点，右边大于父节点），当前基准值的左子树都比他小，右子树都比他大。

     > 举一个5阶树的列子：
     >
     > 1. 未插入元素前：
     >
     >    <img src="https://segmentfault.com/img/remote/1460000020416580" alt="img" style="zoom:80%;float:left" />
     >
     > 2. 插入22后，图如下，就不满足5阶B树的定义了
     >
     >    <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271041828.png" alt="img" style="zoom:80%;float:left" />
     >
     > 3. 分裂中间基准点40
     >
     >    <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271042772.png" alt="img" style="zoom:80%;float:left" />
     >
     > 4. 接着插入23，25，39，然后继续分裂，如下：
     >
     >    <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271043750.png" alt="img" style="zoom:70%;float:left" />
     >
     >    <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271043889.png" alt="img" style="zoom:70%;float:left" />
     >
     > 以上就是B树的插入过程。

- **删除操作**

  1. 如果不存在对应的key，则删除失败
  2. 如果删除的是叶子节点中的关键字，则删除就行
  3. 若当前删除的key位于非叶子节点，则用key的后继节点替换当前要删除的节点，然后把这个后继节点删除（后继节点一定位于叶子节点上）。.

- **复杂度分析**

  具体分析看B+树中，我把B+和B树一起给分析了，这俩时间复杂度是一样的。

  



### B+ Tree

[参考](https://zhuanlan.zhihu.com/p/149287061)

B+树是b树的一种变体，广泛的用在存储引擎中。

**和B树的相同点：**

根节点不是叶子节点至少要有两个子节点，非根节点至少有m/2个子节点，取上限。

**和B树的不同点：**

1. B+树有两种类型的节点：**索引结点**和叶子结点。索引节点就是非叶子节点，内部节点不存储数据，只存储索引（即key），数据都存储在叶子节点。
2. 非叶子节点中，有n颗子树就包含n个key
3. 非叶子节点中包含的是子树中最大或最小的key
4. 所有叶子节点中包含了全部关键字的信息， 及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；

如下图所示：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271125492.png" alt="image-20220327112534330" style="zoom: 67%;float:left" />

> 

- **查找**

  **查询单个元素**

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271336870.jpeg" alt="img" style="zoom:80%;float:left" />

  比如说查询元素59。第一次磁盘IO，访问根节点。然后发现59<=[59,97]，访问当前节点的第一个孩子节点。第二次磁盘IO，发现59>=[15,44,59]，访问当前节点的第三个孩子节点。第三次磁盘IO，访问叶子节点[51,59]，顺序遍历内部节点找到59

  可以看到，B+树查找每个元素所用的磁盘IO数量一样

  **区间查询元素**

  区间查询的关键点在于叶子节点中，每个叶子节点都有一个指向下一个叶子节点的$P_{next}$指针。

  为了更好地对比B树和B+树他们区间查询的优势，我先说一下B树的，查询21<=key<=63

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271345334.jpeg" alt="img" style="zoom: 50%; float: left;" />

  首先找到21所在的节点，上图中在叶子节点。然后从关键字21开始进行中序遍历，关键字依次为37、44、51、59、72、63。不考虑中序遍历过程的压栈和入栈操作，磁盘IO就多了两次(72、63)

  再来看B+树的区间查找：

  <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271410643.jpeg" alt="img" style="zoom:80%;float:left" />

  根据每个节点的索引找到叶子节点[21、37、44]后找到左端点21，接着不需要中序遍历，而是链表形式的遍历，从21找到63，没有任何额外的磁盘IO操作

- **插入**

  要注意一下几点：

  1. 插入的操作全部都在叶子结点上进行，且不能破坏关键字自小而大的顺序；
  2. 由于 B+树中各结点中存储的关键字的个数有明确的范围，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行 “分裂”；

  插入有三种情况：

  1. 若被插入关键字所在的结点，其含有关键字数目小于阶数 M，则直接插入；

     <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271415782.gif" alt="img" style="zoom: 67%;float:left" />

  2. 若被插入关键字所在的结点，其含有关键字数目等于阶数 M，则需要将该结点分裂为两个结点，一个结点包含 `⌊M/2⌋` ，另一个结点包含 `⌈M/2⌉` 。同时，将`⌈M/2⌉`的关键字上移至其双亲结点。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。

     <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271417517.gif" alt="img" style="zoom: 39%;float:left" />

  3. 在第 2 情况中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。

     <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203271418620.gif" alt="img" style="zoom: 67%;float:left" />

- **删除**

  1. 删除该关键字，如果不破坏 B+树本身的性质，直接完成删除操作；
  2. 如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值；
  3. 在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并（情况 3、4 和 5）。（注意这两种方式有时需要更改其父结点中的索引值。）

- **复杂度分析**

  B+树 是 B-树的一个升级版本，在存储结构上的变化，由于磁盘页的大小限制，只能读取少量的B-树结点到内存中（因为B-树结点就带有数据，占用更多空间，所以说是 **少量**）；而B+树就不一样了。因为非叶子结点不带数据，能够一次性读取更多结点进去处理，所以对于同样的数据量， B+树更加 "矮胖"， 性能更好。但是两者在查找、插入和删除等操作的时间复杂度的量级是一致的，均为$O(log_mN)$，其中m是阶数，N是关键字个数

  求查找时间复杂度也就是树的高度。对于B树和B+树来说，树的高度为h，一个节点存储m个关键字，有N个关键字，则满足$N=m^h$，所以$h=log_mN$。同时一个节点中包含的key数量是m，需要$O(m)$的时间复杂度，但是对这些节点key的遍历是放在内存中的，时间可以忽略，我们更加关注的是磁盘IO次数，即树的高度，所以B树和B+树两者在查找、插入和删除等操作的时间复杂度的量级是一致的，均为$O(log_mN)$，其中m是阶数，N是关键字个数



> **B树比B+树的优势在于：**
>
> 1. 如果经常访问的数据离根节点很近，而B树的非叶子节点存储关键字数据的地址，所以这种数据检索的时候会要比B+树快。
>
> **B+树比B树的优势在于：**
>
> 1. B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;(logn)
> 2. B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，查询区间数据时更方便，数据紧密性很高，缓存的命中率也会比B树高。
> 3. B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
> 4. 适合区间查询，需要的磁盘IO数少

**一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。**



### 树表查找

二叉搜索树（BST）、2-3树、红黑树、B/B+树

**基本思想：**二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 



### 分块查找

分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

**算法思想：**将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；

分块查找是有序查找的一种改进吧，即把元素放到不同的块儿中。每一块儿中的节点不必有序，但是块与块之间必须有序

即第一块任意元素的关键字都必须小于第二块任意元素的关键字。

先用二分查找到在那一块，然后再进行顺序查找。



### 哈希查找

**算法思想：**哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

> key - value键值对，是一种时间换空间的算法。

#### 哈希表

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度（以时间换空间的思想）。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。 

##### 常见的常见的散列函数

- 直接寻址法

  取关键字或关键字的某个线性函数值为散列地址

- 平方取中法

  当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址

- 随机数法

  择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不等的场合

- 除留余数法

  取余，取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key % p, p <= m

##### **怎么解决哈希冲突**

- 开放寻址法

  当发生哈希冲突后，就去寻找下一个空的散列地址，只要散列表足够大，这个空的位置一定能找到

- 再散列法

  当散列表元素太多（即装填因子 α 太大）时，查找效率会下降；当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫做“再散列（Rehashing）”。Hash 表中每次发现 loadFactor==1 时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素全部转移过来到新的桶数组中。注意这里转移是需要元素一个个重新哈希到新桶中的。实用最大装填因子一般取 0.5 <= α<= 0.85

- 链地址法

  当发生冲突时，该位置上的数据会用链表链起来，当表中的某些位置没有结点时，该位置就为 NULL。但是当数据特别大时候，可能链表也很长，查找变成O(n)

  优化：使用红黑树等树形结构来存储，但是要注意红黑树有排序，需要自定义排序算法。

- 公共溢出区 

  为所有冲突的关键字记录建立一个公共的溢出区来存放。在查找时，对给定关键字通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表进行顺序查找。如果相对于基本表而言，在有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。

##### Hash表的扩容

**什么时候扩容？**

当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值(即当前数组的长度乘以加载因子的值的时候)，就要自动扩容了。

**扩容**

在hash表的实现中，我们一般会控制一个装载因子，当装载因子过大的时候，会考虑扩容（resize）

 如果一个hash表中桶的个数为 size , 存储的元素个数为used .则我们称 used / size 为负载因子loadFactor . 一般的情况下，当loadFactor<=1时，hash表查找的期望复杂度为O(1). 因此。每次往hash表中加入元素时。我们必须保证是在loadFactor <1的情况下，才可以加入。

当我们加入一个新元素时。一旦loadFactor大于等于1了，我们不能单纯的往hash表里边加入元素。Hash表中每次发现loadFactor==1时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素所有转移过来到新的桶数组中。注意这里转移是须要元素一个个又一次哈希到新桶中的。

缺点：容量扩张是一次完毕的，期间要花非常长时间一次转移hash表中的全部元素。这样在hash表中loadFactor==1时。往里边插入一个元素将会等候非常长的时间。

> redis中的dict.c中的设计思路是用两个hash表来进行进行扩容和转移的工作：当从第一个hash表的loadFactor=1时，假设要往字典里插入一个元素。首先为第二个hash表开辟2倍第一个hash表的容量。同一时候将第一个hash表的一个非空桶中元素所有转移到第二个hash表中。然后把待插入元素存储到第二个hash表里。继续往字典里插入第二个元素，又会将第一个hash表的一个非空桶中元素所有转移到第二个hash表中，然后把元素存储到第二个hash表里……直到第一个hash表为空。













# 智力题

## 智力题



### 101硬币，里面有1假币，用2次天平，判断假币更重还是更轻（阿里云）

第一次天平两边各放50个，会出现两种情况：
1. 平衡：那么剩下的肯定是假币，将它与真币对比即可
2. 不平衡：将其中一堆50个的分为两堆25的（如拿轻的），放天平两边，会出现两种情况：
    * 平衡：则假的在另一堆，假币更重
    * 不平衡：假的就在这堆，假币更轻

2、



### 64匹马，8个赛道，找出前四名最少需要比赛多少场？（腾讯、字节）

可不可以计时？ 可以->8场结束，不可以->老实分治

> 方法一

<img src="https://pic4.zhimg.com/80/v2-2aa7bc15744408f6e13e160ca1284a17_720w.jpg" alt="img"  />



> 方法二

<img src="https://pic4.zhimg.com/80/v2-3083b6b2ec82d2821612d4acff5a28e3_720w.jpg" alt="img" style="zoom:80%;" />

1. 每八匹马一组进行分组，然后按照分组进行比赛，淘汰每个小组的后面4名（8场）

   <img src="https://pic1.zhimg.com/80/v2-e8e4c01ebfab969c0a209e9615e7efd0_720w.jpg" alt="img" style="zoom:80%;" />

2. 然后每个小组的第一名进行比赛，淘汰后四名及其对应的小组（1场）

3. 此时已经可以知道第一名了，然后需要在剩下9匹马中找到最快的三匹马，将除D1以外8匹马进行比赛，此时有两种结果：

   - C1是第二名，那么D1可能是第三名，需要进行加赛
   - C1不是第二名，那么 D1不可能是第三名了，直接取比赛中的前三名



### 如何快速找出1000个瓶子中的一瓶毒药（微软、腾讯pcg）

> 这道题的描述方式很多，但都是万变不离其宗

1. 1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？（并说出怎么检测）



> 基本思路

1000个药剂只有一个是毒药，所以有一千种状态。然后老鼠有两个状态（生/死），所以10只老鼠就可以表示 $$2^{10}=1024$$ 个状态。

- 把1000瓶标号：1,2,3,4,5,6...1000. `（十进制编号）` 。

- 所有老鼠排列在一起组成一个 `2进制` 队列: 0000000000。（0代表不喝，1代表喝 ）

  ```
  0000000001代表第一瓶水被喝情况
  0000000010代表第二瓶水被喝情况
  0000000011代表第三瓶水被喝情况
  0000000100代表第四瓶水被喝情况
  ...
  1111101000代表第1000瓶水被喝情况
  ```

- 第7天，喝了毒药的老鼠都死了，那个二进制队列转为为十进制就是毒药的标号。

  ```
  比如第3只老鼠死亡，其他老鼠没死，队列为0000000100，第4瓶水有毒。
  第1，5，6，8老鼠死亡，其他没死，队列为0010110001，第177瓶水有毒。
  ```




### 10堆苹果，每堆10个，9堆里每个重50g，还有一堆每个重40g，只能称一次，找不一样的那一堆

1. 给每堆苹果编号
2. 第一堆里取一个苹果，第二堆里取两个苹果，第三堆里取三个苹果，…，以此类推
3. 共取了55个苹果，如果每堆都是50g，应该共2750g
4. 称一次，看差的斤数是10的多少倍，就知道是十堆苹果里第几堆斤数不够



### 一圈蚊香烧完要用1个小时,用两圈蚊香识别45分钟

1. 同时点燃第一圈的一头和第二圈的两头，第二圈烧完时过去了30分钟
2. 立即点燃第一圈的另一头，第一圈烧完时又过去了15分钟，共计45分钟



### 拿石头问题（博弈）

感觉只要保证最后一个人剩的个数即可。

#### 有10个石头，你和对手两人轮流拿，每人每次可以拿1-2个，最后一个拿的人算输，有什么必赢的方案

对方先拿、保证两个人每一轮回拿满3个（对方拿一个，我拿两个、对方拿两个，我拿一个）。





# 场景题

## 海量数据处理

### 海量手机号保存（百度二面）

> 如果有海量的手机号数据需要保存，但机器的性能有限，如何才能尽可能少的占用内存？

1. **手机号划分**

   **手机号依据字段的含义进行划分为三部分**，即 aaa-bbbb-cccc，其中前两个部分有特定的含义，如号段、区号等，而第三部分是随机的，所以手机号的前两个部分会有大量的重复，因此可对前两部分进行压缩，使用少数几个字符来表示。当然对于前面一致的部分可以考虑使用**前缀树**进行存储。

2. **存储偏移量**

   对号码进行**排序**，然后使每一个手机号减去最小的手机号得到一个差值，作为**偏移**，这样的话只需要记住最小的手机号和后面每个手机的偏移就可以了，这样可以大大减低内存占用。



### 重复/不重复数据 问题

#### 在海量数据中找到重复最多的一个

假设我们可以用的内存是64M，总的数据量是1024 * 64M即64G。

1. 预设多个小文件（如1024个）作为桶，每读到一条记录就进行哈希计算，将获得的哈希值余上 1024 ，将该记录放到对应的桶中。
2. 由于相同记录的哈希值相同，所以重复的数据一定放在同一个桶，在桶中记录数据的值和数量。
3. 当全部数据读取完成后，依次对所有子文件进行内部排序，如果内存允许的话，可以一次性把所有数据读到内存中进行快速排序，得到 1024 个桶内的最大重复记录。
4. 对这 1024 个桶的最大值进行比较（归并排序），获得最终的最大值就是重复最多的一个。

时间复杂度：O(N) + 100\*O(N1) + O(n\*logn)



#### 两个大文件中找出二者重复的数据

**具体描述：**

给定a、b两个文件，各存放50亿个url，每个 url 各占 64 字节，内存限制是 4G，找出a、b文件共同的 url

1. 假如每个url大小为 64 Bytes，那么可以估计每个文件的大小为 50G×64=320G，远远大于内存限制的4G，所以不可能将其完全加载到内存中处理，可以采用分治的思想来解决。
2. 遍历文件a，对每个url求取hash(url) % 1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999，每个小文件约300M）;
3. 遍历文件b，采取和 a 相同的方式将url分别存储到1000个小文件(记为b0,b1,...,b999)；
4. 由此，两个文件中相同的 url 一定在序号相同的小文件中，所以只需要找出相同序号文件中相同的 url 即可。
5. 把文件 ai 的 url 存储到 hash_set/hash_map 中。然后遍历 bi 的每个 url，看其是否在刚才构建的 hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。



#### 海量数据中找出不重复的数字

- [ ] 位图

例如：2.5亿个整数中找出不重复的整数的个数。

思路： 用 2BitMap 表示一个数是否存在，32bit中无符号整数有4G个，共需 4G bits，每个字节8 bits，需要 2*4G/8 = 1G 字节。所以用 1GB 就可以表示所有的32位无符号整数的状态。

1. 申请 1G 内存，作为一个数是否存在的标记flag，全清0
2. 读入一个数，每个正整数用两个bit的标志位，00表示没有出现，01表示出现1次，10表示出现多次，11无意义
3. 重复2，直到所有整数处理完毕
4. 扫描位图，如果标志位为00（=0），则将对应位置的标志置为01（=1）。如果为01，则置为10（=2）。

也可以将 hash 划分小文件，小文件使用 hash_set 检查各个元素得到的。







### TOP K 问题

#### [100亿数据找最大的一万个数，找第k大的数](https://github.com/pengkaii/CPP_interview/blob/main/cpp基础.md#100亿数据找最大的一万个数找第k大的数)

1. **找最大的一万个数**：

   **使用最小堆**（Min-Heap）。这种数据结构可以在O(logm)的时间内插入和删除元素，其中 m 是堆中的元素数量。

   步骤：

   - 创建一个容量为 10,000 的最小堆。
   - 遍历数据集中的每个数字：
     - 如果堆不满（即数量小于10,000），则向堆中插入该数字。
     - 如果堆已满并且当前数字大于堆顶的数字（堆顶是目前堆中的最小数字），则删除堆顶的数字，并将当前数字插入堆中。
   - 当所有数字都已遍历完，堆中的数字就是最大的10,000个数字。

   这种方法的时间复杂度近似为 O(nlogm)，其中 n 是数据集的大小，m 是要找的数字的数量（在这里 m = 10,000）。这个算法的时间复杂度是O(nlog(k))，因为你需要处理n个元素，每次处理元素的时间复杂度是O(log(k))。

   **使用分治**，我们可以将原始的数据分成若干小组，然后分别在每个小组中找到最大的一万个数。最后，从这些小组的结果中选出整体的最大一万个数。

   步骤：

   1. 将100亿个数分成若干小组。例如，每组有1000万个数。
   2. 对于每一组，使用任意方法（如排序或最小堆）找到该组中最大的一万个数。
   3. 将所有小组中选出的数合并成一个列表，这个列表有的元素数量会是 10000 * 小组的数量。
   4. 最后，再从这个合并后的列表中选出最大的一万个数。

2. **找第 k 大的数**：

   快速选择的基本思想是：如果基准元素在排序数组中的位置是 k，那么基准元素就是第 k 大的数。

   1. 快速选择（QuickSelect）算法就是基于分治思想的。

      步骤：

      1. 从列表中随机选择一个元素作为基准。
      2. 将列表分成两部分：一部分包含比基准小的元素，另一部分包含比基准大的元素。
      3. 判断 k 是在基准的左边还是右边：
         - 如果 k 等于右边部分的大小加1，那么基准就是我们要找的第 k 大的数。
         - 如果 k 小于右边部分的大小，说明第 k 大的数在右边，对右边的数据递归执行快速选择。
         - 否则，第 k 大的数在左边，对左边的数据递归执行快速选择，并对 k 进行相应调整。
      4. 递归进行，直到找到第 k 大的数。

      可以在平均情况下以 O(n) 的时间复杂度找到第 k 大的数。在最差的情况下，其时间复杂度是 O(n^2)，但可以通过随机化选择基准元素来避免这种情况。

   在分治思想的应用中，关键是如何将原问题分解成一个或多个更小的子问题，然后如何合并这些子问题的答案来得到原问题的答案。







#### 如何从 5 亿个数中找出中位数？

从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为第 `(N+1)/2` 个数；当样本数为偶数时，中位数为第 `N/2` 个数与第 `1+N/2` 个数的均值。

思路：如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 `O(NlogN)` 。这里使用其他方法。**双堆法（小量数据）或者分治法（大量数据）**。

**（1）双堆法**

维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。若数据总数为**偶数**，当这两个堆建好之后，**中位数就是这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，**中位数一定在数据多的堆的堆顶**。

**（2）分治法**

分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

#### 10 亿个数中找出最大的 10000 个数

因为 10 亿个数没有办法全部读入内存，可以考虑使用**堆排序**。

**思路：**堆排序 + 分治优化

1. 先拿 10000 个数建小顶堆，然后依次添加剩余的数，如果大于堆顶的数，就将这个数替换堆顶的数，然后调整小根堆的结构。这样，遍历完后，堆中的10000个数就是所需的最大的10000个。
2. 优化：将 10 亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果（归并排序）。

时间复杂度：O(n*logm) 


