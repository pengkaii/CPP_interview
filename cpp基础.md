# C++基础=========================

## 指针与引用

### 指针与引用的区别

四个：定义、初始化、合法性、可变性

1. **定义**：指针存放的是某个对象的地址，引用表示的是一个对象的别名。
2. **初始化**：引用在定义的时候必须进行初始化，但是指针不需要。
3. **判断合法性**：因为引用在定义的时候必须进行初始化，所以在使用的时候不需要判断它是否为空。但是指针需要。
4. **是否可变**：指针可以被重新赋值来指向其他的对象，但是引用总是指向在初始化就被指定的对象，不可变，类似于指针常量。
5. 指针可以有多级，引用只有一级
6. sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小



指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。

在程序编译的时候，将指针和引⽤添加到符号表中。

**指针**它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为空，sizeof 指针得到的是指针类型的⼤⼩。

**引⽤**，它只是⼀块内存的别名，在添加到符号表的时候，是将"引⽤变ᰁ名-引⽤对象的地址"添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。

sizeof 引⽤得到代表对象的⼤⼩。⽽ sizeof 指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。

作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引⽤的实质是传地址，传递的是变ᰁ的地址





### 指针和数组名区别

1. 二者均可通过**增减偏移量**来访问数组中的元素。
2. 数组名不是真正意义上的指针，可以理解为指针常量，所以数组名没有自增、自减等操作。
3. 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。



### 数组和链表的区别

- 数组是一个连续的内存块，而链表是由一系列节点组成，节点在内存中可以不连续
- 数组大小是固定的，链表大小可以动态变化
- 数组插入和删除比链表耗时
- 数组随机访问是O(1)的，链表必须遍历找到，O(n)的



**强引用和弱引用的区别**

编译器默认函数和**已初始化的全局变量**为强符号，而未初始化的全局变量为弱符号。

- 当两者都为强符号时，报错：redefinition of 'xxx'
- 当两者为一强一弱时，选取强符号的值
- 当两者同时为弱时，选择其中占用空间较大的符号，选择占用空间大的符号至少不会造成诸如溢出、越界等严重后果。

**引用占用内存空间？**

对引用取地址，其实是取的引用所对应的内存空间的地址。这个现象让人觉得引用好像并非一个实体。但是引用是占用内存空间的，而且其占用的内存和指针一样，因为引用的内部实现就是通过指针来完成的。



### **引用作为函数参数、返回值的好处：**

对比值传递，**引用传参的好处：**

1、在函数内部可以对此参数进行修改
2、提高函数调用和运行的效率（所以没有了**传值和生成副本的时间和空间消耗**）

用引用作为返回值最大的好处就是在**内存中不产生被返回值的副本**。

**但是返回值有以下的限制：**

1、**不能返回局部变量的引用**。因为函数返回以后局部变量就会被销毁
2、**不能返回函数内部new分配的内存的引用**。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
3、**可以返回类成员的引用，但是最好是const**。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。







### 指针传递、值传递、引用传递的区别

- **值传递：**形参是**实参的拷贝**，函数对形参的所有操作不会影响实参。形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入。当函数内部可能需要改变参数具体的内容时，我们则采用形参，在组成原理上来说，对于**值传递的方式我们采用直接寻址**。
- **指针传递：**本质上是**值传递**，只不过**拷贝的是指针的值**，拷贝之后**实参和形参是不同的指针**，但指向的**地址都相同**。通过指针可以**间接的访问指针所指向的对象**，从而可以修改它所指对象的值。在组成原理上来说，对于指针传递的方式一般采用**间接寻址**。
- **引用传递：**当形参是引用类型时，我们说它对应的实参被引用传递。当然不同的编译器对于引用有不同的实现，部分编译器在**底层是使用指针**来实现引用传递。
- 函数调用的方式，大部分的编译器**按照函数形参定义的逆序，依次将参数压入栈内**，上述提到参数的形式，如果是**值传递，则压入栈中的是一个临时变量**，该变量与传入的值内容相同；如果是**指针传递或者引用传递**，则压入栈的可能是一个**临时的指针变量**，该指针指向与传入的指针指向的内容相同。从函数调用机制来开，不管何种调用所有实参的传入时都在栈中开辟了空间



### 指针定义、函数指针、void泛型指针

- **指针的定义:**
  
  - 指针是一种变量类型，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。在 64 位计算机中，指针占 8 个字节空间。
  - 使用指针时可以用以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值
- **指针的用法：**
  - 空指针: C 语言中定义了空指针为 NULL，实际是一个宏，它的值是 0，即 #define NULL 0。C++ 中使用 nullptr 表示空指针，它是 C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。
  - 指向常量对象的指针：常量指针，`const` 修饰表示指针指向的内容不能更改。
  - 指向函数的指针：函数指针。
  - 指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。
    - 特别注意：定义指向成员函数的指针时，要标明指针所属的类。
    - 而对于函数类型到函数指针类型的默认转换，只有当函数类型是左值的时候才行。所有对于非静态的成员函数，就不存在这种从函数类型到函数指针类型的默认转换，于是编译器也就不知道这个 p = A::add 该怎么确定
    - 由于非静态成员函数指针可以有多态行为，在编译期函数地址可能无法确定。
    - 静态成员函数指针在编译期函数地址则可以确定。
  - this 指针：指向类的当前对象的指针常量。
  
  
  
  **函数指针的定义**

- **函数指针：**函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。
  
  - 所有的函数最终的编译都生成代码段，**每个函数的都只是代码段中一部分而已**，在每个函数在代码段中都有其**调用的起始地址**与结束地址，因此可以用**指针变量**指向函数的在**代码段中的起始地址**。
  
- 需要注意的是，对于 fun1 和 &fun1:
  - 函数名 fun1 存放的是**函数的首地址**，它是一个函数类型 void，**&fun1 表示一个指向函数对象 fun1 的地址**，是一个指针类型。它的类型是 int (*)(int,int)，因此 fun1 和 &fun1 的值是一样的；
  
  - &fun1 是一个表达式，函数此时作为一个对象，取对象的地址，该表达式的值是一个指针。
  
  - 通过打印 sizeof 即可知道 fun1 与 &fun1 的区别；
  
    
  
  **void（泛型指针）：**
  
  指针是对内存区域的抽象。指针变量中存放着目标对象的内存地址，而与指针相复合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它（地址的作用），并且合理地使用它（类型的作用）。void* 只有其中一半的作用。因为没有明确与指针相复合的类型，所以不能解引用，也不能使用基于类型之上（sizeof(T)）的指针运算。



### 指针没有初始化（野指针）

没有初始化的指针叫做**野指针**

指针未初始化能通过编译，但是运行的时候可能报错也可能不报错。因为你如果没使用这个指针，那倒是无所谓。但是如果你使用了，可能会出问题。因为这个指针由于没有初始化，可能会指向任何内存空间，完全随机的，有两种情况：

1. **指向的地址是系统使用的内存**，用户程序不能使用，如果用户程序使用则会报错
2. **指向的不是系统的内存，不报错**。但是如果这个指针指向了你之前程序使用过的内存，则你在个指针赋值，就会修改之前的内存上的数据，也会出问题。

**指针变量设置为nullptr表明它不指向任何内容,**这样引用她也不会出现上面的问题。



**空指针到底是什么？**

 由系统保证**空指针不指向任何实际的对象或函数**，也就是说，**任何对象或者函数的地址都不可能是空指针，空指针与任何对象或函数的指针值都不相等**。空指针表示“未分配”或者“尚未指向任何地方”。它与未初始化的指针有所不同，**空指针可以确保不指向任何对象或函数，而未初始化指针可能指向任何地方。**



### 野指针和悬空指针

**悬空指针：**若**指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”**。如果对悬空指针再次释放可能会出现不可预估的错误，比如可能该段内存被别的程序申请使用了，而此时对该段内存进行释放可能会产生不可预估的后果。

**野指针：**“野指针” 是指不确定其指向的指针，**未初始化的指针**为“野指针”，未初始化的指针的初始值可能是随机的，如果使用未初始化的指针可能会导致段错误，从而程序会崩溃

#### 如何避免野指针: 

指针**在定义时即初始化**，指针在**释放完成后，需要将其置为空**。

- 指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。
- 指针p被free或者delete之后，没有置为NULL。解决办法：指针指向的内存空间被释放后指针应该指向NULL。
- 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。



**基础变量没有初始化怎么样**

不怎么样，不使用他就行。

建议变量**在构造函数时均初始化完成，避免不必要的问题**。比如变量char buf[2000]，把字符串"hello world"拷贝进入buf，恰好EOF("\0")没有被复制，由于**没有使用memset初始化变量，buf空间时随机值,那么调用print，strcmp之类的操作时**，有可能会因为没有EOF,导致访问到非法地址，然后程序异常。















### C++程序优化方法（i++、++i)

- 空间足够时，可以将经常需要读取的资源，缓存在内存中。
- 尽量**减少大内存对象的构造与析构**，考虑缓存暂时不用的对象，等待后续继续使用。
- 尽量使用C++11的右值语义，**减少临时对象的构造**。
- 简单的功能函数可以使用内联。少用继承，多用组合，尽量减少继承层级。
- 在循环遍历时，优化判断条件，减少循环次数。
- **优化线程或进程的同步方式，能用原子操作的就不用锁**。能应用层同步的就不用内核对象同步。
- 优化堆内存的使用，如果有内存频繁的申请与释放，可以考虑内存池。
- 优化线程的使用，节省系统资源与切换造成的性能损耗，线程使用频繁的可以考虑线程池。
- 尽量使用事件通知，谨慎使用轮循或者sleep函数。
- 界面开发中，耗时的业务代码不要放在UI线程中执行，使用单独的线程去异步处理耗时业务，提高界面响应速度。
- 经常重构、优化代码结构。优化算法或者架构，从设计层面进行性能的优化。

**前置++与后置++的区别**

前置++：

当执行前置增量操作时（例如++it，其中it是一个对象），它直接增加it的值，并返回增加后的值（或对象的引用）。
在这个过程中，没有任何临时对象被创建。


后置++：
对于后置增量操作（例如it++），首先需要返回当前的it值，然后再增加它。
为了返回当前值并在稍后增加它，必须创建一个临时对象来保存原始的it值。这就是性能损失的主要原因。

```c++
// 前置++
self &operator++() {
    node = (linktype)((node).next);
    return *this;
}

// 后置++
const selt operator++(int) {
    selt temp = *this;
    ++*this;
    return temp;
}
```

**一些问题：**

**1、为什么后置返回对象，而不是引用**

因为后置为了返回旧值创建了一个临时对象，在函数结束后这个对象就会销毁，不可返回局部变量的引用。

**2、为什么后置前面也要加const**

防止用户使用`i++++`，连续两次调用后置++运算符，使得结果只累加一次，无法产生用户所期望的结果

**3、处理用户的自定义类型**

最好使用前置++，因为不会创建临时对象，不会产生构造和析构所造成的开销











### 普通指针问题、类中有指针问题

**普通指针问题：**

1. **内存泄露**：当你通过 `new` 或者 `malloc` 分配内存时，必须记住在不再需要这段内存时使用 `delete` 或者 `free` 进行释放。否则，将会造成内存泄漏，这是一个严重的问题，特别是在长时间运行的程序中。
2. **悬挂指针**：如果你已经释放了一段内存，但仍然有指针指向它，那么这个指针就被称为悬挂指针。对悬挂指针的访问可能会导致程序崩溃或者数据损坏。
3. **空指针解引用**：空指针不指向任何有效的内存区域。试图解引用一个空指针将导致未定义行为，通常会导致程序崩溃。
4. **数组越界**：如果你有一个指向数组的指针，必须确保你不会访问数组的边界之外。数组越界可能会导致数据损坏或程序崩溃。
5. **所有权问题**：当有多个指针指向同一块内存时，必须明确哪个指针负责释放这块内存。如果多个指针都尝试释放，可能会导致重复释放，从而引发程序崩溃；如果所有指针都没有释放，将导致内存泄露。
6. **类型安全**：指针类型转换需要谨慎处理。错误的类型转换可能导致未定义行为。
7. **内存对齐问题**：在访问某些类型的数据时，指针必须正确对齐。未对齐的访问可能导致未定义行为或性能下降。



**类中有指针问题：**

1. **内存泄漏**：如果你的类中包含指针成员，并且你使用 `new` 在堆上为这个指针分配了内存，那么你需要确保在适当的时候使用 `delete` 释放这块内存。通常，这是在类的析构函数中完成的。如果你没有正确地释放内存，就会发生内存泄漏，这可能会导致你的程序耗尽内存并崩溃。
2. **野指针**：在释放内存之后，你应该将指针设置为 `nullptr`，以防止它成为一个野指针。野指针是指向已经释放的内存的指针，使用野指针可能会导致未定义的行为。
3. **深拷贝与浅拷贝**：当你复制包含指针成员的对象时，需要决定是进行深拷贝还是浅拷贝。浅拷贝仅复制指针本身，这可能导致多个对象共享同一块内存，如果其中一个对象修改了这块内存，或者释放了这块内存，其他对象可能会受到影响。深拷贝会创建指针所指向的内存的一个副本，这样每个对象都有自己的独立内存，但是需要更多的内存和时间。
4. **所有权语义**：如果你的类包含一个指向动态分配内存的指针，你需要定义并文档化这个指针的所有权语义。例如，这个类是唯一可以释放这块内存的地方吗？或者这个类只是一个对这块内存的观察者，而其他类会负责管理这块内存？所有权语义可以帮助你和你的用户理解如何正确地使用和管理这块内存。
5. **异常安全**：如果你的代码可能抛出异常，你需要确保在异常发生时能正确地释放任何已分配的内存。这通常通过使用RAII（资源获取即初始化）技术来实现，例如通过使用智能指针（如 `std::unique_ptr` 或 `std::shared_ptr`）来管理内存。
6. **析构顺序**：需要注意对象析构时的顺序，如果一个对象在析构时还持有对其他已析构对象的指针，并试图访问，那么就可能导致错误。





## 关键字===========

### const与指针

被它修饰的值不能改变，是只读变量，必须在定义时就赋初值

判断方法：看`const`修饰谁

**常量指针（底层const->指向的对象是const）**

pointer to const

```c++
const int* a;
int const* a;
```

`const` 修饰 `*a`，代表指针指向的对象是`const`，不能通过指针修改对象，强调指针对其所指对象的不可改变性。

**指针常量（顶层const->指针本身是const）**

const pointer

```c++
int* const a;
```

`const` 修饰 `a`，代表指针本身就是常量，不可改变指向，强调指针本身的不可改变性，只能在定义时初始化。

**指向常量的指针常量**

```c++
const int* const a;
```

指针指向不可改变和也不可通过指针来改变所指的对象。

#### 常量指针和指针常量的区别

- **指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。**

- **常量指针：**常量指针本质上是个指针，只不过这个指针指向的对象是常量。
  - 特点：const 的位置在指针声明运算符 * 的左侧。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解：* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）
  - `注意 1`：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是**限制了通过这个指针修改变量的值。**
  - `注意 2`：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。
- **指针常量：**指针常量的本质上是个常量，只不过这个常量的值是一个指针。
  - 特点：const 位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。
  - `注意 1`：指针常量的值是指针，这个值因为是常量，所以**指针本身不能改变**。
  - `注意 2`：**指针的内容可以改变**。
- 指向常量的指针常量: 指向常量的指针常量，指针的指向不可修改，指针所指的内存区域中的值也不可修改。

```c++
int ** const p;  // p 是一指针常量，它是一个指向指针的指针常量；
int * const * p; // p 是一个指针，它是一个指向指针常量的指针；
int const ** p;  // p 是一个指针，它是一个指向常量的指针的指针；
int * const * const p; // p 是一指针常量，它是一个指向指针常量的指针常量；
```



**句柄和指针的区别**

句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。



### define 宏常量和 const 、typedef、inline区别

- 编译器处理方式不同：`#define`宏是在预处理阶段展开，不能对宏定义进行调试，而`const`常量是在编译阶段使用；

- 类型和安全检查不同：`#define`宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而`const`常量有具体类型，在编译阶段会执行类型检查；

- 存储方式不同：`#define`宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而`const`常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。

- 定义域不同：`#define`宏不受定义域限制，而`const`常量只在定义域内有效。

  

**define和typedef的区别**

`define`

1. #define为一宏定义语句，本质就是文本替换
2. 简单的字符串替换，没有类型检查
3. #define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。
4. 可以用来防止头文件被重复引用 `#ifdefine` 
5. 不分配内存，给出的是立即数，有多少次使用就进行多少次替换
6. define 不受作用域约束，只要是在define 声明后的引用 都是正确的

`typedef`

1. 定义一种数据类型的别名，增强程序的可读性
2. typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef 
3. 在静态存储区中分配空间，程序运行过程中内存只有一个copy
4. typedef 有自己的作用域，如果在函数之外定义了类型，则在整个文件中都可以使用该类型定义，如果在函数内部定义了该类型，则只能在函数内部使用该类型。

对指针操作不同。见下面代码

```c++
typedef int * pint;
#define PINT int *
 
int i1 = 1, i2 = 2;

const pint p1 = &i1;	//p不可更改，p指向的内容可以更改，相当于 int * const p;
const PINT p2 = &i2;	//p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p；
```



**define 和 inline 的区别**

1. **内联函数是在编译时展开，而宏在编译预处理时展开**；在编译的时候，**内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换**。
2. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
3. **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在**每处调用内联函数的地方直接把内联函数的内容展开**，这样可以省去函数的调用的开销，提高效率
4. **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等
5. 内联函数只是用户给编译器的建议，编译器可以不执行。**内联函数可以进行调试，宏定义的“函数”无法调试**。
6. 由于**类的成员函数全部为内联函数，通过内联函数，可以访问类的数据成员，而宏不能访问类的数据成员**。



### override 和 overload 、overwrite的区别

**1、override是子类覆盖基类的函数**

运行时多态，用于子类继承父类时，子类重写父类的函数

规则：

- override函数的参数列表、返回值、抛出异常与被重写的函数一致
- 被重写的函数不能是私有的
- 静态函数不能被重写为非静态函数
- 重写函数的访问权限必须大于被重写函数的访问权限

  
class Base {
    virtual void func();
};

class Derived : public Base {
    void func() override;  // 明确指出这是覆盖基类的方法
};


**2、overload是重载，这些函数的函数名相同而参数形式不同**

定义：函数重载指的是在同一个作用域中可以有多个同名函数，这些函数的参数列表（即参数的数量、类型或者顺序）必须不同。
用途：允许使用相同的函数或方法名，但根据提供的参数调用不同的实现。

示例（C++）:

void print(int i);
void print(double d);
void print(const std::string& s);

编译时多态，根据不同的参数类型，在编译时将不同的函数体插入指定的地方

**3、overwrite**隐藏（重定义），派生类屏蔽了其同名的基类函数，返回值类型可以不同。

**特征**：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字。





流操作符重载为什么返回引用

在程序中，**流操作符>>和<<经常连续使用**。因此这**两个操作符的返回值**应该是一个仍旧支持**这两个操作符的流引用**。其他的数据类型都无法做到这一点。
注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这**四个操作符的对象都是右值**，因此，它们**必须构造一个对象作为返回值**。



### new 与malloc 底层实现原理

1. new是操作符，而malloc是函数。
2. new在调用的时候**先分配内存**，在**调用构造函数**，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要**给定申请**内存的大小，返回的指针需要强转；new会调用构造函数，**不用指定内存的大小**，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

**malloc底层实现：**当开辟的空间小于 128K 时，调用 `brk()` 函数；当开辟的空间大于 128K 时，调用 `mmap()`。malloc采用的是**内存池**的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用**隐式链表**将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：**new关键字在底层调用的是**operator new**：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空间不足的应对措施，如果该应对措施用户设置了，则继续申请，否则抛异常。

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象



**malloc/free，C++中为什么还需要new/delete？**


对于非内部数据类型而言，光用malloc/free无法满足动态对象都要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。

库函数是依赖于库的，一定程度上独立于语言的。编译器不关心库函数的作用，只保证编译，调用函数参数和返回值符合语法，生成call函数的代码。



**如何让 new 不抛出异常？**

1. 使用 `new(std::nothrow)` 关键字，当 new 一个对象失败时，默认设置对象为 NULL。
2. 通过 `set_new_handler(noMoreMemory);` 让 new 抛出异常时，执行程序给定的handler。一般来说 handler 只有两个选择：
   - 让更多memory可用（调用了程序员指定的handler，表示内存基本用完了，程序员可以选择释放一些其他的内存，C++会再次尝试new）
   - 调用 abort() 或 exit()
   
   

**new 和 malloc 的区别（可看）**

- `new` 会先调用 `operator new` 函数，申请足够的内存（底层使用 `malloc` 实现），再调用对象的构造函数，初始化成员变量，最后返回自定义类型指针。`delete` 先调用析构函数，然后调用 `operator delete` 函数释放内存（通常底层使用free实现）。
  `malloc/free` 是库函数， 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。
- new 可以指定内存空间初始化对象，而 malloc 只能从堆中申请内存。
- new 是 C++关键字，需要编译器支持。而 malloc 是 C 库函数，需要头文件支持。
- 使用 `new` 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而 `malloc` 则需要显式地指出所需内存的尺寸。
- new 的返回值为一个对象的指针类型，而 malloc 统一返回 void * 指针 (可强制转换为任何类型)，需要通过强制类型转换将 `void*` 指针转换成我们需要的类型。
- new 内存分配成功，返回该对象类型的指针，分配失败，抛出 bad_alloc 异常；而 malloc 成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。
- new 的空间大小由编译器会自动计算，而 malloc 则需要指定空间大小。
- `operator new/delete`可以重载，布局 `new` 的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，`new` 在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc/free不允许重载
- malloc 可以更改申请过的空间大小，我们可以 realloc 指定空间大小，而 new 一旦申请则无法更改

###  free 与delete 的区别

- delete 是 C++ 中的一个操作符，可以进行重载；而 free 是 C 中的一个函数，不能进行重载；
- free 只会释放指向的内存，不会执行对象的析构函数；delete 则可以执行对象的析构函数；

- **free 释放** heap 中申请的动态内存空间，只能释放 malloc，calloc，realloc 申请的内存。
  - free 函数只是将参数指针指向的内存归还给操作系统，并不会把参数指针置 NULL，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 free 之后，通常需要手动将指针置 NULL。
  - 内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 free 函数是没有能力去真正的 free 内存的，只是向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存。
- **delete 是** C++ 中的一个操作符，如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 operator delete 的标准库函数来释放所占的内存空间。
  - delete 用来释放单个对象所占的空间，只会调用一次析构函数；
  - delete [] 用来释放数组空间，会对数组中的每个元素都调用一次析构函数。
  - delete 只能用来释放 new 操作返回的指针，否则会产生不可预知的后果。
  
  



**delete和delete[]的区别**

delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数
用new分配的内存用delete释放，用new[]分配的内存用delete[]释放



**new delete，new[] delete[]一定配对使用?**

首先可以明确一点：配套使用是肯定没有错的。

- **new和delete**

  new和delete主要是为了为那些自定义类型的对象开辟空间，因为这些对象在创建的时候要自动执行构造函数，消亡的时候要执行析构函数，对于自定义类型对象如果不配对使用的话，可能会出现没有析构干净的情况

- **new[]和delete[]**

  我们再用new[]创建数组的时候，比如一个对象大小为N，则K个数组需要K*N个空间来构造。那当delete的时候如何知道这个数组空间的大小呢？我们会在new出来的这个空间的头部申请一个int类型的字节，4字节用来存储数组的长度，这样调用delete[]的时候就知道数组的大小，才会调用K次析构函数，释放K * N + 4字节大小的内存。

  下面针对自定义类型变量：

  如果new和delete[]使用，delete的时候会找前4个字节，看要释放的内存有多大。但是使用new导致没有设备区部分4个字节用来存放数组长度，这样会导致这4个字节是未定义的，因此会调用不定次的delete。同时比如说其实地址为A，应该从A开始释放，现在会从A-4开始释放。

  如果new[]和delete一起使用，程序会认为这是一个对象占用的空间，而不是数组，因此就析构一次。同时释放的是new[]中表示长度的前4个字节的地址，应该从A-4开始释放，如果不从头释放的话回出问题。





### constexpr和const

`const`表示“只读”的语义，`constexpr`表示“常量的语义”

`constexpr`只能**定义编译期常量**；`const`可以定义编译期常量，也可以定义运行期常量.

```c++
const int a = 4096;	// 编译期常量
const int size = vector<int>(26).size()	// 运行期常量
```

**constexpr的好处**

1. 为一些**不能修改数据提供保障**，避免被以外修改的风险
2. 部分场景，编译器可以在编译期对constexpr的代码进行优化，提高效率
3. 相比宏来说，没有额外的开销，更安全可靠



### const和static（区别）

| 关键字 | 修饰常量（非类中）                                           | 修饰成员变量                                                 | 修饰成员函数                                                 |
| ------ | ------------------------------------------------------------ | :----------------------------------------------------------- | ------------------------------------------------------------ |
| const  | 1、超出作用域后空间会被释放<br />2、在定义时必须初始化，之后无法更改<br />3、`const`形参可以接受const和非const类型的实参 | 不能赋值、不能在类外定义；只能通过构造函数的参数列表初始化进行初始化（原因：因为不同对象的const成员变量可以具有不同值，所以不能在声明时初始化） | 防止成员函数修改对象的内容（不能修改成员变量，但能够访问）<br />const对象不可以调用非const的函数 |
| static | 在函数执行后不会释放其存储空间                               | 只能用在类内声明，在外部初始化，且不加static                 | 1、作为类作用域的全局函数（不能访问非静态数据成员和调用非静态成员函数）<br />2、没有this指针<br />3、不能声明为virtual |

**const和static不能同时修饰成员函数（原因：静态成员函数不含有this指针，即不能实例化，而const成员函数必须具体到某一实例）**





####  const和static（不考虑类、考虑类）

**static**

- 不考虑类的情况
  1. 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
  2. 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
  3. 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
- 考虑类的情况
  1. static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
  2. static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const、虚函数和volatile**；可以被非static成员函数任意访问

**const**

- 不考虑类的情况
  1. const常量在定义时必须初始化，之后无法更改
  2. const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //...}
- 考虑类的情况
  1. const成员变量：不能在类定义外部初始化，只能通过**构造函数初始化列表**进行初始化，并且必须有构造函数；**不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化**
  2. const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值

补充一点const相关：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。



**顶层const和底层const** 

- 底层const是代表对象本身是一个常量（不可改变）；
- 顶层const是代表指针的值是一个常量,而指针的值(即对象的地址)的内容可以改变（指向的不可改变）；



**const 作用及用法（可看）**

- const 修饰普通变量或者成员变量，定义成 const 常量，相较于宏常量可进行类型检查，节省内存空间，提高了效率。
- const 修饰函数参数，使得传递过来的函数参数的值不能改变。
- const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
- `const` 变量: 定义成 `const` 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。被定义为 `const` 的变量是不可修改的。
- `const` 指针:
  - `const` 修饰指针指向的内容，则指针指向的内容不可变，但是指针本身的内容可以改变，指针常量
  - `const` 修饰指针，则指针为不可变量，指针指向的内容可以变，但指针本身不能变，常量指针
  - `const` 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量
- const 引用:
  - const 引用是指向 const 对象的引用，可以读取变量，但不能通过引用修改指向的对象
  - 可以将 const 引用指向非 const 变量，但不能使用非 const 引用指向 const 变量。
  - const 引用可以初始化为不同类型的对象或者右值（如字面值常量），但非 const 引用不可以

- const 成员变量：
  - const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。
  - const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量。
- const 函数参数与返回值:
  - 用 const 修饰函数参数，表明函数参数为常量，在函数内部不可以修改参数的内容，一般我们使用 const 指针或者 const 引用。函数返回值如果为指针或者引用，我们可以用 const 指针或者引用接受返回值，此时指向的内容则不可以修改。
- const 成员函数：
  - 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。
  - 不能调用非常量成员函数，以防修改成员变量的值。
- const 对象只能访问 const 成员函数,而非 const 对象可以访问任意的成员函数，包括 const 成员函数。
- 加上 mutable 修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的 const 成员函数是可以修改它的

#### static和const同时修饰成员函数?

答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数**不能修改类的实例**的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是**没有this指针**的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。**static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态**，与类型的静态变量没有关系。因此不能同时用它们。

#### static 的作用、初始化时机、线程安全

1. **限制数据的作用域（隐藏）**：所有没有加 static 的全局变量和函数都具有全局可见性，其它源文件中也可以访问。被 static 修饰的全局变量和函数只能在当前源文件中访问，其它源文件访问不了，利用这个特性可以在不同的文件中定义同名变量和同名函数，而不必担心命名冲突。
2. **延长数据的生命周期：**普通的局部变量出了作用域就会释放，而静态变量存储在静态区，直到程序运行结束才会释放。 
3. 静态成员被该类所有对象共享 static 关键字可以修饰类中的成员变量和成员方法，被称为静态成员变量和静态成员方法，静态成员拥有一块单独的存储区，不管创建多少个该类的对象，**所有对象都共享这一块内存。静态成员本质上属于类，可以通过类名直接访问。**
4. 静态变量默认初始化值为0，如果**没有显示初始化静态变量或者初始化为0的静态变量会存储在 BSS 段，而初显示初始化的静态变量存储在 DATA 段。**
5. **静态成员函数中不能访问普通的成员变量，只能访问静态成员变量，并且在静态成员函数中没有 this 指针。**

**static变量何时初始化？**

1. 对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。
2. 而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

**静态变量在返回函数中的地址**

- **静态局部变量存在静态区**，程序初始化时则已经创建了改变量，变量的生存周期为整个程序的生命周期。函数 fun 中定义了静态局部变量 var，使得离开该函数的作用域后，该变量不会销毁，**返回到主函数中，该变量依然存在，**从而使程序得到正确的运行结果，该**静态局部变量直到程序运行结束**后才销毁。
- **全局静态对象**在程序初始化时，则进行了初始化。**局部静态对象的初始化**在第一次进入函数内部时，才会调用对象的构造函数进行初始化。程序退出时，**先释放静态局部变量，再释放全局静态变量**



**static初始化时机和线程安全问题**

**先说在C语言中：**

静态局部变量和全局变量一样，数据都存放在全局区域，所以在**主程序之前**，编译器已经为其分配好了内存，在编译阶段**分配好了内存之后就进行初始化**，在程序运行结束时变量所处的全局内存会被回收。所以在**c语言中无法使用变量对静态局部变量进行初始化**。

**再说C++和C语言的区别：**

c++主要引入了类这种东西，要进行**初始化必须考虑到相应的构造函数和析构函数**，而且很多时候构造或者析构函数中会指定我们定义的操作，并非简单的分配内存。因此为了造成不必要的影响（一些我不需要的东西被提前构造出来）所以**c++规定全局或者静态对象在首次用到的时候**才会初始化。

所以c++整了两种初始化的情况，我理解就是**编译初始化和运行初始化**。

**编译初始化也叫静态初始化**。对全局变量和const类型的初始化主要是，叫做zero initialization 和 const initialization，静态初始化在程序加载的过程中完成。从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量静态变量初始化基本是一致的。其次全局类对象也是在编译器初始化。

**动态初始化也叫运行时初始化**。主要是指需要经过函数调用才能完成的初始化或者是类的初始化，一般来说是**局部静态类对象的初始化和局部静态变量的初始化**。

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20190424220313563.png" alt="在这里插入图片描述" style="zoom: 60%; float: left;" />

下面是我自己的实验的一段代码：

```c++
#include<stdio.h>
static int a;
int main()
{
	int b = 5;
	{	
        //g++编译报错
	 	static int c = b;
        //gcc编译不报错
        static int c = b;	
	}
	return 0;
}
```

如果在c语言中有**局部静态变量赋值操作**的话会报错：`undefined reference to ' __cxa_guard_acquire'和 '__cxa_guard_release'`。而这两个API接口恰恰是c++中保证局部静态变量运行时初始化的关键，具体参考[c++局部静态变量和线程安全具体实现参考](https://www.cnblogs.com/william-cheung/p/4831085.html)

##### **线程安全问题：**

C语言中**非局部静态变量**一般在main执行之前的静态初始化过程中分配内存并初始化，可以认为是线程安全的；C++11标准针规定了**局部静态变量初始化是线程安全的**。这里的线程安全指的是：一个线程在初始化 m 的时候，其他线程执行到 m 的初始化这一行的时候，就会挂起而不是跳过。

具体实现如下：**局部静态变量在编译时，编译器的实现是和全局变量类似的，均存储在bss段中**。然后编译器会生成一个`guard_for_bar` 用来保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在 bss 段。它的最低的一个字节被用作相应静态变量是否已被初始化的标志， 若为 0 表示还未被初始化，否则表示已被初始化(` if ((guard_for_bar & 0xff) == 0)`判断)。 `__cxa_guard_acquire` 实际上是一个加锁的过程， 相应的 `__cxa_guard_abort` 和` __cxa_guard_release` 释放锁。

```c++
void foo() {
    static Bar bar;
}

//gcc 4.8.3 编译器生成的汇编代码
void foo() {
    if ((guard_for_bar & 0xff) == 0) {
        if (__cxa_guard_acquire(&guard_for_bar)) {
            try {
                Bar::Bar(&bar);
            } catch (...) {
                __cxa_guard_abort(&guard_for_bar);
                throw;
            }
            __cxa_guard_release(&guard_for_bar);
            __cxa_atexit(Bar::~Bar, &bar, &__dso_handle);
        }
    }
    // ...
}
```



#### 局部静态变量的问题

**局部静态变量**

局部静态变量位于**内存中的静态存储区**，未经初始化的局部静态变量会自动初始化为0。但是局部静态变量的作用于还是还是局部作用于，定义它的函数或者代码块结束的时候，作用于也随之结束。但是**该变量值不会被销毁，而是在内存中驻留下来**，知道程序全部结束，这个驻留的值我们不能访问她。

**静态局部变量的构造和析构**

对于全局变量的构造和析构，肯定是排在首位的。

而对于局部静态变量，**程序首次执行到局部静态变量的定义处时才发出构造**，其构造和析构都取决于程序的执行顺序。很显然，对于分布在程序各处的静态局部变量，其构造顺序取决于它们在**程序的实际执行路径上的先后顺序**，而析构顺序则正好与之相反。这就有两个问题：

1. 一方面是因为程序的实际执行路径有多个决定因素（例如基于消息驱动模型的程序和多线程程序），有时是不可预知的；
2. 另一方面是因为局部静态变量分布在程序代码各处，彼此直接没有明显的关联，很容易让开发者忽略它们之间的这种关系（这是最坑的地方）。

所以我们应该尽量少使用静态变量。



**函数局部静态变量的返回**

```c++
int tmp(){
    static int b = 5;
    return b;
}
int main(){
    static int a = 0;
    int c = tmp();
    std::cout<<"a:"<<a<<std::endl;
    std::cout<<"c:"<<c<<std::endl;
}
```

对于g++编译器来说，可以返回哦





### strlen 和 sizeof、面试题

<img src="https://img-blog.csdnimg.cn/20200804193045440.png" alt="C++数据类型的大小" style="zoom:50%;" />

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是头文件 <cstring> 中的字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串，+1的作用。
- **因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。**
- 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。

二者的不同之处:

- strlen 本身是库函数，因此**在程序运行过程中，计算长度**；而 sizeof 是在**编译时计算长度**；sizeof 的参数可以是类型，也可以是变量，**且必须是完整类型**；strlen 的参数必须是 char * 类型的变量。
- sizeof 接受的参数可以是对象也可以是表达式，但是 **sizeof(expression) 在运行时不会对接受的表达式进行计算**，编译器**只会推导表达式的类型**从而计算占用的字节大小；而 strlen 是一个函数，**如果接受表达式则会对表达式进行运算**

**sizeof的定义**

sizeof是C语言的一种**单目操作符**，它并不是函数。**sizeof操作符以字节形式给出了其操作数所占存储空间的大小。**操作数可以是一个表达式或括在括号内的类型名。操作数所占存储空间的大小由操作数的类型决定。作用就是返回一个对象或者类型所占的内存字节数。sizeof在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。

数组——编译时**分配的数组空间大小**；

指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；

类型——该类型所占的空间大小；

对象——对象的实际占用空间大小；

函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。

对了，还要注意结构体的**内存对齐原**则！！！这个也是考点

**问：定义不包含任何成员变量和成员函数的空的类，该类型sizeof多少？**

答：1。因为该类的实例不包含任何信息，按常理来说应该sizeof=0的。但是当我们**声明该类实例时，必须在内存中占用一定的空间才行，否则你无法使用这些实例**。至于占用多少内存是由编译器决定的。用了一个char为了保证空类和空类之间在内存中不会有相同的地址。c++中的struct和class本质其实没有区别，区别仅仅是默认的“权限不同”，class是private，struct是public，sizeof(class)或者sizeof(struct)是1。

**问：在空类里面添加一个构造函数和析构函数，sizeof是多少？**

答：还是一样的。因为**调用构造函数和析构函数**或者其他函数只需要知道函数的地址就行，**函数的地址和类的实例无关**。

**问：如果把析构函数编程虚函数呢？**

答：如果类中有虚函数，会生成虚函数表，并且每个对象都会在头部添加一个指向虚函数表的指针。**所以sizeof就是指针的大小，计算机内部地址总线的宽度，32位机器上是4，64位机器上是8**。

**问：不用sizeof如何获得int所占的字节数？**

思路：设初始值为1，则循环将值左移，**直到值为0，记录循环的次数**，即总共的位数，再除以8（一个字节=8位），即该类型的字节长度。

```c++
int main()
{
    int i = 1;
    int count = 0;
    while(i)
        i = i <<1;//一个循环，每次左移一位
    	count++;
    cout << count/8 << endl;//因为一个字节8位
    return 0;
}
```





### std::atomic、future、extern、mutable、RITT

`std::atomic` 是 C++ 标准库中提供的一个类型，用于实现多线程编程中的原子操作。它的目的是为了在多线程环境中确保共享数据的安全性，避免出现竞态条件（Race Condition）等问题。

在多线程编程中，当多个线程同时访问和修改共享数据时，可能会导致数据不一致性、错误的结果或者程序崩溃等问题。为了解决这些问题，C++ 提供了 `std::atomic` 类型，它使用了硬件支持或操作系统提供的原子操作指令，保证了特定操作的原子性。

**问题：`a++`和`int a = b`在c++中是否线程安全？**

1、`a++`的汇编

先将a对应的内存值搬运到某个寄存器（如eax）中，然后将该寄存器中的值自增1，最后将寄存器中的值搬运回a代表的内存中

```assembly
mov eax, dword ptr [a] #(1)
inc eax #(2)
mov dword ptr [a], eax #(3)
```

2、`int a = b`的汇编

数据不能直接从内存某处搬运到内存另外一处，必须通过寄存器来中专

```assembly
mov eax, dword ptr [b]
mov dword ptr [a], eax
```

解决办法：`std::atomic<int> value`对整型变量原子操作的相关库



**future关键字：**

在C++中，`std::future` 是一个模板类，它是一个异步结果的代表。当你想要异步地执行一个操作，并且在未来某个时刻获取该操作的结果时，你会使用 `std::future`。

在底层，C++库可能使用线程同步原语（如互斥锁和条件变量）来实现 `std::future`。这确保了即使在多线程环境中，`std::future` 的操作都是线程安全的。

**原理概述**：

1. **包装函数**：当你提交一个函数或可调用对象进行异步执行时（例如，使用 `std::async`），C++将这个函数或对象包装起来，使其可以在一个独立的线程中执行。
2. **共享状态**：`std::future` 对象和异步操作共享一个状态。这个共享状态用于存储函数的返回值或异常，如果该函数抛出了一个异常。当异步操作完成时，它会设置这个共享状态。
3. **等待/检索结果**：你可以使用 `std::future::get()` 方法来查询结果。如果异步操作还没有完成，`get()` 方法会阻塞调用线程，直到结果变得可用。如果异步操作抛出了异常，调用 `get()` 会重新抛出该异常。
4. **状态查询**：`std::future` 提供了几种方法，如 `valid()`, `wait()`, 和 `wait_for()`, 来查询或等待异步操作的状态。
5. **只取一次**：`std::future::get()` 只可以被调用一次。一旦你调用了 `get()` 方法并获取了结果，你不能再次调用它。
6. **异步操作**：除了 `std::async`，C++还为 `std::promise` 和 `std::packaged_task` 提供了 `std::future`。它们都是手段来设置与 `std::future` 对象相关的共享状态。



**extern 关键字**

①为了能够**正确实现C++代码调用其他C语言代码**。加上extern "C"后，会指示编**译器这部分代码按C语言的进行编译**，而不是C++的。主要原因是C++和C程序编译完成后在**目标代码中的命名规则**不同。比如C++语言在**编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会**，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，**请保持我的名称，不要给我生成用于链接的中间函数名。**

②extern是C/C++语言中**表明函数和全局变量作用范围（可见性）**的关键字，该关键字告诉编译器，其**声明的函数和变量**可以在本模块或其它模块中使用。



**mutable关键字**

mutable：可变的

首先想到的是在lamba表达式中有这个东西，表示如果是值传递的，可以修改，不加这个mutable属性不能修改，表示传递过来的是常量。虽然在匿名函数内部改变了变量的值，但是在外部还是原来的值

除了lamba表达式中的，就只有类中的了

mutable 在类中只能够修饰非静态数据成员，用来修饰一个 const 示例的部分可变的数据成员的。如下代码：

```c++
struct Test
{
    int a;
    mutable int b;
};

const struct Test test = {1,2};
test.a = 10;  # 编译错误
test.b = 20;  # 允许访问
```







**c++RITT机制**

**概念：**

RTTI(Run Time Type Identification)即通过**运行时类型识别**，C++引入这个机制是为了让**程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型**。但是现在RTTI的类型识别已经不限于此了，它还能**通过typeid操作符识别出所有的基本类型**（int，指针等）的变量对应的类型。

和很多其他语言一样，C++是一种静态类型语言。**其数据类型是在编译期就确定的，不能在运行时更改**。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要**将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。**

**如何实现：**

C++通过以下的两个操作提供RTTI：

（1）**typeid运算符**，该运算符返回其表达式或类型名的实际类型。返回指针和引用所指的实际类型；

（2）**dynamic_cast运算符**，该运算符将**基类的指针或引用安全地转换为派生类类型的指针或引用**。

我们知道**C++的多态性（运行时）是由虚函数实现**的，对于多态性的对象，无法在程序编译阶段确定对象的类型。**当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用typeid函数，该函数反回一个对type_info类对象的引用，要使用typeid必须使用头文件`<typeinfo>`，因为typeid是一个返回类型为typ_info的引用的函数**



### extern “C” 、类explicit、类override和final

**extern"C":**

extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern “C”就是其中的一个策略。

- C++代码调用C语言代码
- 在C++的头文件中使用
- 在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到



**类explicit作用**

explicit关键字主要是用来**修饰类中的构造函数**的，对于仅有**一个参数或除第一个参数外其余参数均有默认值**的类构造函数，尽可能使用explicit关键字修饰。因为**只有一个参数或者出了第一个参数其他参数是默认参数**的构造函数来说，他还有另一个名字叫做转换构造函数。

**所以explicit主要用来防止隐式转换。**因为仅含一个参数的构造函数和除了第一个参数外其余参数都有默认值的多参构造函数承担了两个角色。 第一个是成为**带参数的构造函数**，第二个是一个**默认且隐含的类型转换操作符**（就是单参数的构造函数是一种隐含的类型转换符）

额外说一下隐式类型转换：

> c++隐式类型转换是指c++自动将一种类型转换成另一种类型，是编译器的一种自主行为。

举一些类型转换的例子：

```c++
int i=3;
double j = 3.1;
i+j;//i会被转换成double类型，然后才做加法运算。

class A{};
class B: public A
{};//B是子类
void Fun(A& a);
B b;
Fun(b);//使用子类对象代替父类对象是可以的，也是因为隐式类型转换。

class Test
{
	public:
		Test(int i);
};

Test t1 = 1;//正确，由于强制类型转换，1先被Test构造函数构造成Test对象，然后才被赋值给t1
Test t2(1);//正确
```





**类override和final**

1. **override（重写）：**

   - **用法：** 在子类中，可以使用"override"关键字来指示编译器，你意图重写父类中的虚函数。这有助于检测潜在的错误，例如拼写错误或方法签名不匹配的情况。

   - **作用：** 重写虚函数允许子类提供自定义的实现，以替代父类中的虚函数。在运行时，根据对象的实际类型来调用正确的函数实现，实现多态性。

   - **示例：**

     ```c++
     cppCopy codeclass Animal {
     public:
         virtual void makeSound() {
             std::cout << "Animal makes a sound" << std::endl;
         }
     };
     
     class Dog : public Animal {
     public:
         void makeSound() override {
             std::cout << "Dog barks" << std::endl;
         }
     };
     ```

2. **final（最终）：**

   - **用法：** "final"关键字可以应用于虚函数或类。

     - 当应用于虚函数时，它表示该虚函数不能再被子类重写。
     - 当应用于类时，它表示该类不能被继承，即它是不可派生的。

   - **作用：** "final"关键字的主要作用是限制继承和重写，以确保某些部分的代码不会被修改或扩展。这有助于提高代码的可靠性和安全性。

   - **示例：**

     ```c++
     cppCopy codeclass Base {
     public:
         virtual void doSomething() final {
             // 这个虚函数不能再被子类重写
         }
     };
     
     class Derived : public Base {
         // 尝试重写被标记为 final 的虚函数会导致编译错误
     };
     
     class FinalClass final {
         // 这个类不能被继承
     };
     ```









### volatile作用、使用场景（const参数、原子性）

1. volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
2. 多线程中被几个任务共享的变量需要定义为volatile类型。

**volatile 的作用：**

- 使用 volatile 关键字试图阻止**编译器过度优化**
- volatile 主要作用如下：
  - 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）
  - 阻止编译器调整操作 volatile 变量的指令排序。
  - 写入变量时，阻止编译器对指令顺序的优化: 在某些特定的场景下，比如读写寄存器或者操作某些硬件，需要按照某些特定的指令序列读写寄存器，而不能忽略其中的某些步骤

**volatile 的应用场景：**

- 在实际场景中除了操纵硬件需要用到 volatile 以外，更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程可见，此时我们就需要使用 volatile 进行修饰。
- **volatile 应用地方：**
  - **中断服务程序中修改的**供其它程序检测的变量需要加 volatile；
  - 多任务环境下各任务间共享的标志应该加 volatile；
  - 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能有不同意义
  
  
  
  #### **多线程编程中什么情况下需要加 volatile？**
  
  C/C++多线程编程中不要使用volatile。C++11标准中明确指出**解决多线程的数据竞争问题应该使用原子操作或者互斥锁**。
  
  因为C和C++中的volatile并不是用来解决多线程竞争问题的，而是用来**修饰一些因为程序不可控因素导致变化的变量**，比如访问**底层硬件设备的变量**，以提醒编译器不要对该变量的访问擅自进行优化。



**参数是volatile又是const?**

可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。

注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。



**Volatile是否具有原子性**

  "volatile" 并不提供原子性。原子性是指一个操作要么完全执行，要么完全不执行，不会被中断。如果多个线程同时对一个 "volatile" 变量进行读取和写入操作，仍然可能会发生竞态条件和数据不一致的问题，因为 "volatile" 并不能防止多个线程同时访问变量。

要实现原子操作，通常需要使用锁（比如互斥锁或读写锁）或者原子操作库来确保在一个时间点只有一个线程可以执行特定的操作，从而避免竞态条件和数据不一致问题。

综上所述，"volatile" 关键字保证了可见性，但不保证原子性。在多线程环境中，如果需要原子操作，应该使用适当的同步机制来确保线程安全。

但是要知道volatile并不能真正解决多线程之间的问题。对于临界区的资源我们可以用锁机制来保护，对于非临界区的资源，如果**使用 `volatile` 会禁止编译器优化相关变量，从而降低性能**，所以也不建议依赖 `volatile` 在这种情况下做线程同步。

**使用`std::atomic<type>` 操作是原子的，同时构建了良好的内存屏障**









### strcpy（缺点）、sprintf 与memcpy 、memmove 原理

- 操作对象不同，strcpy 的两个操作对象均为**字符串**，sprintf 的操作源对象可以是**多种数据类型**， 目的操作对象是字符串，memcpy 的两个对象就是两个**任意可操作的内存地址**，并不限于何种数据类型。
- 执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
- 实现功能不同，strcpy 主要实现**字符串变量间**的拷贝，sprintf 主要实现**其他数据类型格式**到字 符串的转化，memcpy 主要是**内存块间的拷贝**。

**「注意」**：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。

**strcpy 函数的缺陷**

- strcpy 是 C++ 语言的一个标准函数 ，strcpy 把含有 **'\0' 结束符的字符串**复制到另一个地址空间，返回值的类型为 char*，返回值为**拷贝后的字符串的首地址**。

  ```c++
  char * strcpy(char * strDest,const char * strSrc) {
      if ((NULL==strDest) || (NULL==strSrc)) 
      throw "Invalid argument(s)"; 
      char * strDestCopy = strDest; 
      while ((*strDest++=*strSrc++)!='\0'); 
      return strDestCopy;
  }
  ```

- strcpy 函数的缺陷：**strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖**

- 由于 strcpy 函数存在一定的安全风险，如果使用不当容易出现安全问题，利用 strcpy 的特性可以编写 shellcode 来进行**缓冲区溢出攻击**。在大多数工程代码中，为了保证代码的健壮性和安全性，一般会使用 **strncpy 代替 strcpy**

- 

**memmove 函数底层原理**

- memmove 用于拷贝字节，如果**目标区域和源区域**有**重叠**的话，memmove 能够**保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中**，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 memcpy 函数功能相同。

- 实现 memmove 函数，在实现的时候需要特殊处理地址重叠的情况

  ```c++
  void *memmove(void *dst, const void *src, size_t size)
  {
      char *psrc;
      char *pdst;
  
      if (NULL == dst || NULL == src)
      {
          return NULL;
      }
  
      if ((src < dst) && (char *)src + size > (char *)dst) // 出现地址重叠的情况，自后向前拷贝
      {
          psrc = (char *)src + size - 1;
          pdst = (char *)dst + size - 1;
          while (size--)
          {
              *pdst-- = *psrc--;
          }
      }
      else
      {
          psrc = (char *)src;
          pdst = (char *)dst;
          while (size--)
          {
              *pdst++ = *psrc++;
          }
      }
  
      return dst;
  }
  ```

- 



### struct与class、union、 +typedef 区别

1. 从定义上来讲，结构体是描述数据结构的集合；而类是对一个对象数据的封装。
2. 无论是成员结构体的默认限定符是public；类是private
3. 在继承关系中，结构体默认是公有继承，而类默认是私有继承
4. **class 关键字可以用于定义模板参数。**class这个关键字还可用于**定义模板参数**，就等同于typename；而**strcut不用与定义模板参数**。

- C语言的结构体是不能有函数成员的，而C++的类可以有。
- C语言的结构体中数据成员是没有private、public和protected访问限定的。而C++的类的成员有这些访问限定。
- C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。

**「注意」**：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。

**struct和union（共同体）的区别**

- union 是联合体，struct 是结构体。结构体中的每个成员都有自己**独立的地址**，它们是同时存在的；共同体中的**所有成员占用同一段内存**，它们不能同时存在；
- 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，**联合体只有一个有效的成员，不同类型的几个变量共同占用一段内存；而结构体所有的成员都有效**。
- **对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响**。
- 联合体的大小为其内部所有变量的最大值，**按照最大类型的倍数进行分配大小**；**结构体分配内存的大小遵循内存对齐原则**。
- struct 可以定义变长数组成员变量 int a[]，union 中不能包含有这种不确定长度的变量。

sizeof(struct)是内存对齐后所有**成员长度**的总和，sizeof(union)是内存对齐后**最长数据成员的长度**。



**struct 和 typedef struct**

```c
/代码1（c语言）
typedef struct test3{
	int a;
	int b;
	int c;
}test4;
//代码2（c++）
struct test3{
	int a;
	int b;
	int c;
}test4;
```

- **在c语言中**

  对于代码1。**test3**相当于标识符，而**test4**相当于变量类型.定义一个结构体变量为`test4 t`，即`struct test3 = test4`

  对于代码2。要定义结构体变量必须写成`struct test3 t `

- **在c++中**

  对于代码1。不要这样写，基本上是代码二的类型。test4变成了变量名

  对于代码2 。这是c++的写法，test4相当于一个结构体变量。



**C++ 和 C 中 struct 的区别**

- [ ] **函数、权限、继承、实例化**

1. C 的结构体不允许有函数存在（但可以有函数指针），而 C++ 的结构体允许有内部函数，并且允许该函数是虚函数。
2. C 的结构体内部成员不能设置权限，均为 public。而 C++ 的结构体可以设置内部成员的权限，默认为 public。
3. C 的结构体不能继承，而 C++ 的结构体可以从其他结构体或者类中继承。
4. C 中实例化一个结构体，需要带上 struct 关键字。而 c++ 中不用。

**struct可以直接赋值吗**

声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。

**「注意」**：当有**多个指针指向同一段内存**时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在**释放前一定要确保其他指针不再使用这段内存空间**。

**结构体相等判断及 memcmp 函数**

- 符号重载：需要重载操作符 == 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为 memcmp 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。



#### struct的内存对齐规则

**为什么要字节对齐？**

需要字节对齐的根本原因在于**CPU访问数据的效率问题**。假如没有字节对齐，那么一个double类型的变量会存储在4-11上（正常是0-7）这样计算机取这个数据的会**会取两次，降低效率**。而如果变量在**自然对齐位置**上，则只要**一次就可以取出数据**。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误。

**对齐规则**

由于在x86下，GCC默认按4字节对齐，但是可以使用**`__attribute__`选项改变对齐规则**， vs studio上用`#pragma pack (n)`方式改变

举例子：

```c++
//sizeof stu = 4 +4 + 12 = 20
struct stu{
    char sex;			//4
    int length;			//4
    char name[10];		//12
};

// size of str1 = 1 + 1+(2)+4 = 8
//两个char后需要再补充两个字节凑够4字节
struct node1  
{
    char c1;
    char c2;
    int a;
}str1 ;

// 5+2+1+4 = 12
//char前4个元素占4字节，第5个元素和short一共3字节，需要补1个字节
struct str4  {
    char c1[5];
    short c;
    int b;
}str4 ;

// 1+(7)+8+1+(7) = 24
struct str6 {
    char c1;
    double a;
    char c2;
}str6 ;
```

**易错点**

```c++
//sizeof = 8
struct str{
    char p;
    int a;
    int b[0];
}

//sizeof = 4
struct str{
    int b[0];
}

//sizeof = 1
struct str{
    
}
```

上面三个结构体都包含空数组，空数组指的是长度为0的数组`int[]`或`int[0]`

这种定义只**能在类或者结构体中定义，在外部是非法定义**。空数组不占空间，也无需初始化

空数组名是一个指针，（但是又不占空间）指向一个位置；对于结构体，空数组名这个指针指向了前面一个成员结束的第一个空间。

> 不能再函数中定义Int a[0] 或int a[];这种

- 

### inline 工作原理、优缺点、场景

**工作原理：**

inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在**调用时并不通过函数调用的机制**而是直接在**调用点处**展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。**内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。**这也是设计内联函数的主要目的之一。

**函数调用时，需要切换栈帧寄存器**，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而**内联函数可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点**。

- 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。**转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销**。
- 虽然内联函数在调用时直接进行展开，但**实际在编译后代码中存在内联函数的定义，可以供编译器进行调用**。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针。



**优缺点:**

- 内联函数具有以下优点：
  **不会产生函数调用开销。**节省了调用函数时在堆栈上推送/弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。
- 内联函数的缺点：
  - 从内联函数中添加的变量会**消耗额外的寄存器**，在内联函数之后，如果要使用寄存器的变量数量增加，则可能**会在寄存器变量资源利用方面产生开销**。在函数调用点替换内联函数体时，**函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加**。因此，**如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销**。
  - 如果你使用太多的内联函数，那么**二进制可执行文件的大小会很大，因为相同的代码重复**。
  - 过多的内联也会**降低指令缓存命中率**，从而降低从缓存内存到主内存的指令获取速度。
  - 如果有人更改内联函数内的代码，**内联函数可能会增加编译时间开销**，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.
  - **内联函数可能会导致抖动**，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降。



**使用场景：**

内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联：

- 如果函数包含循环（for, while, do-while）；
- 如果一个函数包含静态变量；
- 如果一个函数是递归的；
- 如果函数返回类型不是 void，并且函数体中不存在 return 语句；
- 如果函数包含 switch 或 goto 语句；
- 内联可以去除函数只能定义一次的限制：

- 内联函数可以在程序中定义不止一次， 但是 **inline 函数的定义在某个源文件中只能出现一次**，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 inline 函数，所有 include 该头文件，如果修改了头文件中的 inline 函数时，**使用了该头文件的所有源文件都必须重新编译**。比如我们可以在定义以下两个文件包含相同的函数。



#### **类内外成员函数使用inline、虚函数为内联函数？**

**类内定义成员函数默认是内联函数**，除了虚函数以外，因为虚函数是在运行时决定的，在编译时还无法确定虚函数的实际调用。

- **类内定义成员函数**，可以不用在函数头部加 inline 关键字，因为**编译器会自动将类内定义的函数**（构造函数、析构函数、普通成员函数等）**声明为内联函数**
- **类外定义成员函数**，若想定义为内联函数，**需用关键字**声明;当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在**类外定义函数时加上 inline 关键字**。关键字 inline 必须与函数定义体放在一起才能使函数成为内联，如果只是 inline 放在函数声明前面不起任何作用

**虚函数可以是内联函数？**

- 首先要明白，**内联函数是编译器做出的选择**，是否内联决定权在编译器，程序员不可控。同时，虚函数是多态性的一种体现，**多态性表现在函数的运行阶段而不是函数的编译阶段**。因此，**虚函数表现为多态性时（运行期）不可以内联。**
- 唯一可以内联的时候是：编译器知道所调用的对象是哪个类。**只有在编译器具有实际对象而不是对象的指针或引用时才会发生。**





### C++四种类型转换区别、何时、引入原因

- **static_cast：**static_cast 是“静态转换”的意思，也即在**编译期间转换，转换失败的话会抛出一个编译错误。**一般用于如下:
  - 用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。
  - 用于**基本数据类型**的转换。
  - 用于**类层次之间的基类和派生类之间**指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于**没有动态类型检查，所以是不安全的**，最好用 dynamic_cast 进行下行转换。
  - 可以将**空指针转化成目标类型的空指针**。
  - 可以将**任何类型的表达式转化成 void 类型**。
  - **不能**用于在**不同类型的指针之间互相转换**，也不能用于**整型和指针之间的互相转换**，当然也不能用于不同类型的引用之间的转换。
- **const_cast：**主要用于 const 与非 const、volatile 与非 volatile 之间的转换。**强制去掉常量属性**，**不能用于去掉变量的常量性**，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。
- **reinterpret_cast：**改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。reinterpret_cast 转换时，执行的过程是逐个**比特复制**的操作。
- **dynamic_cast：**其他三种都是编译时完成的，**动态类型转换是在程序运行时处理的**，运行时会进行类型检查。
  - 只能用于**带有虚函数的基类或派生类的指针或者引用对象的转换，**转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。
  - 在**向上进行转换**时，即派生类的指针转换成基类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）
  - 在**下行转换**时，基类的指针类型转化为派生类的指针类型，只有当**要转换的指针指向的对象类型和转化以后的对象类型相同**时，才会转化成功。

所以C++不是类型安全的



**何时：四种类型转换是在什么时候进行的？**

1. **编译期进起作用**
   - `static_cast`
   - `reinterprete_cast`
   - `const_cast`
2. **运行期起作用**
   - `dynamic_cast`

> 为什么不使用 C 风格的类型转换

1. C 风格的类型转换无法实现更精确的类型转换，举两个例子，将一个指向 const 对象的指针转化为一个指向非 const 对象的指针 `const_cast` ，或者将指向基类的指针转换为指向子类的指针`dynamic_cast`。
2. C 风格的类型转换在程序中难以识别。



**为什么要引入四种强制类型转换**

> c语言可以在任意类型之间进行转换，但是有一点就是不安全。可能会不经意间将指向const对象的指针转换成非const对象的指针，也有可能将基类对象指针转换成派生类对象的指针。因此这四种强制类型转换是的代码更加严谨规范

同时c++风格的强转很清晰的知道在干什么，只要扫一眼就知道这样转换的目的

**为什么说不要使用 dynamic_cast**

没有说一定不能用，而是需要在恰当的场合使用恰当的特性。比如：能在编译时解决掉的问题没必要留到运行时、能用多态搞定的事情也没必要使用 dynamic_cast 和 [typeid](https://www.zhihu.com/search?q=typeid&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A170472080}) 等。



##  其他================

### C++与C、python、Java的区别

**C++ 和C 语言和区别**

1. C 语言是 C++ 的子集，c++可以兼容 c 语言，但是 c++ 里面又引入了很多新特性，如引用、智能指针、类等
2. c++ 是面向对象的语言，c 是面向过程的语言
3. c 语言中存在一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄漏等。而 C++ 增加了新特性来改善安全性，如 const常量、智能指针、cast 转换、try-catch 异常处理等
4. c++的可复用性高，引入了模板的概念。并在此基础上实现了标准模板库 STL，与 c语言函数库相比更加灵活
5. 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。
6. 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。

**C++和Python的区别**

1. Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。
2. Python使用缩进来区分不同的代码块，C++使用花括号来区分
3. C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
4. Python的库函数比C++的多，调用起来很方便

**C++ 和Java 的对比**

- **相同之处**: `C++` 与 `Java` 均支持面对对象（`Object Oriented`），支持类、继承、封装等常见的概念
- 两者之间的不同之处：
  - Java 被编译成字节码，并运行在虚拟机 JVM 上，和开发平台无关，具有跨平台的特性；C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持
  - Java 是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。
  - C++ 支持方法与操作符的重载；但 Java 只支持方法重载，不支持操作符重载。
  - C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。
  - C++ 标准库不提供 thread 相关接口；Java 的标准 SDK 提供 thread 类。
  - C++ 支持结构体（structure）与联合体（union），Java 不支持结构体（structure）与联合体（union）。
  - 从应用场景来说， C++ 可以直接编译成可执行文件，运行效率比 Java 高。Java 目前主要用来开发 Web 应用。C++ 主要用在嵌入式开发、网络、并发编程、图形图像处理、系统编程的方面。

















### #include<file.h> #include “file.h” 的区别

区别：

前者是**从标准库路径**寻找
后者是从**当前工作路径**

- 查找文件的位置：

  **include<filename>** 通常在编译器或者 IDE 中**预先指定的搜索目录**中进行搜索，通常会搜索 **/usr/include 目录**，此方法通常用于包括标准库头文件；

  **#include "filename"** 在**当前源文件所在目录中**进行查找，如果没有；再到当前已经添加的系统目录（编译时以 -I 指定的目录）中查找，最后会在 /usr/include 目录下查找 

- 日常编写程序时，对于**标准库中的头文件**常用 include<filename>，对于**自己定义的头文件**常用 #include "filename"。

- __has_include：C++ 17 支持该特性，用来检查是否已经包含某个文件:



### #ifdef、#endif和#ifndef与program once 的区别

利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。

```cpp
#ifdef MATH
#include "math.c"
#endif
```

在子程序前加上标记，以便于追踪和调试。

```cpp
#ifdef DEBUG
printf ("Indebugging......!");
#endif
```

应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。

**采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。**



**ifndef与program once 的区别**

同点： 它们的作用是**防止头文件被重复包含**。
不同点：

ifndef 由**语言本身**提供支持，但是 program once 一般由**编译器**提供支持，也就是说，有可能出现编译器不支持的情况(主要是比较老的编译器)。
通常**运行速度上 ifndef** 一般慢于 program once，特别是在大型项目上， 区别会比较明显，所以越来越多的编译器开始支持 program once。
ifndef **作用于某一段被包含（define 和 endif 之间）的代码，** 而 program once 则是针对**包含该语句的文件**， 这也是为什么 program once 速度更快的原因。

如果用 **ifndef 包含某一段宏定义**，当这个宏名字出现“撞车”时，可能会出现这个宏在程序中提示宏未定义的情况。

相反由于program once **针对整个文件**， 因此它**不存在宏名字“撞车”**的情况， 但如果某个头文件被多次拷贝，program once 无法保证不被多次包含，因为**program once 是从物理上**判断是不是同一个头文件，而不是从内容上。







**怎么实现一个频繁使用的短小函数，优缺点？**

应该使用`inline`内联函数，即编译器将`inline`内联函数内的代码替换到函数被调用的地方。

优点：

- 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
- 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；

缺点：

- 代码膨胀，产生更多的开销；
- 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
- 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
  - 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。
  
  







### 变量声明和定义、全局和局部变量区别

**变量声明和定义区别**

- **声明**仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间

- **定义**要在定义的地方为其分配存储空间。

**相同变量可以在多处声明（外部变量extern），但只能在一处定义**

```cpp
int main() 
{
   extern int A;
   //这是个声明而不是定义，声明A是一个已经定义了的外部变量
   //注意：声明外部变量时可以把变量类型去掉如：extern A;
   dosth(); //执行函数
}
int A; //是定义，定义了A为整型的外部变量
```



**全局和局部变量区别**

- **生命周期不同：**
  全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
  **使用方式不同：**
  通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。
  **内存分配位置不同：**
  全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。
- 操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。





### c++中四种变量存储期类型

在C++语言中，变量的存储类共有如下四种： 

（1）auto存储类（自动存储类）

（2）static存储类 （静态存储类）

（3）extern存储类  (外部存储类)

（4）register存储类（寄存器存储类）

- **自动存储类**

  auto存储类，即自动存储类。在函数内部定义的变量，如果不指定其存储类，那么它就是auto类变量。这个是最常见的，所以我们不加关键字auto

  这是我们经常见到的一种变量存储类型。见如下代码：

  ```c++
  void func( ) { int a; auto int b; … }
  //a和b都是auto存储类变量
  ```

  > 自动存储类在在进入代码块（函数）之前生成，在函数体内部存活，出了函数体（函数返回）后就消失。
  >
  > 自动变量默认初始值是不确定的、
  >
  > 自动存储类每调用一次函数时都要赋一次初始值

- **静态存储类**

  static关键字在c和c++中是不同的，这个在上面说过了，具体的话可以去看上面。

- **extern存储类**

  如果在**一个文件中要引用另一个文件中定义的外部变量**，则在此文件中应用extern关键字把**此变量说明为外部**的。例如：

  ```c++
  extern int a; //a为别的文件中定义的外部变量
  int mydata; //外部变量的定义 
  extern int mydata;  //外部变量的说明 
  ```

  > 大型程序为了易于维护和理解，通常需要把程序划分为多个文件来保存，每个文件都可以单独编译，最后再把多个文件的编译结果（即目标文件）连接到一起来生成一个可执行程序。这种情况下，如果在一个文件中需要引用另一个文件中的外部变量，就需要利用extern说明。

- **register存储类**

  为了提高某些自动类变量或函数参数的处理速度，可以在定义这些变量的类型说明符的前面加上register关键字，以通知编译系统为这些变量分配寄存器来存放其值。若使用register（而非auto）存储类标识代码块内的变量，编译器就会将变量缓存于处理器内的寄存器中，此种情况下不能对该变量或其成员变量使用引用操作符&以获取其地址，因为&只能获取内存空间中的地址







### c++函数参数入栈顺序、函数调用的压栈过程

**c/c++中规定了函数参数的压栈顺序是从右至左**

本质上是因为**支持可变长参数导致**的。如果是从左至右的入站方式，最左边的参数就会被压在栈底，栈顶指针指向的是最右边的长度参数，由于可变长度，编译器无法找到最左边的参数吧。但是如果从右至左入栈，最左边的参数就在栈顶。

**printf的原理**

C/C++的函数参数是**通过压入堆栈的方式来给函数传参数的**。 最先压⼊的参数最后出来，在计算机的内存中，数据有 2 块，**⼀块是堆，⼀块是栈**（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压⼊的参数在最下面，结构上看起来是第⼀个，所以最后压⼊的参数总是能够被函数找到。 因为它就在堆栈指针的上方。**printf的第⼀个被找到的参数就是那个字符指针，就是被双引号括起来的那⼀部分， 函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移了。**



**C++函数调用的压栈过程**

当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，**main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；**

当main函数开始调用func()函数时，编译器此时会将**main函数的运行状态进行压栈**，再将func()函数的返回地址、**func()函数的参数从右到左、func()定义变量依次压栈**；当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈







举个例子：

```c++
void fun(int x, int y, int z)
{
    cout << x << &x << endl;
    cout << y << &y << endl;
    cout << z << &z << endl;
}

int main(int argc, char *argv[])
{
    fun(1, 2, 3);
    system("pause");
    return 0;
}
```

输出如下：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203301037301.png" alt="图片" style="zoom:50%;float:left" />

我们知道先入栈的占高地址，从结果看出入栈的顺序依次为`z->y->x`，即压栈顺序从右至左。















### C++异常处理方法(try、throw)、codedump

**1、try、throw和catch关键字**

C++中的异常处理机制主要使用**try**、**throw**和**catch**三个关键字。就是程序中需要throw一个类型的异常，然后catch住这个类型的异常进行处理。

程序的执行流程是**先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，**代码中使用的是数字，也可以自定义异常class。

**2、函数的异常声明列表**

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：

```text
int fun() throw(int,double,A,B,C){...};
```

这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常

**3、C++标准异常类 exception**

exception 类位于` <exception> `头文件中

下表是对层次结构中出现的每个异常的说明：

| 异常               |                     描述                      |
| ------------------ | :-------------------------------------------: |
| **std::exception** |       该异常是所有标准 C++ 异常的父类。       |
| std::bad_alloc     |           该异常可以通过 new 抛出。           |
| std::bad_cast      |      该异常可以通过 dynamic_cast 抛出。       |
| std::bad_exception | 这在处理 C++ 程序中无法预期的异常时非常有用。 |
| std::bad_typeid    |         该异常可以通过 typeid 抛出。          |
| std::logic_error   |    理论上可以通过读取代码来检测到的异常。     |
| std::domain_error  |  当使用了一个无效的数学域时，会抛出该异常。   |
|                    |                                               |
|                    |                                               |
|                    |                                               |
|                    |                                               |
|                    |                                               |
|                    |                                               |
|                    |                                               |

**codedump**


core dump 是一个程序在执行时由于某种原因（如段错误、非法指令等）而崩溃时保存的其内存镜像。在一定的条件下生成的一个叫做**core的文件**，这个core文件会记录**程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息**等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。这个内存镜像可以被后续用于调试以找出问题的根源。

原理:

当程序崩溃时，操作系统捕获该事件并决定是否生成 core dump。如果系统配置允许生成 core dump，则它会将程序的内存内容、寄存器状态、栈信息和其他相关信息保存到一个文件中。

使用:

配置系统以生成 core dump:

默认情况下，一些系统可能不会生成 core dump。在 UNIX 或 Linux 系统上，你可以使用 ulimit 命令来配置它：


ulimit -c unlimited

这会设置 core dump 文件的大小为无限制。如果你不这样做，操作系统可能会因为默认的大小限制而不生成 core dump。

分析 core dump:

一旦你有了 core dump 文件，你可以使用 gdb（GNU 调试器）或其他调试工具来分析它。例如：


gdb /path/to/executable /path/to/coredump

在 gdb 中，你可以使用各种命令，如 bt（获取回溯）、info registers（查看寄存器状态）等，以帮助你找出程序崩溃的原因。



**怎样判断两个浮点数是否相等？**

对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过**相减并与预先设定的精度比较，记得要取绝对值！**浮点数与0的比较也应该注意。与浮点数的表示方式有关

























**基础冷面试题===========**

**设置地址为0x67a9 的整型变量的值为0xaa66**

```cpp
int *ptr; 
ptr = (int *)0x67a9; 
*ptr = 0xaa66; 
```

**「注意」**：这道题就是强制类型转换的典型例子，绝大部份情况下，地址长度和整型数据的长度是一样的(此时的整型指的是 long)， 即**一个整型数据可以强制转换成地址指针类型**，只要有意义即可。



**什么运算符可以重载/不可重载？**

> 不能重载

`.`, `.*`, `::`, `?:`, `new` , `delete` , `sizeof` , `typeid` , `static_cast` , `dynamic_cast` , `const_cast` ,  `reinterpret_cast`

> 可以重载

除了不能重载的都能重载.0..

`operator new` , `operator delete` , `operator new[]` , `operator delete[]` 





**int 、bool、 float 、指针变量与 “零值”比较的if 语句**

题目中要求的是零值比较，而非与0进行比较，在C++里“零值”的范围可就大了，可以是0， 0.0 ， FALSE或者“空指针”。

下面是答案。

```cpp
//int与零值比较 
if ( n == 0 )
if ( n != 0 )

//bool与零值比较 
if   (flag) //   表示flag为真 
if   (!flag) //   表示flag为假 

//float与零值比较 
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON) //其中EPSINON是允许的误差（即精度）。
//指针变量与零值比较 
if (p == NULL)
if (p != NULL)
```



**一个函数f(int a, int b)的b和a的地址关系？**

当你调用函数f(int a, int b)时，a和b是按照顺序压入到栈中的。因此，这两个变量的地址关系通常会取决于具体的编译器以及操作系统。一般情况下，**大部分的系统都是采用从高地址向低地址分配内存的策略，所以在大部分系统上，变量b的地址会比a的地址大。**

这是因为在C/C++中，函数参数是按照**从右到左的顺序压入栈中的**。当函数被调用时，首先会**为b分配内存（即b的内存地址在栈的高地址）**，然后为a分配内存（即a的内存地址在栈的低地址）。这是为了支持变长参数列表，如printf等函数。



**sizeof(1==1) 在 C 和 C++ 中的结果**

- sizeof 接受的参数可以是对象也可以是表达式，但是 sizeof(expression) 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小
- 由于 `C` 语言没有 `bool` 类型，用整形表示布尔型，因此sizeof(1==1)返回 `4`;
- 由于 `C++` 语言有 `bool` 类型，布尔型占 `1` 个字节，因此sizeof(1==1)返回 `1`;



### 数组名取地址的增量、a和&a有什么区别

```c++
int a[][5] = {{1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15}};
// 1、对数组名取地址，增量为整个数组
// p1 指向的二维数组末尾元素的下一个字节
int *p1 = (int *)(&a + 1);  // p1 增量为 sizeof(int)
auto p1 = &a + 1;  // p1 增量为 sizeof(a)

// 2、首地址的增量是该数组的大小
// p2 指向第二个一维数组
int *p2 = (int *)(a + 1);  // p2 增量为 sizeof(int)
auto p2 = a + 1; // p2 增量为 sizeof(a[0])

// 3、a[0]是第一个一维数组
// 与 1 类似，看是否对数组名取地址
int *p3 = (int *)(a[0] + 1);  // p3 指向 a[0][1]，增量为 int
int *p4 = (int *)(&a[0] + 1); // p4 指向 a[1][0]，增量为 sizeof(int)
auto p4 = &a[0] + 1;  // p4 指向 a[1][0]，增量为 sizeof(a[0])
```

**a和&a有什么区别？**

假设数组int a[10]; int (*p)[10] = &a;其中：

- a是数组名，是数组首元素地址，+1表示地址值加上一个**int类型**的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
- &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。



#### arr和&arr[0]和&arr的不同

首先如果打印的话，三个打印的完全一样，都是数组首元素的地址。

首先&arr应该是整个元素的地址，但是打印出来却是首元素的地址，不同之处在于**对地址做加法运算后**有不同，如下：

```c++
int arr[10]={0};
printf("%p\n",arr);//首元素的地址
printf("%p\n",arr+1);

printf("%p\n",&arr[0]);//首元素的地址
printf("%p\n",&arr[0]+1);

printf("%p\n",&arr);//整个数组元素的地址
printf("%p\n",&arr+1); 
```

输出首元素地址都是相同的，arr+1和&arr[0]+1都是只移动了4个字节，但是&arr+1移动了40个字节

**结论：&arr代表的是整个数组的地址，虽然它具体表现为首个元素的地址，但是在对其进行操作时，是以整个数组为单位的。**

补充

arr 本身是左值（但不可仅凭此表达式修改），指代数组对象。不过 arr 会在大多数场合隐式转换成右值表达式 &(arr[0]) ，为指针类型，指向 arr[0] 。&arr 是右值表达式，为指针类型，指向 arr 本身。简单来说就是 **arr 本身不是地址而是指代整个数组，只不过会隐式转成指针**罢了。



**char a,char a[],char *a,char *[],char * *a 之间的区别**

1. char a

   定义了一个存储空间，存储的是char类型的变量

2. char a[]

   是一个字符数组，数组中的每一个元素是一个char类型的数据

3. char *a

   **字符串的本质（在计算机眼中）是其第一个字符的地址，c和c++中操作字符串是通过内存中其存储的首地址来完成的**

   对于char a[]来说a代表的是数组的首地址，那么对char *a来说a代表的也是字符串的首地址

   因此char a[]和char *a可以放到一块看，这两个没有本质区别。

   但是要注意对于char s[]和char* a我们可以有`a=s`，但不能有`s=a`，因为创建数组的时候s的地址不为空已经确定，但是a是一个空指针，不能将非空的地址指向空指针

4. char *a[]

   `*`的优先级是低于`[]`的，因此要先看`a[]`再看 `*`

   因此这是一个char数组，**数组中的每一个元素都是指针**，这些指针指向char类型

   `char *a[ ] = {"China","French","America","German"}`

5. char **a

   两个**代表相同的优先级，因此从右往左看，即`char*(*a)`

   char *a不就是一个**字符串数组，a代表首地址**。那么char * (*a)就是和char *a[]一样的数据结构



**一维数组名和二维数组名的区别**

不管是一维还是多维数组，都是内存中一块线性连续空间，因此在内存级别上，其实都只是一维。

所以一维数组名是指向该数组的指针，二维数组名也是指向该数组的指针，但是+1之后，跳过的是一行。

问：二维数组名为什么不能直接赋值给二级指针？

答：一句话来说就是二维数组名是行指针，也就是指向数组的指针。而二级指针是指向指针的指针，它们不是同一类型。

> 定义一维数组 `int a[i]` 和二维数组` int b[i][j]`，a相当于`int (*)`，而b相当于`int (*)[j]`。想要获得 a[i] 中第 x 个元素，可以直接使用 `*(a+x)`。而想要获得 `b[i][j] `中第 x 行第 y 个元素，则需用 `*(*(b+x)+y)`，因为 b 相当于数组指针，(b+x) 则是指向第 x 个数组的指针，注意，是指向数组，而不是数组元素！所以` *(b+x)` 获得的是第 x 个数组的数组名，即该数组的首元素地址，这时再结合偏移量 y 就可以取得该元素。



**数组指针和指针数组**

其实就是数组的指针和指针的数组

数组的指针：指向一个数组的指针就是数组指针

指针的数组：一个数组的每一个元素都是指针

有符号数和无符号数之间的转换

```
题目：
    32位机上根据下面的代码，问哪些说法是正确的？
    signed char a = 0xe0;
    unsigned int b = a;
    unsigned char c = a;

答案:
    b的十六进制表示是：0xffffffe0

解答:
    考察有符号数和无符号数之间的转换。
    1. a : 1110 0000。
    2. 扩展问题：
        长 -> 短：低位对齐，按位复制。
        短 -> 长：符号位扩展。
    3. 精度提升：
        两个变量运算，表示范围小的变量精度达的变量提升（signed -> unsigned）。
```

### 主函数的退出方式有哪些、区别

- **正常退出方式**：exit()、_exit()、return（在main中）。

  exit() 和 exit() 区别：exit() 是对 \_exit() 的封装，都会终止进程并做相关收尾工作，最主要的区别是 exit() 函数关闭全部描述符和清理函数后不会刷新流，但是 exit() 会在调用 \_exit() 函数前刷新数据流。

  return 和 exit() 区别：exit() 是函数，但有参数，执行完之后控制权交给系统。return 若是在调用函数中，执行完之后控制权交给调用进程，若是在 main 函数中，控制权交给系统。

- **异常退出方式**：abort()、终止信号。



### main执行之前和之后的代码

**main函数执行之前**，主要就是初始化系统相关资源：

- 设置栈指针
- 初始化静态 `static` 变量和 `global` 全局变量，即 `.data` 段的内容
- 将未初始化部分的全局变量赋初值：数值型 `short`，`int`，`long` 等为 `0`，`bool` 为 `FALSE`，指针为 `NULL` 等等，即 `.bss` 段的内容
- 全局对象初始化，在 `main` 之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数 `argc`，`argv` 等传递给 `main` 函数，然后才真正运行 `main` 函数
- `__attribute__((constructor))` 标识在程序启动时自动调用的构造函数。这个特性允许你在程序开始执行之前执行一些初始化操作。

**main函数执行之后**：

- **全局对象的析构函数**会在main函数之后执行；
- 可以用 `atexit` 注册一个函数，它会在 main 之后执行;允许你在程序退出之前执行一些清理操作或其他操作。它的原型定义在 `stdlib.h` 头文件中：
- `__attribute__((destructor))`  用于指定在程序退出时自动调用的析构函数。它可以用于标识一个函数，以确保在程序结束或者从 `main` 函数返回时调用这个函数。



### 宏实现：比较大小以及两个数中的最小值

实现比较简单，需要注意括号和作用域的问题，由于 #define 只是做简单的替换，而 **#define 中替代时可能含有表达式**，因此我们需要用括号进行作用域限制

```c++
#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))
```

上述可能**存在重复计算**的问题，比如表达式 `X,Y` 均计算了两次，多次计算在某些场景下性能较低或者会产生影响，可以进行简化如下:

```c++
#define MIN(x, y) ({				\
	typeof(x) _min1 = (x);			\
	typeof(y) _min2 = (y);			\
	(void) (&_min1 == &_min2);		\
	_min1 < _min2 ? _min1 : _min2; })

#define MAX(x, y) ({				\
	typeof(x) _max1 = (x);			\
	typeof(y) _max2 = (y);			\
	(void) (&_max1 == &_max2);		\
	_max1 > _max2 ? _max1 : _max2; })
```





### fork()返回0、C++函数调用的压栈过程

**fork()返回0：**

`fork()` 函数的返回值在父进程和子进程中是不同的：

- **在子进程中，`fork()` 返回 0。**这是因为子进程没有自己的子进程，所以没有子进程的 PID（进程 ID）可以返回。因此，可以通过检查 `fork()` 的返回值是否为 0 来判断当前代码是否在子进程中运行。
- **在父进程中，`fork()` 返回新创建的子进程的 PID。**这使得父进程可以通过 PID 来管理（例如发送信号、等待退出）子进程。
- 如果 `fork()` 失败（例如，因为系统已经达到了最大进程数），它会返回 -1，并在全局变量 `errno` 中设置错误码来表示具体的错误原因。

**因此，当你看到 `fork()` 返回值为 0，那就表示你当前处于子进程中。**



**函数调用的压栈过程：**

当函数从入口函数main函数开始执行时，编译器会将我们操作系统的**运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；**

当main函数开始调用func()函数时，编译器此时会将**main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈**；当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈



### 字节序、主函数，子函数的栈顶区分

**字节序：**

大端字节序：数据的高字节存放在低地址中；

小段字节序：数据的高字节存放在高地址中。



**主函数、子函数的栈顶区分：**

在一个程序中，只有一个物理的栈。但是，每当调用一个函数时，栈的顶部会发生变化，以容纳这个函数的栈帧。栈帧包含函数的局部变量、保存的寄存器、返回地址等。因此，栈顶在任何给定的时刻指向当前活动函数（正在执行的函数）的栈帧的顶部。

考虑以下简化的场景：

1. `main`函数开始执行。它的栈帧被放在栈上，这时的栈顶指向`main`函数的栈帧的顶部。
2. `main`函数调用了`subFunction`。此时，`subFunction`的栈帧被推到栈上。现在的栈顶指向`subFunction`的栈帧的顶部。
3. 当`subFunction`结束执行并返回时，其栈帧从栈上被移除。这时的栈顶再次指向`main`函数的栈帧的顶部。





### **fork()原理，与vfork、clone的区别、exec**

1. fork()是一个系统调用，会陷入内核态

2. 在内核态中，内核会创建一个新的PCB，在Linux中就是一个 task_struct 结构体，然后将父进程 task_struct 的资源（页表、文件资源、当前路径、信号、堆栈、寄存器等）完全复制给子进程的 task_struct ，这里复制指的是写时复制，内核会把资源对应的页表项设置为只读模式，此时内核是没有将物理内容真正的复制。

3. 只有当其中一个进程对资源进行了写操作，由于页表被设置为只读模式，那么此时会引发缺页中断，使得内核将共享的资源另外复制一份，然后中断返回后重新执行进程的写操作。

**fork用写时复制，那fork出子进程后，子进程和父进程谁先调度？**

一般来说是子进程优先调度。因为很多情况下，子进程被fork出来以后，就会马上执行exec，去执行另外的程序，此时会清空堆栈等一些和父进程共享的资源，加载新的代码段。如果此时是父进程先调度的话，在父进程中执行了写操作后，会触发写时复制，而子进程并不需要用到属于自己的资源，造成资源和效率浪费。所以内核一般会优先将子进程加入调度队列中。

**和vfork的区别**：

1. fork 是将父进程的所有资源的复制一份，而 vfork 是将父进程除虚拟内存以外的资源都复制一份。

2. vfork 结束后父进程和子进程是共享一个地址空间的。而 fork 结束后父进程和子进程拥有自己独立

的地址空间。

3. 并且 vfork 会阻塞父进程，直到子进程调用 exec 或者 exit，父进程才会得以执行

**和** **clone** **的区别**：

1. clone可以由用户决定复制父进程的哪些资源，共享父进程的哪些资源。

2. clone不再复制父进程的栈空间，而是自己创建一个新的栈。如果选择和父进程共享一个虚拟地址。

空间，那么此时创建的就是线程。



**fork，wait，exec函数**

fork()函数:

作用：fork函数用于创建一个新的进程，称为子进程。这个新进程是原进程的复制品，也称为父进程。子进程和父进程在内存中拥有独立的空间。

特点：子进程从父进程继承了代码、数据、堆和栈的副本。初创时，两个进程使用相同的物理内存页面，但当其中一个进程尝试写入时，会使用写时复制（Copy-On-Write）机制来分配新的内存页面。

返回值：在父进程中返回子进程的PID，在子进程中返回0。如果创建失败，返回-1。

exec()函数族:

作用：exec函数族用于在进程内执行一个新的程序。当exec被调用时，当前进程的内容（代码、数据、堆和栈）被新程序替换。

特点：调用exec后，原进程的内存映像被新程序替换，新程序从其主函数开始执行。如果exec调用成功，它就不再返回；如果调用失败，返回-1。

exec有多个变种，如execl、execp、execle、execv等，它们提供不同的方式来传递参数和环境变量。

wait()函数族:

作用：wait函数用于让父进程阻塞，直到它的一个子进程退出或被信号终止。

特点：它可以收集子进程的退出状态。这样可以防止子进程变成僵尸进程。

返回值：成功时返回终止的子进程的PID，失败时返回-1。

wait也有变种，如waitpid，它提供更多的控制，允许父进程等待指定的子进程。

总之，fork、wait和exec是UNIX和Linux系统编程中用于进程管理的基础函数。它们为开发者提供了创建、执行和管理进程的能力。



**main()之前执行的代码**

1. 全局变量的构造函数
2. 全局变量的赋值函数

```cpp
#include <iostream>
#include <vector>

using namespace std;

int a = []() {
    cout << "a" << endl;
    return 0;
}();

int main() {
    cout << "b" << endl;

    system("pause");
    return 0;
}
```









**O0、O1、O2、O3优化**

**-O0**

不做任何优化，这是默认的编译选项。 

**-O1**

主要对代码的分支、常量以及表达式进行优化。会减小代码的尺寸，缩短执行周期啥的

 -floop-optimize：执行循环优化,将常量表达式从循环中移除，简化判断循环的条件，并且optionally do strength-reduction，或者将循环打开等。在大型复杂的循环中，这种优化比较显著。 

**-O2**

O2优化再打开O1优化的前提下，尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。

所以一般来说可以直接开-O2的优化等级，

**-O3**

 在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。

这个好像不推荐，因为会增加编译失败和程序不可预知的一些行为，不建议使用



**带返回值的函数不return会怎么样？**

首先不是BUG，这种情况属于**未定义的行为**，而未定义的行为不会导致编程失败。

当main函数没有return结尾的时候会在生成的目标文件中自动加入return 0



**switch 的 case 里为何不建议定义变量**

- switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的
- 比如在符合 `A` 的条件下定义了变量，当符合 `B` 或者 `C` 的条件时，对该变量进行自增操作，但是因为不符合条件 `A` 未对变量进行定义，该变量无法使用











# C++面对对象=======================

### 面向对象及其三大特性

- 面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。

- **面向对象的三大特性：**

  - 封装：**将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。**

    把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部分意外的改变或错误的使⽤了对象的私有部分。



    通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。
  
    在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

    在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员.

  - 继承：**让某种类型对象获得另一个类型对象的属性和方法，使得派生类可以使用父类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。**
  
    **三种方式：**
  
    1. 实现继承：使用基类的属性和方法而无需额外编码的能力
    2. 接口继承：仅使用属性和方法的名称，但子类必须提供实现的能力
    3. 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力
  
  - 多态：**在 C++ 中多态一般是使用虚函数来实现的，使用基类指针调用函数方法时，如果该指针指向的是一个基类的对象，则调用的是基类的虚函数；如果该指针指向的是一个派生类的对象，则调用的是派生类的虚函数。**
  
    多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式
    
    多态与非多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。
    
    
    
    
    
    

### 覆盖、重载和隐藏的区别

 - **覆盖（重写）**

   派生类中**重新定义的函数**，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有**函数体有区别**。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。**（完全相同才可，并且基类函数需要定义为虚函数）**

 - **重载**

   具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。**（参数列表不同）**

   **隐藏**

   **指派生类函数屏蔽了与其同名的函数**，要求基类和派生类函数同名即可。其他状态同覆盖。隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。**（函数名相同即可，需要调用基类的同名函数需要加上作用域）**



### 面向对象和面向过程语言的区别

基本思路：

面向过程：关注的是任务的执行步骤。解决问题时，首先要分析任务的处理流程，然后用函数来实现流程中的每一步。


面向对象：关注的是对象及其属性和行为。解决问题时，首先要分析涉及的对象以及对象的属性和行为，然后模拟这些对象来完成任务。


数据与函数的关系：


面向过程：数据和函数是分开的。函数可以操作输入的数据。

面向对象：数据和行为（通常以方法的形式）被封装在一起，成为一个“对象”。



### 模板

#### 模板概念，底层实现、泛型编程（实现、优缺点）

**模板概念：**

模板是 C++ 编程语言的一个特性，它允**许函数和类使用泛型类型进行操作**。这允许**一个函数或类在许多不同的数据类型上工作，而无需为每个类型重写**。C++ 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码，**C++ 中使用 template 关键字**。模板是**创建泛型类或函数的蓝图**或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。

共有三种模板：**函数模板、类模板以及自 C++ 14 以来的变量模板**

**泛型编程**是一种编程风格。

在**c中不同参数相同功能函数名不同，现在函数名相同，但是可能参数类型不同也要重新写函数**。模板出现就是提高了程序的复用性，提高效率。用一种广泛的表达去取代具体数据类型，这在c++中就叫做模板编程。

c++模板主要分成两大类：**函数模板和类模板。**

模板的格式是`template<template T>`或者`template<class T>`。template是一个声明模板的关键字，表示声明一个模板关键字class不能省略，如果类型形参多余一个 ，每个形参前都要加class <类型 形参表>可以包含基本数据类型可以包含类类型.



**模板底层实现：**

编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产⽣不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调⽤的地⽅对参数替换后的代码进行编译。



这是因为函数模板要被实例化后才能成为真正的函数，在使⽤函数模板的源⽂件中包含函数模板的头⽂件，如果该

头⽂件中只有声明，没有定义，那编译器⽆法实例化该模板，最终导致链接错误。

编译器**从函数模板通过具体类型产生不同的函数**；

编译器会对函数模板进行**两次编译**：在**声明的地方对模板代码本身进行编译**，在**调用的地⽅对参数替换后的代码进行编译**。 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源⽂件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器⽆法实例化该模板，最终导致链接错误。



**泛型编程如何实现、优缺点：**

- 泛型编程实现的基础：**模板**。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。
- 泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。
  - 容器：涉及到 STL 中的容器，例如：vector、list、map 等
  - 迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。
  - 模板
- 泛型编程优缺点：
  - **通用性强：**泛型算法是建立在语法一致性上，运用到的类型集是无限的/非绑定的。
  - **效率高：**编译期能确定静态类型信息，其效率与针对某特定数据类型而设计的算法相同。
  - **类型检查严：**静态类型信息被完整的保存在了编译期，在编译时可以发现更多潜在的错误。
  - 二进制复用性差：泛型算法是建立在语法一致性上，语法是代码层面的，语法上的约定无法体现在机器指令中。泛型算法实现的库，其源代码基本上是必须公开的，引用泛型中库都需要重新编译生成新的机器指令。而传统的 C 库全是以二进制目标文件形式发布的，需要使用这些库时直接动态链接加载使用即可，不需要进行再次编译。



#### 函数模板和类模板的区别、模板和函数重载，继承的区别

**函数模板和类模板的区别：**

- 实例化方式不同：函数模板实例化由**编译程序在处**理函数调用时自动完成，类模板实例化需要在程序中显式指定。
- 实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。
- 默认参数：函数模板不允许有默认参数，类模板在模板参数列表中可以有默认参数。
- 特化：**函数模板只能全特化**；而类模板可以全特化，也可以偏特化。
- 调用方式不同：函数模板可以进**行类型推导**，可以隐式调用，也可以显式调用；类模板只能显式调用



**模板和函数重载的区别：**

 **函数重载和模板都是面向对象多态特性的**例子。

当多个函数执行非**常相似（不相同）的操作**时使用函数重载，

当多个函数执行**相同操作时**使用模板，函数模板也可以重载。

当模**板类或者模板函数中含有静态变量**时，则每个模板的实例类型都含有一个静态成员。



**模板和继承的区别：**

**第一点：**

模板可以生成一组类或者函数，这些类或函数的实现都是一样的

继承是事物之间的一种关系，从父类到子类实际上就是从普遍到特殊、从共性到特性

**第二点：**

模板和继承都是多态性的体现，**继承是运行时的多态性，模板是编译时**的多态性。

**第三点：**

继承是数据的复制、模版是代码的复制。

模板函数在编译完成之后，会生成对应参数数类型的函数；

继承是对虚表、数据的复制







类模板和模板类的区别

1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数
2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。



#### 函数模板（与普通函数的区别）、类模板

通过定义一个函数模板，可以避免为每一种类型定义一个新函数。

- 对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。
- **函数模板实例化**：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。

函数模板分为**成员函数模板和普通函数模板。**

**调用方式（重要）：**

1. 自动类型推导，隐式调用 `mySwap(a, b)`

2. 显式指定类型 `mySwap<int>(a, b)`


**模板注意事项：**

1. **自动类型推导，**必须推导出一致的数据类型T才可以使用。也就是说参数类型和你模板定义的得一致才行。
2. 模板必须要确定出T的类型



**普通函数与函数模板的区别：**

1. 普通函数调用时可以发生自动类型转换（隐式类型转换）
2. 如果使用函数模板，自动类型推导的话，则不会发生隐式转换
3. 如果使用函数模板，显式指定类型，则可以发生隐式转换

**普通函数与函数模板的调用规则：**

1. 优先调用普通函数

2. 可以**使用空模板参数**来强制调用模板函数

   `myPrint<>(arg1, arg2,...)`

3. **函数模板也可以重载**

4. 如果函数模板可以产生更好的匹配，优先调用函数模板





**类模板（成员函数创建时间、对象做函数参数、与继承基类模板）：**

类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，**类模板**没有自动类型推导的使用方式，只有显式指定参数类型

**类模板中成员函数创建时间：**

1. 普通类中的成员函数在编译的时候就创建
2. 类模板中的成员函数在**调用的时候**才会创建

**类模板对象做函数参数：**

就是类模板实例化出的对象，作为参数的形式传入函数

1. 指定传入的类型 —— 直接显示对象的数据类型

   ```c++
   void print(Person<string, int>&p);
   ```

2. **参数模板化** —— 将对象中的参数变为模板进行传递

   ```c++
   template<class T1, class T2>
   void print(Person<T1, T2>& p);
   ```

3. **整个类模板化** —— 将整个对象类型模板化进行传递

   ```c++
   template<class T>
   void print(T& p);
   ```

**类模板与继承：**

1. 当派生类继承基类的一个类模板时，子类在声明时，要指定出分类中的T类型

   ```c++
   template<class T>
   class Father{
       T m;
   };
   
   //报错
   class Son: public Father{
       
   }; 
   
   //正确
   class Son: public Father<int>{
       
   }; 
   ```

   > 因为子类要继承父类中的成员变量，但是模板没有指定内存大小，所以是不确定的，而不确定性是c++所嗤之以鼻的。因此**继承的时候得指定要继承模板的数据类型**才行。
   >
   > 但是这样不灵活，父类中的类型就被定死了，有违背c++灵活编程，所以这种方法不太实用

2. 如果不指定，编译器无法给**子类非配内存**

3. 如果要灵活的话，**子类也需变为类模板**

   ```c++
   template<class T1, class T2>
   class Son: public Father<T2>{
       T1 obj;
   }; 
   ```

**类模板成员函数的类外实现**

```c++
//构造函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){}

//成员函数类外实现
template<class T1, class T2>
void Person<T1, T2>::show(){}
```













#### 可变参数模板、模板特化是什么、模板全特化和偏特化

**可变参数模板：**

- 可变参数模板：**接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包**。
  - 模板参数包：表示零个或多个模板参数；
  - 函数参数包：表示零个或多个函数参数。
  - 用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class... 或 typename... 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof... 运算符
- 可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值

**模板特化是什么：**

- **模板特化的原因：**

  **模板并非对任何模板实参都合适、都能实例化**，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。

- **模板特化：**

  模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化

  - **函数模板特化：**将函数模板中的全部类型进行特例化，称为函数模板特化。
  - **类模板特化：**将类模板中的部分或全部类型进行特例化，称为类模板特化。

- 特化分为全特化和偏特化：

  - 全特化：模板中的模板参数全部特例化。
  - 偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。

- 说明：要区分下函数重载与函数模板特化

- 定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配

**模板全特化和偏特化：**

模板分为**类模板与函数模板**，特化分为**特例化（全特化）和部分特例化（偏特化）**。
对模板特例化是因为对特定类型，可以利用某些特定知识来提高效率，而不是使用通用模板。

**函数模板：**

- **模板和特例化版本**应该声明在同一头文件，所有同名模板的声明应放在前面，接着是特例化版本。
- **一个模板被称为全特化**的条件：1.必须有一个主模板类。2.模板类型被全部明确化。

**对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类>偏特化类>主版本模板类。**



#### 函数模板和类模板的特例化、类模板何时实例化

**函数模板和类模板的特例化：**

**「引入原因」**

编写单一的模板，它能适应多种类型的需求，使**每种类型都具有相同的功能**，但对于**某种特定类型，如果要实现其特有的功能**，单一模板就无法做到，这时就需要**模板特例化**

**「定义」**对单一模板**提供的一个特殊实例**，它将一个或多个模板参数绑定到**特定的类型或值上**

**（1）函数模板特例化**

必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参。

**「本质」**特例化的本质是**实例化一个模板**，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个**cosnt char*相对于T，更匹配实参类型**），注意二者函数体的语句不一样了，实现不同功能。

**「注意」**模**板及其特例化版本应该声明在同一个头文件**中，且所有同名模板的声明应该放在前面，后面放特例化版本。

**（2）类模板特例化**

原理类似函数模板，不过在类中，我们**可以对模板进行特例化，也可以对类进行部分特例化**。对类进行特例化时，仍然用template<>表示是一个特例化版本，

**「类模板的部分特例化」**

**不必为所有模板参数提供实参**，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为**其特例化版本中未指定的模板参数提供实参**(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)

**「特例化类中的部分成员」**

可以特例化**类中的部分成员函数**而不是整个类



**类模板何时实例化：**

1. **模板实例化**：模板的实例化分为**显示实例化和隐式实例化**，前者是研发人员明确的**告诉模板应该使用什么样的类型去生成具体的类或函数**，后者是在**编译的过程中由编译器来决定使用什么类型来实例化一个模板**，不管是显示实例化或隐式实例化，最终**生成的类或函数完全是按照模板的定义来实现的**。
2. **模板具体化**：当模板使用**某种类型类型实例化后生成的类或函数不能满足需要**时，可以考虑**对模板进行具体化**。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。





#### C++14变量模板、成员函数模板不能是虚函数

**C++14变量模板：**

在 `C++14` 以后，**变量也可以参数化**为特定的类型，这称为变量模板。使用变量模板时，必须**显式地指定它的类型**

- 函数重载与模板的区别: 函数重载和模板都是面向对象多态特性的例子。当多个函数执行非常相似（不相同）的操作时使用函数重载，**当多个函数执行相同操作时使用模板**。当模板类或者模板函数中含有静态变量时，则**每个模板的实例类型都含有一个静态成员**。



**成员函数模板不能是虚函数**  

 因为c++ 编译器在解析一个类的时候就要确定虚函数表的大小，如果允许一个虚函数是模板函数，那么compiler就需要在parse这个类之前扫描所有的代码，找出这个模板成员函数的调用（实例化），然后才能确定vtable的大小，而显然这是不可行的，除非改变当前compiler的工作机制。因为类模板中的成员函数在调用的时候才会创建





**模板和实现可以写在一个文件吗**

不可以。编译能通过，连接不能通过。如下代码：

```c++
// add.h
template <typename T>
T add(const T &a, const T &b);

// add.cpp
#include "add.h"
template <typename T>
T add(const T &a, const T &b)
{
    return a + b;
}

// main.cpp
#include "add.h"
int main()
{
    int i = add(1, 1);
    return 0;
}

$ gcc -c main.cpp          # main.cpp编译通过
$ gcc -c add.cpp           # add.cpp编译通过
$ gcc -o main main.o add.o # 链接失败！
main.o: In function `main':
main.cpp:(.text+0x34): undefined reference to `int add<int>(int const&, int const&)'
collect2: error: ld returned 1 exit status
```

编译器面对巨量代码的时候，也是以一个一个的.cpp/.c文件作为基本单元，**根据代码的include包含找到声明，翻译代码产生.o文件**。注意他们每个cpp/c文件都是相互独立完成自己工作的，对于缺少的部分，如果妥善声明，会留待链接过程的时候产生引用关系。由于我们在**编译main.cpp的时候只是找到了.h文件，即模板的声明，但是没有模板函数的具体实现，因此就没有办法实例化add函数。**在add.cpp中有模板函数的使用，可以实例化，但是cpp编译单元中并没**有人使用该函数，因此该cpp不会产生任何可执行代码，编译add.cpp时没有生成可执行代码**。因此在链接的时候会报错，因为没有可执行代码

《C++编程思想》第15章(第300页)说明了原因：**模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知**。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。





























### 多态问题

#### 多态的概念、实现原理、两种实现

**多态的概念：**

多态是同一个事物在不同场景下的多种形态。就是**不同继承类的对象，对同一消息做出不同的响应**，**基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式**。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，**运行时将会根据对象的实际类型来调用相应的函数**。如果**对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数**。

- 虚函数的调用是在运行时决定，是由本身所指向的对象所决定的。
- 如果使用虚函数，基类指针指向派生类对象并调用对象方法时，使用的是子类的方法;
- 如果未使用虚函数，则是普通的隐藏，则基类指针指向派生类对象时，使用的是基类的方法（与指针类型看齐）
- 基类指针能指向派生类对象，但是派生类指针不能指向基类对象



**多态的实现原理:**

- 多态是通过虚函数实现的，**虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中**。**不同继承类的对象，对同一消息做出不同的响应**，**基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式**。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，**运行时将会根据对象的实际类型来调用相应的函数**。如果**对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数**。
- 虚函数表是由**编译器自动生成与维护的**。virtual 成员函数会被编译器放入虚函数表中，存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr 指针）。在多态调用时，vptr 指针就会根据这个对象在对应类的虚函数表中查找被调用的函数，从而找到函数的入口地址。
- 当基类指针指向派生类对象，基类指针调用虚函数时，该**基类指针指的虚表指针实际指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数然后调用执行**



**多态的两种实现：**

多态分为**静态多态和动态多态**。

静态多态是通过**重载和模板**技术实现的，在编译期间确定，静态多态有**函数重载、运算符重载、泛型编程**等；

动态多态是通过**虚函数和继承关系**实现的，执行动态绑定，在运行期间确定。在程序运行时根据基类的指针指向的对象来确定自己具体该调用哪一个类的虚函数。当父类指针（引用）指向 父类对象时，就调用父类中定义的虚函数；即当父类指针（引用）指向 子类对象时，就调用子类中定义的虚函数。

**动态多态行为的表现效果为：同样的调用语句在实际运行时有多种不同的表现形态。**



#### 动态多态的实现条件，作用、编译时，运行时多态的区别，优缺点

**动态多态的实现条件、动态绑定实现**

- 要有继承关系 - 要有虚函数重写（被 virtual 声明的函数叫虚函数）
- 要有父类指针（父类引用）指向子类对象
- #### 动态绑定的实现：

  当编译器发现**类中有虚函数**时，会**创建一张虚函数表**，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针`vptr`，用于**指向类的虚函数表**。**当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。**

**动态多态的作用：**

- **隐藏实现细节，使代码模块化**，提高代码的可复用性；
- 接口重用，使**派生类的功能可以被基类的指针/引用所调用**，即向后兼容，提高代码的可扩充性和可维护性。





**编译时，运行时多态的区别，优缺点：**

- **编译时多态：**在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。实际在编译器内部看来**不管是重载还是模板**，编译器内部都会生成不同的函数，在代码段中分别装有两个函数的不同实现。
- **运行时多态：**运行时多态也称**动态绑定**，借助**虚函数表**来实现，发生在程序的运行过程中，通过**基类的指针或引用访问派生类中的虚函数**。

**优缺点分析**：

- **运行期多态优点**
  1. 灵活
  2. 方便程序耦合同时减少内聚
  3. 能够处理异质对象集合（一个动物园有一堆动物，每一种动物都是一个对象）
- 运行期多态缺点
  1. 运行期间进行虚函数绑定，提高了程序运行开销。
  2. 庞大的类继承层次，对接口的修改易影响类继承层次。
  3. 由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
- **编译期多态优点**
  1. 它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。
  2. 在编译器完成多态，提高运行期效率。
  3. 具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。
- 编译期多态缺点
  1. 程序可读性降低，代码调试带来困难。
  2. 无法实现模板的分离编译，当工程很大时，编译时间不可小觑。
  3. 无法处理异质对象集合。



### 虚函数

#### 虚函数，纯虚函数的概念、区别、作用

**虚函数，纯虚函数的概念：**

- **虚函数：**被 `virtual` 关键字修饰的成员函数，`C++` 的虚函数在运行时**动态绑定**，从而实现多态
- **纯虚函数：**纯虚函数在类中声明时，用 **virtual 关键字**修饰且**加上 =0**，且**没有函数的具体实现**；含有纯虚函数的类称为**抽象类（只要含有纯虚函数这个类就是抽象类）**，类中只有接口定义，没有具体的实现方法；继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，**不能实例化对象**。
- **抽象类说明:**
  - 抽象类对象不能作为函数的参数，**不能创建对象**，不能作为函数返回类型；
  - 可以**声明抽象类指针**，可以声明抽象类的引用；
  - **抽象类只能作为基类**来使用，其**纯虚函数的实现**由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。



**虚函数和纯虚函数区别：**

- 虚函数和纯虚函数可以出现在**同一个类**中，该类称为**抽象基类**（含有纯虚函数的类称为抽象基类）
- **使用方式不同：**虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；
- **定义形式不同：**虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上 virtual 关键字还需要加上 =0;
- 纯虚函数必须实现，否则编译器会报错；
- 对于**实现纯虚函数的派生类**，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在**派生类中重写**；
- **析构函数最好定义为虚函数**，特别是对于含有继承关系的类；**析构函数可以定义为纯虚函数**，此时，其所在的类为抽象基类，**不能创建实例化对象**



**纯虚函数作用：**

- 含有**纯虚函数的基类**要求**任何派生类都要定义自己的实现方法**，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。定义纯虚函数是为了实现**统一的接口属性**，用来**规范派生类的接口属性**，也即强制要求继承这个类的程序员必须实现这个函数。
- 纯虚函数的意义在于，**让所有的类对象（主要是派生类对象）都可以要求实现纯虚函数的属性，在面对对象设计中非常有用的一个特性**
- 实现方式是在虚函数声明的结尾加上`= 0`即可。







**虚函数表内存布局：**

1. 虚函数在地址空间中的存放

   ![这里写图片描述](https://img-blog.csdn.net/20180820143644168?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2. 单一继承的虚函数表：（ClassB继承ClassA）

   ![这里写图片描述](https://img-blog.csdn.net/20180820162125485?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3. 多重继承的虚函数表：（ClassC继承ClassB，ClassB继承ClassA）

   ![这里写图片描述](https://img-blog.csdn.net/20180821103628852?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4. 多继承下的虚函数表：（ClassC依次继承ClassA1、ClassA2）

   ![在这里插入图片描述](https://img-blog.csdn.net/20181023164040667?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





#### 虚函数的实现原理（虚表，虚表指针）

**虚函数的实现原理:**

- **实现原理：**虚函数通过**虚函数表**来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向**虚函数表的指针**（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用**基类的指针来操作一个派生类**的时候，这张虚函数表指明了实际应该调用的函数。
- 每个使用**虚函数的类**（或者从使用虚函数的类派生）都有自己的虚函数表。该表是编译器在**编译时设置的静态数组**，一般称为 vtable。虚函数表包含可由**该类调用的虚函数**，此表中的每个条目是一个函数指针，指向该类可访问的虚函数。
- 每个对象在创建时，编译器会为**对象生成一个指向该类的虚函数表的指针**，称为 vptr。vptr 在创建类实例时自动设置，以便指向该类的虚拟表。如果对象（或者父类）中含有虚函数，则编译器一定会为其分配一个 vptr；如果对象不包含（父类也不含有），此时编译器则不会为其分配 vptr。**与 this 指针不同，this 指针实际上是编译器用来解析自引用的函数参数，vptr 是一个真正的指针**。

**虚函数表概念：**

- 虚函数表存放的内容：**类的虚函数的地址。**
- 虚函数表建立的**时间**：**编译阶段**，即程序的编译过程中会将虚函数的地址放在虚函数表中。
- **虚表指针**保存的位置：**虚表指针**存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。
- **虚函数表和类绑定，虚表指针和对象绑定**。即**类的不同的对象的虚函数表是一样的，但是每个对象在创建时都有自己的虚表指针 vptr**，来指向类的虚函数表 vtable

**虚函数表指针 vptr概念:**

- 带有虚函数的类，通过**该类所隐含的虚函数表**来实现多态机制，该**类的每个对象均具有一个指向本类虚函数表的指针**，这一点并非 C++ 标准所要求的，而是编译器所采用的内部处理方式。实际应用场景下，不同平台、不同编译器厂商所生成的虚表指针在内存中的布局是不同的，有些将**虚表指针置于对象内存中的开头处**，有些则置于结尾处。如果涉及多重继承和虚继承，情况还将更加复杂。因此永远不要使用 C 语言的方式调用 memcpy() 之类的函数复制对象，而**应该使用初始化（构造和拷构）或赋值的方式来复制对象**。









虚函数表问题2

虚函数的性能分析

第一步是通过**对象的vptr找到该类的vtbl**，因为虚函数表指针是编译器加上去的，通过vptr找到vtbl就是指针的寻址而已。

第二部就是找到**对应vtbl中虚函数的指针**，因为vtbl大部分是指针数组的形式实现的

在**单继承的情况下调用虚函数所需的代价基本上和非虚函数效率一样**，在大多数计算机上它多执行了很少的一些指令

在**多继承的情况由于会根据多个父类生成多个vptr**，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些

空间层面为了实现运行时多态机制，**编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，所以虚函数的一个代价就是会增加类的体积。在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。**但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。**如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费**。同时由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。在单继承或没有继承的情况下，类的每个对象只会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。



#### 构造函数不能为虚函数、析构函数为虚函数

- **构造函数不能为虚函数：（static 函数不能定义为虚函数）**

  1). 因为创建一个对象时需要确定**对象的类型**，而虚函数是在**运行时确定其类型**的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是**类本身还是类的派生类**等等。
  2). 虚函数的调用需要**虚函数表指针**，而该指针存放在对象的内存空间中；**若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数**

- **析构函数为虚函数：**

  析构函数可以为虚函数，并且一般情况下**基类析构函数要定义为虚函数**。

  只有在**基类析构函数**定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。

  析构函数可以是**纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但**派生类中可以根据自身需求重新改写基类中的纯虚函数**。

  **防止内存泄漏**，实际应用时当基类的指针或者引用指向或绑定到派生类的对象时，**如果未将基类的析构函数定义成虚函数，当我们对基类指针执行 delete 操作时，此时只会调用基类的析构函数**，将基类的成员所占的空间释放掉，而派生类中特有的资源就会无法释放而导致内存泄漏。所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而**销毁派生类对象中的所有数据**。

  







#### **哪些函数不能是虚函数**、虚函数表和虚表指针的位置

**哪些函数不能声明为虚函数:**

普通函数（普通函数没有类）、**静态成员函数、内联成员函数、构造函数、友元函数**

1. **构造函数**：构造函数用来创建一个新的对象，而虚函数的运行是建立在对象已经实例化的基础上，**在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数。**在派生类的构造函数中调用虚函数，执行的是基类的版本。

2. **inline内联成员函数**：因为内联成员函数是在**编译期展开**的，而虚函数是在运行时才动态绑定的，在运行前内联函数就已经确定了。

3. **静态成员函数**：静态成员函数对于**每个类来说只有一份代码，所有的对象都共享这一份代码**，他也没有要动态绑定的必要性。并且**静态成员函数属于一个类而非某一对象**，没有this指针,它无法进行对象的判别。

   在C++中，静态成员函数不能被声明为virtual函数。首先会编译失败，也就是不能同过编译。

   原因如下：

   1. static成员不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有任何意义的。
   2. 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有隐藏的this指针。对于虚函数，它的调用恰恰需要this指针。在有虚函数的类实例中，this指针调用vptr指针，vptr找到vtable(虚函数列表)，通过虚函数列表找到需要调用的虚函数的地址。总体来说虚函数的调用关系是：this指针->vptr->vtable ->virtual虚函数。所以说，static静态函数没有this指针，也就无法找到虚函数了

4. **友元函数**：因为友元函数不是类成员，只有类成员才能使虚函数。C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

5. **成员函数模板不能是虚函数**。因为c++ 编译器在解析一个类的时候就要确定虚函数表的大小，如果允许一个虚函数是模板函数，那么compiler就需要在parse这个类之前扫描所有的代码，找出这个模板成员函数的调用（实例化），然后才能确定vtable的大小，而显然这是不可行的，除非改变当前compiler的工作机制。因为类模板中的成员函数在调用的时候才会创建

   





**虚函数表和虚表指针的位置：**

在gcc编译器的实现中虚函数表vtable存放在**可执行文件的只读数据段.rodata**中。既不在堆上，也不在栈上。虚函数表（vtable）的表项在编译期已经确定，也就是一组常量函数指针。跟代码一样，在程序编译好的时候就保存在**可执行文件里面**。程序运行前直接加载到内存中即可。而堆和栈都是在运行时分配的。

而跟**虚函数表对应的，是虚函数表指针（vptr）**，作为对象的一个（隐藏的）成员，总是跟对象的其他成员一起。如果对象分配在堆上，vptr也跟着在堆上；如果对象分配在栈上，vptr也在栈上……



**编译器如何处理虚函数表**

对于派生类来说，编译器简历虚表的过程有三步：

1. 拷贝基类的虚函数表，如果是多继承，就拷贝每个基类的虚函数表
2. 查看派生类中是否有重写基类的虚函数，如果有，就替换成已经重写后的虚函数地址
3. 查看派生类中是否有新添加的虚函数，如果有，就加入到自身的虚函数表中



#### 虚函数表针对类、初始化时间

**虚函数表针对类：**

虚函数表是针对类的，**类的所有对象共享这个类的虚函数表**，因为每个对象内部都保存一个指向该类虚函数表的指针`vptr`，每个对象的`vptr`的存放地址都不同，但都指向同一虚函数表。

**虚函数表初始化时间：**

- 在**派生类定义对象**时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化;

  构造函数是在**程序的执行到达定义这个对象的位置时**调用的（运行期）



#### 一类创多对象有几个虚函数表

- 一个类的多个对象是**共享一个虚函数表的**，虚函数表内**有几个虚函数就有多少个指针**
- **子类对象具有两个虚函数表指针**，一个指向自己的，一个指向父类的虚函数表指针；子类是有父类的**整个数据的**，子类对象内存中存在父类的一个实例
- 针对**单**继承：若没有覆盖虚函数，则父类的虚函数在子类的虚函数前面；若覆盖了虚函数则**覆盖的f()函数被放到了虚表中原来父类虚函数的位置，没有被覆盖的函数依旧**；
- 针对**多重**继承：**若没有覆盖虚函数，每个父类都有自己的虚表， 子类的成员函数被放到了第一个父类的表中**（所谓的第一个父类是按照声明顺序来判断的）；**若有覆盖虚函数f，则父类虚函数表中的f()的位置被替换成了子类的函数指针**



#### 构造函数和析构函数中可调用虚函数

- 可以，但是**没有动态绑定**的效果

- **父类构造函数**中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数

- 因为父类对象会在子类之前进行构造，此时**子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的**，故而C++不会进行动态联编

- 析构函数是用来销毁一个对象的，在销毁一个对象时，**先调用子类的析构函数，然后再调用基类的析构函数**。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义









#### 单继承和多继承的虚函数表

1. **单继承：** 在单继承中，一个派生类只能继承一个基类，因此虚函数表的结构相对简单。每个类（包括基类和派生类）都有一个对应的虚函数表，虚函数表中存储了类中的虚成员函数的指针。派生类会继承基类的虚函数表，并可以通过虚函数表调用基类的虚函数。
2. **多继承：**在多继承中，一个派生类可以从多个基类继承，这就涉及到处理多个虚函数表的情况。在多继承中，每个基类都有自己的虚函数表，派生类会在其内存布局中包含每个基类的虚函数表。此时，为了支持正确的函数调用和动态绑定，编译器会在派生类的虚函数表中添加一些额外的信息，以便在运行时正确地查找和调用虚函数。

总之，单继承和多继承都使用**虚函数表来实现动态绑定和多态**。在单继承中，**一个派生类只继承一个基类的虚函数表**，而在多继承中，派生类的虚函数表可能会包含多个基类的虚函数表指针。这些机制确保了在运行时能够正确调用相应的虚函数，实现了多态性。

- 编译器将虚函数表的**指针放在类的实例对象的内存空间**中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。
- 如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。
- 如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说**虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中**。
- 如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。





把所有函数设为虚函数:

不行。首先，虚函数是有代价的，由于**每个虚函数的对象**都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。



对象访问虚函数和普通成员函数哪个快？

- 访问普通成员函数更快，因为普通成员函数的**地址在编译阶段**就已确定，因此在访问时直接调用对应地址的函数，而虚函数在调用时，需要**首先在虚函数表中寻找虚函数所在地址**，因此相比普 通成员函数速度要慢一些














### 类对象构造析构

#### 构造函数有几种、默认生成哪些函数、类的默认构造函数

**构造函数有几种：**

默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。

1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。
2. **赋值构造函数**默认实现的是**值拷贝（浅拷贝）**。
3. **移动构造函数。**用于将其他类型的变量，**隐式转换为本类对象**。

**类默认会生成哪些函数：**

1. 一个无参的默认构造函数
2. 拷贝构造函数（浅拷贝）
3. 拷贝赋值运算符
4. 析构函数（非虚）

**类的默认构造函数：**

- **默认构造函数**是在**没有显式提供初始化式时调用的构造函数**。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。
- **用户定义的默认构造函数**：
  - 用户自定义的不带参数的构造函数，未提供任何实参，程序运行时会调用默认的构造函数。
  - 用户自定义的构造函数，但为所有形参提供默认值的构造函数，程序运行时会调用所有形参提供默认值的构造函数。
- **编译器自动分配的合成默认构造函数**
  - 如果用户定义的类中没有显式的定义任何构造函数，编译器就会自动为该类型生成默认构造函数，称为合成的默认构造函数。
  - 一般情况下，如果类中包含内置或复合类型的成员，则该类就不应该依赖于合成的默认构造函数，它应该定义自己的构造函数来初始化这些成员。
  - 多数情况下，编译器为类生成一个公有的默认构造函数，只有下面两种情况例外:
    - **一个类显式地声明了任何构造函数，**编译器不生成公有的默认构造函数。在这种情况下，如果程序需要一个默认构造函数，需要由类的设计者提供。
    - **一个类声明了一个非公有的默认构造函数**，编译器不会生成公有的默认构造函数。
  - 在大多数情况下，C++ 编译器为未声明构造函数之 class 合成一个默认构造函数：
    - 如果该类没有任何构造函数，但是包含一个对象类型的成员变量，且该变量有一个显式的默认构造函数；
    - 如果该类没有任何构造函数，但是其父类含有显式的默认构造函数；
    - 如果该类没有任何构造函数，但是含有（或父类含有）虚函数；
    - 如果该类没有任何构造函数，但是带有一个虚基类；











**什么是拷贝构造函数**

首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：

int a=100; int b=a;

而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。

下面看一个类对象拷贝的简单例子。

```cpp
#include<iostream>
using namespace std;
class CExample
{
private:
    int a;
public:
    //构造函数
    CExample(int b)
    {
        a=b;
        printf("constructor is called\n");
    }
    //拷贝构造函数
    CExample(const CExample & c)
    {
        a=c.a;
        printf("copy constructor is called\n");
    }
    //析构函数
    ~CExample()
    {
        cout<<"destructor is called\n";
    }
    void Show()
    {
        cout<<a<<endl;
    }
};
int main()
{
    CExample A(100);
    CExample B=A;
    B.Show(); 
    return 0;
}
```

运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。

CExample(const CExample& C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个**引用变量**。



**拷贝构造函数的调用时机**

**函数的参数为类的对象**

```cpp
#include<iostream>
using namespace std;
class CExample
{
private:
    int a;
public:
    CExample(int b)
    {
        a=b;
        printf("constructor is called\n");
    }
    CExample(const CExample & c)
    {
        a=c.a;
        printf("copy constructor is called\n");
    }
    ~CExample()
    {
     cout<<"destructor is called\n";
    }
    void Show()
    {
     cout<<a<<endl;
    }
};
void g_fun(CExample c)
{
    cout<<"g_func"<<endl;
}
int main()
{
    CExample A(100);
    CExample B=A;
    B.Show(); 
    g_fun(A);
    return 0;
}
```

调用g_fun()时，会产生以下几个重要步骤：

(1).A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。

(2).然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);

(3).等g_fun()执行完后, 析构掉 C 对象。

**函数的返回值是类的对象**

```cpp
#include<iostream>
using namespace std;
class CExample
{
private:
    int a;
public:
    //构造函数
    CExample(int b)
    {
     a=b;
        printf("constructor is called\n");
    }
    //拷贝构造函数
    CExample(const CExample & c)
    {
     a=c.a;
        printf("copy constructor is called\n");
    }
    //析构函数
    ~CExample()
    {
     cout<<"destructor is called\n";
    }
    void Show()
    {
     cout<<a<<endl;
    }
};
CExample g_fun()
{
    CExample temp(0);
    return temp;
}
int main()
{
    
    g_fun();
    return 0;
}
```

当g_Fun()函数执行到return时，会产生以下几个重要步骤：

(1). 先会产生一个临时变量，就叫XXXX吧。

(2). 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);

(3). 在函数执行到最后先析构temp局部变量。

(4). 等g_fun()执行完后再析构掉XXXX对象。



**对象需要通过另外一个对象进行初始化**

```cpp
CExample A(100);
CExample B=A;
```

**浅拷贝与深拷贝**

**默认拷贝构造函数**

很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式：

```cpp
Rect::Rect(const Rect& r)
{
    width=r.width;
    height=r.height;
}
```

当然，以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了，让我们来考虑以下一段代码：

```cpp
#include<iostream>
using namespace std;
class Rect
{
public:
    Rect()
    {
     count++;
    }
    ~Rect()
    {
     count--;
    }
    static int getCount()
    {
     return count;
    }
private:
    int width;
    int height;
    static int count;
};
int Rect::count=0;
int main()
{
    Rect rect1;
    cout<<"The count of Rect:"<<Rect::getCount()<<endl;
    Rect rect2(rect1);
    cout<<"The count of Rect:"<<Rect::getCount()<<endl;
    return 0;
}
```

这段代码对前面的类，加入了一个静态成员，目的是进行计数。在主函数中，首先创建对象rect1，输出此时的对象个数，然后使用rect1复制出对象rect2，再输出此时的对象个数，按照理解，此时应该有两个对象存在，但实际程序运行时，输出的都是1，反应出只有1个对象。此外，在销毁对象时，由于会调用销毁两个对象，类的析构函数会调用两次，此时的计数器将变为负数。

说白了，就是拷贝构造函数没有处理静态数据成员。

出现这些问题最根本就在于在复制对象时，计数器没有递增，我们重新编写拷贝构造函数，如下：

```cpp
#include<iostream>
using namespace std;
class Rect
{
public:
    Rect()
    {
        count++;
    }
    Rect(const Rect& r)
    {
        width=r.width;
        height=r.height;
        count++;
    }
    ~Rect()
    {
        count--;
    }
    static int getCount()
    {
        return count;
    }
private:
    int width;
    int height;
    static int count;
};
int Rect::count=0;
int main()
{
    Rect rect1;
    cout<<"The count of Rect:"<<Rect::getCount()<<endl;
    Rect rect2(rect1);
    cout<<"The count of Rect:"<<Rect::getCount()<<endl;
    return 0;
}
```

**浅拷贝**

所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了，让我们考虑如下一段代码

```cpp
#include<iostream>
#include<assert.h>
using namespace std;
class Rect
{
public:
    Rect()
    {
     p=new int(100);
    }
   
    ~Rect()
    {
     assert(p!=NULL);
        delete p;
    }
private:
    int width;
    int height;
    int *p;
};
int main()
{
    Rect rect1;
    Rect rect2(rect1);
    return 0;
}
```


在这段代码运行结束之前，会出现一个运行错误。原因就在于在进行对象复制时，对于动态分配的内容没有进行正确的操作。我们来分析一下：

在运行定义rect1对象后，由于在构造函数中有一个动态分配的语句，因此执行后的内存情况大致如下：

![img](https://pic4.zhimg.com/80/v2-506ec7d6525af433a0deda83f07b2503_1440w.webp)

在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间，如下图所示：

![img](https://pic2.zhimg.com/80/v2-44381a7a52bbbf85f3bf7747df2b5f4d_1440w.webp)

当然，这不是我们所期望的结果，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。

**深拷贝**

在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间，如上面的例子就应该按照如下的方式进行处理：

```cpp
#include<iostream>
#include<assert.h>
using namespace std;
class Rect
{
public:
    Rect()
    {
     p=new int(100);
    }
    
    Rect(const Rect& r)
    {
     width=r.width;
        height=r.height;
     p=new int(100);
        *p=*(r.p);
    }
     
    ~Rect()
    {
     assert(p!=NULL);
        delete p;
    }
private:
    int width;
    int height;
    int *p;
};
int main()
{
    Rect rect1;
    Rect rect2(rect1);
    return 0;
}
```

此时，在完成对象的复制后，内存的一个大致情况如下：

![img](https://pic1.zhimg.com/80/v2-37fc850aabfcd0f3bad2863424bef2f4_1440w.webp)

此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。

**防止默认拷贝发生**

通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——**声明一个私有拷贝构造函数**。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。

```cpp
//防止按值传递
class CExample 
{ 
private: 
    int a; 
  
public: 
    //构造函数
    CExample(int b) 
    { 
        a = b; 
        cout<<"creat: "<<a<<endl; 
    } 
  
private: 
    //拷贝构造函数，只是声明
    CExample(const CExample& C); 
  
public: 
    ~CExample() 
    { 
        cout<< "delete: "<<a<<endl; 
    } 
  
    void Show () 
    { 
        cout<<a<<endl; 
    } 
}; 
  
//???? 
void g_Fun(CExample C) 
{ 
    cout<<"test"<<endl; 
} 
  
int main() 
{ 
    CExample test(1); 
    //g_Fun(test);   //按值传递将出错
      
    return 0; 
}
```

小结

拷贝有两种：深拷贝，浅拷贝。

当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但**当数据成员中有指针时**，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。

深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。**简而言之，当数据成员中有指针时，必须要用深拷贝**。



拷贝构造函数的几个细节

为什么拷贝构造函数必须是引用传递，不能是值传递？

简单的回答是为了防止递归引用。

具体一些可以这么讲：当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。

参数传递过程到底发生了什么？

将地址传递和值传递统一起来，归根结底还是传递的是"值"(地址也是值，只不过通过它可以找到另一个值)！

i)值传递:

对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；

对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用

ii)引用传递:

无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).

在类中有指针数据成员时，拷贝构造函数的使用？

如果不显式声明拷贝构造函数的时候，编译器也会生成一个默认的拷贝构造函数，而且在一般的情况下运行的也很好。但是在遇到类有指针数据成员时就出现问题 了：因为默认的拷贝构造函数是按成员拷贝构造，这导致了两个不同的指针(如ptr1=ptr2)指向了相同的内存。当一个实例销毁时，调用析构函数 free(ptr1)释放了这段内存，那么剩下的一个实例的指针ptr2就无效了，在被销毁的时候free(ptr2)就会出现错误了, 这相当于重复释放一块内存两次。这种情况必须显式声明并实现自己的拷贝构造函数，来为新的实例的指针分配新的内存。



移动构造函数

有时候我们会遇到这样一种情况，我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。

下面这个图，很好地说明了拷贝构造函数和移动构造函数的区别。

![img](https://pic4.zhimg.com/80/v2-6cde8e70de081bfd1dd08326f726c82f_1440w.webp)

拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。

但是上面提到，指针的浅层复制是非常危险的呀。没错，确实很危险，而且通过上面的例子，我们也可以看出，浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针**（比如a->value）置为NULL**，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间（同时也是b->value指向的空间），下面是一个简单的移动构造函数代码

```cpp
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <vector>

using namespace std;

class Str{
    public:
    char *value;
    Str(char s[])
    {
        cout<<"调用构造函数..."<<endl;
        int len = strlen(s);
        value = new char[len + 1];
        memset(value,0,len + 1);
        strcpy(value,s);
    }
    Str(Str &v)
    {
        cout<<"调用拷贝构造函数..."<<endl;
        this->value = v.value;
        v.value = NULL;
    }
    // 移动构造函数中，语法格式是classname(classname && T)，因此在最后的Str的移动构造函数中应该是Str(Str &&v)。如果你使用了Str(Str &v)，那么还是拷贝构造，没有将旧对象的堆内存直接分配给新对象。
    ~Str()
    {
        cout<<"调用析构函数..."<<endl;
        if(value != NULL)
            delete[] value;
    }
};

int main()
{

    char s[] = "I love BIT";
    Str *a = new Str(s);
    Str *b = new Str(*a);
    delete a;
    cout<<"b对象中的字符串为："<<b->value<<endl;
    delete b;
    return 0;
}
```

移动构造函数中采用了浅层复制，但是结果仍能够达到我们想要的效果，关键在于在拷贝构造函数中，最后我们将**v.value置为了NULL**，这样在析构a的时候，就不会回收a->value指向的内存空间。







#### 构造和析构函数抛出异常、禁止拷贝构造函数、类不实例化

- **构造函数可以抛出异常**

  但**尽量不要抛出异常**，因为会可能**导致内存泄漏**。解决办法：用智能指针来管理内存就可以

  对象只有在构造函数执行完成之后才算构造妥当，c++只会析构已经完成的对象。**因此如果构造函数中发生异常，控制权就需要转移出构造函数，执行异常处理函数**。在这个过程中系统会认为对象没有构造成功，导致不会调用析构函数。

  **在构造函数中抛出异常会导致当前函数执行流程终止，在构造函数流程前构造的成员对象会被释放，但是如果在构造函数中申请了内存操作，则会造成内存泄漏。**另外，如果有继承关系，派生类中的构造函数抛出异常，那么基类的构造函数和析构函数可以照常执行的。

  

- **析构函数不可以抛出异常**

  1. 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
  2. 异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding）。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。
  
  

  **解决办法：**

  把**异常完全封装在析构函数内部**，决不让异常抛出函数之外，代码如下：
  
  ```c++
  DBConn::~DBconn()
  {
      try
      {
  	    db.close(); 
      }
      catch(...)
      {
          abort();
      }
  }
  //如果close抛出异常就结束程序，通常调用abort完成：
  ```



**禁止构造函数使用方法：**

- 为类的**构造函数**增加 `= delete` 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。
- 如果仅仅将**构造函数设置为私有**，**类内部的成员和友元还可以访问**，无法完全禁止。而在 C++11 以后，在成员函数声明后加 "= delete"则可以禁止该函数的使用，而**需要保留的加 "= default"**。

**如何避免拷贝（拷贝构造函数）**

- 将类的拷贝构造函数和赋值运算符重载声明为私有 private，但对于**类的成员函数和友元函数依然可以调用**，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。
- **声明一个基类**，具体做法如下：
  - 定义一个基类，将其中的**拷贝构造函数和赋值运算符重载声明为私有 private**。
  - **派生类以私有 private 的方式继承基类**。
- **拷贝构造函数 `=delete` 修饰**:`C++ 11` 支持 `delete` 直接禁用类的成员函数调用。



**类不实例化：**

- 在类中定义一个**纯虚函数，使该类成为抽象基类**，因为不能创建抽象基类的实例化对象；
- 将类的**所有构造函数**声明为私有 `private`；
- `C++ 11` 以后，将类的所有构造函数用 **`=delete` 修饰**；





#### 拷贝构造函数，移动构造函数的区别、深拷贝和浅拷贝

**区别：**

- **拷贝构造函数**是先将**传入的参数对象**进行一次深拷贝，再传给新对象。这就会**有一次拷贝对象的开销**，并且进行了深拷贝，就需要**给对象分配地址空间**。而**移动构造函数**就是为了**解决这个拷贝开销而产生**的。移动构造函数首先将传递**参数的内存地址空间接管**，然后将内部所有指针设置为nullptr，并且**在原地址上进行新对象的构**造，最后调用原对象的的析构函数，这样做**既不会产生额外的拷贝开销，也不会给新对象分配内存空间**。
- 对于指针参数来讲，**移动构造函数**是对传递参数进行一次浅拷贝。也就是说如果参数为指针变量，进行拷贝之后将会有两个指针指向同一地址空间，这个时候如果前一个指针对象进行了析构，则后一个指针将会变成野指针，从而引发错误。所以**当变量是指针的时候，要将指针置为空，这样在调用析构函数的时候会进行判断指针是否为空**，如果为空则不回收指针的地址空间，这样就不会释放掉前一个指针。
- **当类中同时包含拷贝构造函数和移动构造函数时**，如果使用**临时对象**初始化当前类的对象，编译器会**优先调用移动构造函数来完成此操作**。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户**利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数**。

1. **拷贝构造函数：** 

   拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，一个参数是本类型的一个**引用变量**。用于创建一个对象，该对象是另一个已存在对象的精确副本。它通常以引用参数接受另一个相同类型的对象，并生成一个新对象，其中包含与原始对象相同的数据。拷贝构造函数通常用于以下情况：

   - 当一个对象被传递给函数，而该函数需要创建一个该对象的本地副本。
   - 当对象通过值传递给函数参数或从一个对象初始化另一个对象时。
   - 当使用对象初始化列表进行对象的复制或初始化。

   拷贝构造函数的一般形式如下：

   ```C++
   ClassName(const ClassName &other);
   ```

2. **移动构造函数：** 

   移动构造函数用于将资源从一个对象转移到另一个对象，而不进行深层的数据复制。它通常以右值引用参数接受另一个相同类型的对象，并将其资源移动到新对象中，然后将原对象置于有效但未定义的状态。移动构造函数可以避免不必要的数据复制。

   移动构造函数的一般形式如下：

   ```c++
   ClassName(ClassName &&other);
   ```

总之，拷贝构造函数用于创建对象的副本，而移动构造函数用于将资源从一个对象转移到另一个对象



**深拷贝和浅拷贝的区别：**

- 如果一个**类拥有资源，该类的对象进行复制**时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。
  - 深拷贝：该**对象和原对象**占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。
  - 浅拷贝：该对象和原对象占用同一块内存空间，仅**拷贝类中位于栈空间**中的内容。
- 当类的成员变量中有**指针变量**时，最好使用**深拷贝**。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存
- 编译器生成的**默认拷贝函数**均大部分都是浅拷贝，所有在特定场景下需要禁止编译器生成默认拷贝构造函数。在遇到需要使用堆内存的构造函数中，我们需要特别注意浅拷贝和深拷贝的使用方式，**防止两个不同的对象指向同一块内存区域**



深拷贝与浅拷贝的区别就在于深拷贝会在**堆内存**中另外申请空间来储存数据，从而也就解决了**指针悬挂**的问题。简而言之，当数据成员中**有指针时，必须要用深拷贝**。

**浅拷贝：**

当数据成员中没有指针时，浅拷贝是可行的；

**但当数据成员中有指针时，会出问题。如果没有自定义拷贝构造函数，会调用默认拷贝构造函数，这样就会调用两次析构函数。**第一次析构函数delete了内存，第二次的就指针悬挂了。所以，此时，必须采用深拷贝。

- 浅拷贝只是拷贝一个指针，并没有新开辟一个空间，**拷贝的指针和原来的指针指向同一块地址**。
- 如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针资源就会出现错误。
- 如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应的改变。
- **默认的拷贝构造函数和默认的赋值运算符重载函数**都是浅拷贝。

**深拷贝：**

- 深拷贝不仅拷贝值，还**开辟一块新的空间来存放新的值**，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值时，如果有**指针变量的话是需要自己实现深拷贝**的。







1. **直接初始化 **: 使用小括号来直接初始化一个对象。

   ```c++
   int a(10);
   std::string str("Hello");
   ```

2. **拷贝初始化**: 使用等号初始化一个新的对象，调用拷贝构造函数

   ```c++
   int b = a; 
   std::string str2 = str;
   ```

3. **赋值初始化**: 这不是在对象的创建时的初始化方式，而是在对象已经创建之后，不是初始化，给它赋值的操作

   ```c++
   cppCopy codeint c;
   c = 20; // 这是赋值，不是初始化
   ```









#### 拷贝构造函数为什么有const+引用、何时调用拷贝构造

对于 class A，它的拷贝构造函数如下： A::A(const A &a){}

**1、为什么是 const **
拷贝构造函数的目的是用**其它对象的数据来初始化当前对象**，并没有**期望更改其它对象的数据**，添加 const 限制后，这个含义更加明确了。
另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果**形参没有 const 限制，就不能将 const 对象传递给形参**，因为 const 类型不能直接转换为非 const 类型，这就意味着，**不能使用 const 对象来初始化当前对象了。**

  **类const常成员函数**

1. 类的成员函数后面加 const，表明这个函数不能对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。
2. 有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。
3. 常量（即 const）对象可以调用 const 成员函数，而不能调用非 const 修饰的函数。



**2、为什么必须是当前类的引用**
**循环调用**。如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将**另外一个对象直接传递给形参**，这本身就是**一次拷贝**，**会再次调用拷贝构造函数**，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。
只有**当参数是当前类的引用时**，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。

======

**拷贝构造函数声明为引用：**

**为了防止递归调用。**如果不用引用，就会是值传递的方式，但是值传递会调用拷贝构造函数生成临时对象，从而又调用一次拷贝构造函数。就这样无穷的递归下去。

**如果是指针类型**

就变成了一个带参数的构造函数了。。。

比如`A(A* test)`

- 避免**拷贝构造函数无限制的递归**而导致**栈溢出**。
- 1、ex2 = ex1; 和 A ex3 = ex1; 为什么调用的函数不一样？
  - 对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值运算符的重载；但是 **ex3 还没有实例化，因此调用的是拷贝构造函数**，构造出 ex3，而不是赋值函数，这里涉及到**构造函数的隐式调用**。
- 2、如果拷贝构造函数中形参不是引用类型，A ex3 = ex1; 会出现什么问题？
  - **构造 ex3，实质上是 ex3.A(ex1)**;，假如拷贝构造函数参数不是引用类型，那么将使得 ex3.A(ex1); 相当于 ex1 作为函数 A(const A tmp) 的实参，在参数传递时相当于 A tmp = ex1，因为 **tmp 没有被初始化**，所以在 **A tmp = ex1 中继续调用拷贝构造函数，接下来的是构造 tmp，也就是 tmp.A(ex1)** ，必然又会有 ex1 作为函数 A(const A tmp)的实参，在参数传递时相当于即 A tmp = ex1，那么又会触发拷贝构造函数，就这下永远的递归下去
- 3、为什么 ex2.fun(ex1); 会调用拷贝构造函数？
  - ex1 作为参数传递给 fun 函数， **即 A tmp = ex1;**，这个过程会调用拷贝构造函数进行初始化



**何时调用拷贝构造函数、何时调用复制构造函数：**

- **直接初始化和拷贝初始化**时
- 将**一个对象作为实参**传递给一个非引用或非指针类型的形参时
- 从一个**返回类型为非引用或非指针的函数**返回一个对象时
- 用花括号列表初始化一个数组的元素或者一个聚合类（很少使用）中的成员时。

**何时调用复制构造函数**：

新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用











#### 减少构造函数开销、构造析构为inline函数

**减少构造函数开销：**

- 在构造函数时尽量使用**类初始化列表**，会减少调用默认的构造函数产生的开销

**构造和析构函数为inline函数：**

构造函数、析构函数、虚函数可以声明为内联函数，这在语法上是正确的。
编译器并不真正对**声明为inline的构造和析构函数内联**，因为编译器会在**构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象，调用基类成员对象构造函数等**），致使构造函数/析构函数并不像看上去的那么精简。



#### 构造函数的调用顺序&析构函数、调用时机

1. 调用所有**虚基类的构造函数**，顺序为从左到右，从最深到最浅

2. **基类的构造函数**：如果有多个基类，则构造函数的调用顺序是**该基类在派生类中出现的顺序，而不是他们在成员初始化列表中的顺序**。

3. 如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚表(vtbl)。

4. **成员类对象的构造函数**：如果有**多个成员类构造函数调用顺序是对象在类中被声明的顺序**，而不是他们在成员初始化列表中的顺序

5. **派生类的构造函数**。

6. **析构函数与之相反**。

   析构函数调用的次序时**先派生类，成员类对象，后基类**的。和**构造函数的执行顺序相反。并且析构函数要是virtual的**，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。



**构造函数和析构函数的调用时机**

- **全局范围中的对象**

  构造函数在所有函数调用之前执行，在主函数 `main()` 执行完调用析构函数。

- **局部自动对象**

  建立对象时调用构造函数，离开作用域时调用析构函数。

- new**动态分配的对象**

  建立对象 `new` 时调用构造函数，调用释放 `delete` 时调用析构函数。

- **静态局部变量对象**

  建立时调用一次构造函数，**主函数结束时**调用析构函数。



#### 实例化类对象的过程、**类成员变量的初始化顺序**

- **分配空间：**创建类对象首先要为该**对象分配内存空间**。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。
- **初始化：**初始化不同于赋值。初始化发生在赋值之前，**初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值**。**初始化列表先于构造函数体内的代码执行**，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。
- **赋值：**对**象初始化完成后，可以对其进行赋值**。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。
  - 构造函数实现了**对象的初始化和赋值**两个过程，对象的**初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数**的函数体来实现。
  - 对于**拥有虚函数的类的对象**，还需要**给虚表指针赋值**。
  - 没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。
  - 有继承关系的类，分配内存之后，首先进行**基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体**，即上述中的初始化和赋值操作。



**类成员变量的初始化顺序问题**

1. 成员变量在使用**初始化列表初始化**时，只与**定义成员变量的顺序**有关，与构造函数中初始化成员列表的顺序无关。因为成员变量的初始化次序是根据**变量在内存中次序**有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。
2. 如果**不使用初始化列表初始化**，在**构造函数内初始化**时，此时与**成员变量在构造函数中的位置**有关。
3. **类成员在定义时**，是不能初始化的
4. 类中**const成员常量**必须在**构造函数初始化列表中**初始化。
5. 类中**static成员变量，必须在类外初始化**。

**变量的初始化顺序：**

1. 初始化**基类中的静态成员变量和静态代码块**，按照在程序中出现的顺序初始化；
2. 初始化**派生类中的静态成员变量和静态代码**块，按照在程序中出现的顺序初始化；
3. 初始化**基类的普通成员变量**和代码块，再执行父类的构造方法；
4. 初始化**派生的普通成员变量**和代码块，在执行子类的构造方法；

```c++
class A
{
private:
    int n1;
    int n2;
public:
    A():n2(0),n1(n2+2){}
    void Print(){
        cout << "n1:" << n1 << ", n2: " << n2 <<endl;
    }
};
int main()
{
    A a;
    a.Print();
    return 1;
}
//输出：n1: 是一个随机数；n2: 0
//有的编译器是n1:2, n2=0
```





**类对象的初始化、构造函数顺序**

- **类对象的初始化顺序：**
  - 按照**构造函数的调用顺序**，调用基类的构造函数
  - 按照**成员变量的声明顺序**，调用成员变量的构造函数函数，成员变量的**初始化顺序与声明顺序**有关；
  - 调用**该类自身的构造函数**；
  - 析构顺序和类对象的初始化顺序相反

- **类的成员初始化:**
  - 类中可能含有静态变量和全局变量，由于静态变量和全局变量都被放在静态存储区，他们的**初始化在 main 函数执行之前已被初始化，且 static 变量必须在类外进行初始化**。
  - 成员变量在使用**初始化列表初始化**时，与构造函数中初始化成员列表的顺序无关，**只与定义成员变量的顺序有关。**因为成员变量的初始化次序是根据**变量在内存中次序**有关，而内存中的排列顺序早在**编译期**就根据变量的定义次序决定了。
  - 如果类不使用初始化列表初始化，而**在类的构造函数内部进行初始化时，此时成员变量的初始化顺序与构造函数中代码逻辑有关**。
  - 类**成员在定义时，是不能初始化的**
- **构造函数调用顺序：**
  - 按照**派生类继承基类的顺序**，即派生列表中声明的继承顺序，依次调用基类的构造函数；
  - 在有虚继承和一般继承存在的情况下，**优先虚继承**。比如虚继承：class C: public B, virtual public A，此时应当先调用 A 的构造函数，再调用 B 的构造函数。
  - 按照派生类中**成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数**；
  - 执行派生类自身的构造函数。
- 类中 **const 成员常量必须在构造函数初始化列表中初始化**。
- 类中 **static 成员变量，必须在类外初始化**

**派生类对象执行顺序：**

**类的构造函数不能被继承，构造函数不能被继承是有道理的**，因为即使继承了，它的名字和派生类的名字也不一样（构造函数名字和类名一样），不能成为派生类的构造函数，当然更不能成为普通的成员函数。在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有private属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。这种矛盾在C++继承中是普遍存在的，解决这个问题的思路是：**在派生类的构造函数中调用基类的构造函数**。

对象创建时候执行顺序是：**静态代码 --> 非静态代码 --> 构造函数。**静态代码包括（静态方法，静态变量，静态代码块等），非静态代码即（成员方法，成员变量，成员代码块等）。代码块中或者成员变量中如果有类对象的话，肯定要先将类对象创建出来。所以说先执行代码块再执行构造函数，而且如果代码块中有多个成员变量，则按照成员变量的声明顺序进行构造。初始化列表的顺序, 不影响成员变量构造顺序

静态变量在内存中属于全局变量，所以要先创建。然后类会查看成员函数的相关信息，为该类的对象中的每个成员变量分配相应的存储空间，然后再执行构造函数创建对象，如果构造函数有初始化，则将值放到准备好的内存空间中。





#### 拷贝构造和赋值运算符重载的区别

1. 拷贝构造函数是函数，赋值运算符是运算符重载。

2. 拷贝构造函数会生成新的类对象，赋值运算符不能。

3. 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。

4. 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符。

**注：类中有指针成员变量时要重写析构函数、拷贝构造函数和赋值运算符**

- **例子：**拷贝构造函数用于构造新的对象；

  ```cpp
  Student s;
  Student s1 = s; // 隐式调用拷贝构造函数
  Student s2(s);  // 显式调用拷贝构造函数
  ```

- 赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含**未释放的内存需要先将其释放**；

  ```cpp
  Student s;
  Student s1;
  s1 = s; // 使用赋值运算符
  ```

  一般情况下，类**中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数**。





#### 拷贝初始化，直接初始化的区别、拷贝赋值和移动赋值的区别

**拷贝初始化=复制初始化、复制构造函数=拷贝构造函数**  ClassType(const ClassType& other);

要点就是**拷贝初始化和直接初始化调用的构造函数**是不一样的，但是当**类进行复制时，类会自动生成一个临时的对象**，然后再进行拷贝初始化。

1. **直接初始化**：

   ```c++
   ClassTest ct1("ab");
   ```

   - 调用方式：直接使用小括号。
   - 结果：直接调用 `ClassTest(const char *pc)` 构造函数来创建 `ct1`。
   - 当复制构造函数为私有时：无影响，该语句仍然可以正常工作。

2. **复制初始化（从临时对象）**：

   ```c++
   ClassTest ct2 = "ab";
   ```

   - 调用方式：使用等号。
   - 结果：首先调用 `ClassTest(const char *pc)` 构造函数创建一个临时对象。然后**调用复制构造函数**，使用该临时对象作为参数来创建 `ct2`。
   - 当复制构造函数为私有时：该语句会导致编译错误，因为它需要复制构造函数。

3. **复制初始化（从已存在的对象）**：

   ```c++
   ClassTest ct3 = ct1;
   ```

   - 调用方式：使用等号。
   - 结果：直接调用复制构造函数，使用 `ct1` 作为参数来创建 `ct3`。
   - 当复制构造函数为私有时：该语句会导致编译错误。

4. **直接初始化（从已存在的对象）**：

   ```c++
   ClassTest ct4(ct1);
   ```

   - 调用方式：直接使用小括号。
   - 结果：直接调用复制构造函数，使用 `ct1` 作为参数来创建 `ct4`。
   - 当复制构造函数为私有时：该语句会导致编译错误。



**拷贝赋值和移动赋值的区别：**

1. 拷贝赋值调用的拷贝构造函数，移动赋值调用的是移动构造函数
2. **拷贝构造函数的形参**是一个**左值引用**，而移动构造函数的形参是一个右值引用
3. 拷贝构造函数完成的是整个对象或变量的深拷贝，而移动构造函数只是简单地把**右值引用的资源浅拷贝给需要建立的对象**，然后将右值引用对象的资源赋空。



#### 什么库用到了移动构造函数

C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，**移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。**

移动操作的发生的时候，是当移动值的对象是**未命名的对象**的时候。这里**未命名的对象就是那些临时变量**，甚至都不会有名称。典型的**未命名对象**就是**函数的返回值或者类型转换的对象**。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。

做到这些，就要**使用移动构造函数和移动赋值**：当使用一个**临时变量对对象进行构造初始化**的时候，调用**移动构造函数**。类似的，使用**未命名的变量的值赋给一个对象时，调用移动赋值操作**。





### 虚继承

#### 虚继承底层实现原理、菱形继承和虚继承

**虚继承底层实现原理：**

- 虚继承用于解决多继承条件下的菱形继承问题，底层实现原理与编译器相关，**一般通过虚基类指针实现，也就是各对象中只保存一份父类的对象**，多继承时通过**虚基类指针引用该公共对象**，从而避免菱形继承中的**二义性问题**

**菱形继承和虚继承：**

一个类（我们称之为 "基类"）被两个子类所继承，而这两个子类又被同一个类（我们称之为 "最底部的子类"）所继承。如果你把这四个类的关系画出来，形状看起来就像一个菱形，因此得名 "菱形继承"。

菱形继承会导致一个问题，那就是最底部的子类（在这个例子中是`Platypus`类）会包含多份基类（在这个例子中是`Animal`类）的实例。这可能会引发混淆，例如，如果`Animal`类有一个数据成员，那么`Platypus`对象将会有两个相同的数据成员。解决方案就是把中间的类虚拟继承，这样通过虚继承，`Dog`类和`Bird`类可以共享同一个`Animal`基类的实例，从而解决了上述的问题





#### **为何要虚继承**、类不被继承final、与普通继承的区别

**为何要虚继承：**

**1、解决多继承时的命名冲突和冗余数据问题（尤其是菱形继承）**

虚继承在**派生类中只保留一份间接基类**的成员。其中多继承（Multiple Inheritance）是指从**多个直接基类中产生派生类**的能力，多继承的派生类继承了所有父类的成员。

**2、虚继承的目的是让某个类做出声明，承诺愿意共享它的基类**

其中，这个被共享的基类就称为虚基类（Virtual Base Class）。在这种机制下，不论虚基类在继承体系中出现了多少次，**在派生类中都只包含一份虚基类的成员**。



**类不被继承：**

​    使用友元、虚继承和私有构造函数来实现

1. 将**构造函数声明为私有**，这样派生类无法调用基类的构造函数进行构造
2. 将自身作为一个已存在类的友元类，利用了**友元不能被继承的特性**。虚基类构造函数的参数必须由最新派生出来的类负责初始化（即使不是直接继承）
3. c++11中可以使用关键字 **final**，使用 `final` 关键字修饰的类不能被继承



```c++
template <typename T>
class Base{
    friend T;
private:
    Base(){
        cout << "base" << endl;
    }
    ~Base(){}
};

class B:virtual public Base<B>{   //一定注意 必须是虚继承
public:
    B(){
        cout << "B" << endl;
    }
};

class C:public B{
public:
    C(){}     // error: 'Base<T>::Base() [with T = B]' is private within this context
};
```

- 虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；
- B 类继承 Base 类采用**虚继承的方式**，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。
- 注意：在继承体系中，**友元关系不能被继承**，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。



**虚继承和普通继承会有什么区别**

在虚继承中，**虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。**

这跟**普通继承**不同，在**普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的**。



由于有了间接性和共享性两个特征，所以决定了虚继承体系下的对象在访问时必然会在时间和空间上与一般情况有较大不同。

**时间：**在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种**间接引用**来完成，这样会**增加引用寻址时间**（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。

**空间：**由**于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。**也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个指向基类子对象的指针。

比如 在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。





#### 多重继承常见问题及避免方法

- 多重继承（多继承）：是指从**多个直接基类中产生派生类**。多重继承容易出现**命名冲突和数据冗余**问题。

- 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对**成员访问的不确定性，即同名二义性**；

  **消除同名二义性的方法：**

  - 利用作用域运算符`::`，用于限定派生类使用的是哪个基类的成员；
  - 在派生类中定义同名成员，覆盖基类中的相关成员；

  

- 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即**路径二义性**；

  **消除路径二义性的方法：**

- 消除同名二义性的两种方法都可以；

- 使用**虚继承**，使得不同路径继承来的同名成员在内存中只有一份拷贝。

- 由于使用多重继承很容易出现二义性的问题，将使得程序调试和维护工作变得非常复杂，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承



#### 构造、析构函数不能被继承

**1、构造函数不能被继承**

第一个原因：

**在创建派生类对象时必须调用派生类的构造函数。派生类构造函数通常使用成员列表初始化来调用基类构造函数以创建派生类中的基类部分。**如果派生类没有使用成员列表初始化语法，则将使用默认的基类构造函数，如果基类没有默认的构造函数就会报错。

第二个原因：

**因为即使继承了，它的名字和派生类的名字也不一样**（构造函数名字和类名一样），不能成为派生类的构造函数，当然更不能成为普通的成员函数。在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是**大部分基类都有private属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化**。这种矛盾在C++继承中是普遍存在的。

解决这个问题的思路是：**在派生类的构造函数中调用基类的构造函数**。

**2、析构函数不能被继承**

释放对象的时候需要**先调用派生类析构函数然后调用基类析构函数**。

**3、赋值运算符=**

不应该说不能被继承，而是被覆盖了。

第一点是在c++的编译器中如果没有定义赋值运算符，会自动加上一个默认的。所以**如果赋值运算符可以被继承，则会导致派生类也会有这个赋值运算符**。

第二就是在如果**派生类的成员和基类的成员有相同的声明，那么派生类会覆盖基类的成员，哪怕参数和数据类型都不相同，也会被覆盖。**显然，B1中的赋值运算符函数名operator =和基类A1中的operator =同名，所以，A1中的赋值运算符函数int perator=(int a);**被B1中的隐含的赋值运算符函数B1& perator =(const B1& robj);所覆盖**。所以**赋值运算符会被覆盖，不能被继承，那么派生类就不能使用基类中的赋值运算符做一些事情，就像图上说的特征标随类而异**。举个例子就是基类A中赋值运算符参数是int，但是派生类赋值运算符参数是类类型，导致编译出错。





public、private、protected继承特点

c++默认是什么继承？

c++类中默认是私有继承

c++结构体中默认是public继承。



**c++11的final关键字**

**将自身的构造函数与析构函数放在private作用域内**

**友元+虚继承**

解释一下这个，首先要明白什么是友元和虚继承。

友元：友元的本质就是想**在类外不通过成员函数访问类的私有成员**，分为友元函数和友元类。友元函数内部可以直接访问私有成员。一个类A可以将另一个类B声明为自己的友元，类B的所有成员函数就都可以访问类 A 对象的私有成员。

虚继承：**虚拟继承是多重继承中**特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在**类D中两次出现类A中的变量和函数**。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而**A就成了虚拟基类**。虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。

```c++
class CFinalClassMixin {//从这个类中继承的类都不能再被继承
  friend class Cparent;
private:
  CFinalClassMixin() {}
  ~CFinalClassMixin(){}
};
class Cparent: virtual public CFinalClassMixin, public CXXX {
public:
  Cparent() {}
  ~Cparent(){}
};
class CChild : public Cparent {
public:
  CChild() {};//编译错误
  ~CChild() {};//编译错误
};
```

如果不是虚继承，那么CChild直接调用Cparent的构造函数，这是成立的，而且CChild是不需要调用CFinalClassMixin的构造函数。**若把它声明为虚继承（派生类对象一定会调用基类的构造函数），那么CChild就必须负责CFinalClassMixin构造函数的调用，这样又因为不能继承friend类，所以不能调用，造成了错误。**



#### 友元函数的作用及使用场景

- **作用：**

  友元（friend）提供了**不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享**的机制。通过友元，一个普通的函数或另一个类中的成员函数可以访问类中的**私有成员和保护成员**。

- **使用场景**：

  - 普通函数定义为类的友元函数，使得普通函数能够**访问该类的私有成员和保护成员**。
  - 友元类：由于类的 private 和 protected 成员变量只能由类的成员**函数访问或者派生类访问**，友元类则提供提供一种通用的方法，使得不同类之间可以访问其 private 和 protected 成员变量，**用于不同类之间共享数据。**

**friend友元类和友元函数**

[看这里](https://blog.csdn.net/adriano119/article/details/5914443?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)

采**用类的机制后**实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。有时需要定义一些函数，这些**函数不是类的一部分，但又需要频繁地访问类的数据成员**，这时可以将这些函数定义为该函数的友元函数。如果不用友元你可以使用成员函数来set这些数据成员。

除了友元函数外，还有友元类，两者统称为友元。

**友元函数**能够使**得普通函数直接访问类的保护数据和私有数据成员**，避免了**类成员函数的频繁调用，**可以节约处理器开销，提高程序的效率，但所矛盾的是，即使是最大限度大保护，同样也破坏了类的封装特性，这即是友元的缺点，在现在cpu速度越来越快的今天我们并不推荐使用它。

**友元类**友元类的所有成员函数都是**另一个类的友元函数**，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。    

友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得**非成员函数可以访问类的私有成员。**

> 我碰到了一种必须使用友元的情况。如下图
>
> <img src="https://s2.loli.net/2022/08/16/7vWarITSkPYHOdK.png" alt="image-20220816221227150" style="zoom:50%;float:left" />
>
> 上述代码由于使用了priority_queue，而且每个成员是一个结构体，所以需要重新定义std::less的比较方式，所以在结构体重重载了`<`号，这个时候重载运算符需要用到友元。因为std::less类中的比较运算符需要调用struct中的，因此需要把结构体中的设置为友元。













###  其他



**对象的存储空间问题**

**为何空类的大小不是0**

为保证两个不同对象的地址不同，**空类也会实例化**，所以编译器会给空类隐含的添加一个字节（在不涉及虚函数时），此时`sizeof`为1，这样空类实例化后就有独一无二的地址了。

当基类中含有虚函数，或者**派生类使用虚继承**时，会含有虚函数表的地址/指向虚基类的指针，此时`sizeof`为4，当然具体情况视继承的数量而定。

- 空类定义时编译器会生成 6 个成员函数：当空类 A 定义对象时，sizeof(A) 仍是为 1，但
- **编译器会在需要时生成 6 个成员函数：**
- **缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符**。

**空类的大小为什么1字节**

因为**任何不同的对象不能拥有相同的内存地址**

为了区分空类的实例化对象，和实现**每个实例在内存中**都有一个独一无二的地址，编译器往往会给**一个空类隐含的加一个字节**，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。



**对象的存储空间由什么决定**

1. **非静态成员的数据类型大小之和**。
2. 编译器加入的**额外成员变量（指向虚函数表的指针）**。
3. 为了**边缘对齐优化加入的padding**。



#### 类的大小（空类、虚表指针）、只在栈堆分配空间

- 类的大小是指**类的实例化对象的大小**，用 sizeof 对类型名操作时，结果是该类型的对象的大小。计算原则如下：
  - 遵循结构体的**成员变量对齐原则**。
  - 与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。
  - **虚函数对类的大小有影响**，是因为**虚函数表指针**的影响；虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。
  - 不包含虚继承的情况，派生类直接继承了基类的成员变量；虚继承的情况就比较复杂，虚继承需要额外加上一个指向虚基类表的指针。虚继承的基础上如果再加上虚函数，还需要**额外加上虚函数表的指针占用的空间**
  - **空类的大小是一个特殊情况，空类的大小为 1**，空类同样可以被实例化，而每个实例在内存中，都有一个独一无二的地址，为了达到这个目的，编译器往往会给**一个空类隐含的加一个字节**，这样空类在实例化后在内存得到了独一无二的地址，所以sizeof(A) 的大小为 1。



**如何让类对象只在栈/堆上分配空间：**

1. **对象只建立在堆上：**

   - 将**析构函数设置为私有**。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。

     该方法存在的问题：用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destroy() 函数，用来释放 new 创建的对象。无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。

   - **构造函数设置为 protected**，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。

2. **对象只建立在栈上：**

   将 operator new() 设置为私有。将 new 和 delete 运算符重载为私有的。

   - 原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够**防止对象建立在堆上**









初始化成员列表必有的情况

- 初始化一个 const 成员。

- 初始化一个 reference 成员。

- 调用一个基类的构造函数，而**该函数有一组参数**。

- 调用一个**数据成员对象的构造函数**，而**该函数有一组参数**。

```c++
class A {
    public:
        A(int &v) : i(v), p(v), j(v) {}
        void print_val() { cout << "hello:" << i << "  " << j << endl;}
    private:
        const int i;   //const成员
        int p;
        int &j;        //引用成员
};
```

#### 成员初始化列表效率高的原因、类模板和模板类的区别

- 用户自定义类型如果使用类初始化列表，**直接调用该成员变量对应的构造函数即完成初始化**；如果在构造函数中初始化，由于 C++ 规定对象的成员变量的初始化动作发生在进入自身的构造函数本体之前，那么在执行构造函数之前**首先调用默认的构造函数为成员变量设初值，在进入函数体之后，再显式调用该成员变量对应的构造函数**。因此**使用列表初始化**会**减少调用默认的构造函数**的过程，效率更高一些。
- 使用成员列表初始化的方式会**省去调用默认的构造函数**的过程。如果自定义的类型没有默认构造函数，此时必须使用初始化列表提供初值对这些类型进行初始化。



**类模板和模板类的区别：**

类模板，template提前修饰，不明确定义其数据成员、成员函数的参数和返回值，这种类是一个模板，可以传入任意符合要求的类型，最后实例化成一个具体的类；模板类就是类模板实例化后的具体类，就好比一个类模板是做糕点的模具，模板类就是做出来的糕点。









类对象静态建立、动态建立

- 静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;

- 动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();

#### RTTI原理、This指针的作用，何时创建，何处

RTTI即**运行时类型识别**，其功能由两个运算符实现：

- `typeid`运算符，用于**返回表达式的类型**，可以通过基类的指针获取派生类的数据类型；
- `dynamic_cast`运算符，具有**类型检查**的功能，用于将基类的指针或引用安全地转换成派生类的指针或引用。

**补充：**

RTTI即运行时类型识别，用于在**程序运行时获取对象的实际类型信息。**它通常用于面向对象的编程语言，如C++。

允许`dynamic_cast`和`typeid`两个关键符在运行时确定对象的实际类型，并进行类型安全的转换和比较。

1. `dynamic_cast`运算符： 它用于将**基类指针或引用转换为派生类指针或引用**。在进行这种转换时，编译器会检查**转换是否合法，**即检查源对象是否真的是目标派生类的实例。如果转换合法，`dynamic_cast`将返回指向**目标派生类的指针或引用**，否则返回空指针（当转换指针时）或抛出`std::bad_cast`异常（当转换引用时）。
2. `typeid`运算符： 它用于返回一个`std::type_info`对象，表示表达式的类型。`std::type_info`是一个类，包含有关类型的信息，包括类型名称。**`typeid`常用于比较两个对象的类型是否相同**。



**This指针的作用：**

**当函数参数与成员变量同名时，可以用 `this` 指针来区分**。**返回对象自身**：在链式调用或者其他需要返回对象自身的情况下，`this`指针可以用来返回当前对象。

**实现动态多态**：`this`指针在C++的动态多态中起到关键作用。由于动态多态是在运行时决定的，所以需要知道调用函数的具体对象是什么，这就需要`this`指针。



如果函数内部想使用成员数据，可以使用**该对象指针**的方式，指向成员变量。

**其作用就是指向非静态成员函数所作用的对象。**

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向**调用该非静态成员函数的那个对象。**
2. 当对一个对象调用成员函数时，编译程序先将**对象的地址**赋给 `this` 指针，然后调用成员函数，**每次成员函数存取数据成员时，都隐式使用 `this` 指针。**
3. `this` 并不是一个常规变量，而是个**右值**，所以**不能取得 `this` 的地址（不能 `&this`）**。



**this指针何时创建**

this在**成员函数的开始执行前构造，在成员的执行结束后清除**。

但是如果class里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，**在栈里分配内存，这时候this指针的值就是这块内存的地址**。采用new的方式创建对象的话，在堆里分配内存，new操作符**通过eax（累加寄存器）返回分配的地址**，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx



**this指针存放在何处**

this指针会因**编译器不同**而有不同的放置位置。可能是**栈，也可能是寄存器，甚至全局变量**。在汇编级别里面，一个值只会以3种形式出现：**立即数、寄存器值和内存变量值**。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。



**知道一个对象this指针的位置，可以直接用吗？**

**this指针只有在成员函数中才有定义。**

因此，你获得一个对象后，也不能通过对象使用this指针。所以，**我们无法知道一个对象的this指针的位置**（只**有在成员函数里才有this指针的位置**）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。



**成员函数调用delete this有什么问题？**

在类对象的内存空间中，只有数据成员和虚函数表指针，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前**是哪个对象在调用它**。

当**调用delete this时，类对象的内存空间被释放**。在delete this之后进行的其他任何函数调用，只要**不涉及到this指针的内容，都能够正常运行**。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。



**类析构函数中调用delete this有什么后果：**

**会导致堆栈溢**出。原因很简单，delete的本质是为将被释放的内存调用一个或多个析构函数，然后，释放内存。显然，**delete this会去调用本对象的析构函数**，而**析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃**。

> inline说明对编译器来说只是一种建议，编译器可以忽略这个建议的，比如，你将一个长达100多行的函数指定为inline，编译器就会自动忽略这个inline，将这个函数还原成普通函数。在调用内联函数时，要保证内联函数的定义让编译器看到，也就是说，内联函数inline必须要定义在头文件中，这与通常的函数定义是不一样的。





**不改类成员变量的函数实现：**

- 如果想达到一个**类的成员函数不能修改类的成员变量**，只需用 const 关键字来修饰该函数即可。
- 同时 C++ 还存在与 const 相反的关键字 mutable。被 mutable 修饰的变量，将永远处于可变的状态，即使在一个 const 函数中。如果我们需要在 const 函数中修改类的某些成员变量，这时就需要用到 mutable。
- 使用 mutable 的注意事项：
  - mutable 只能作用于**类的非静态和非常量数据成员**。
  - 在一个类中，应尽量避免大量使用 mutable，大量使用 mutable 表示程序设计存在缺陷





# C++11=======================

## 智能指针

### 智能指针作用、3个

**作用：**

智能指针是一个**RAII类模型，用于动态分配内存**，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用`delete`删除指针所指向的内存空间。

处理内存泄漏问题和空悬指针问题。

智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数释放资源。所以智能指针的作用原理就是**在函数结束时自动释放内存空间，不需要手动释放内存空间**。



**shared_ptr**

采用**引用计数器**的方法，允许多个智能指针指向同一个对象，但是多个指针指向同一个资源不能被释放多次，因此使用计数机制表明资源被几个指针共享，使用**拷贝构造函数和赋值拷贝构造函数**时，引用计数加1。 **shared_ptr 并不是线程安全的**，但 shared_ptr 的**计数是原子操作**实现的，利用 atmoic CAS 指令实现。从share_ptr 的内存模型可以看出，当**引用计数和 weak count 同时为 0** 时，share_ptr 对象才会被最终释放掉。当对 shared_ptr 赋予新值或者被对象被销毁时，引用计数会递减。但特殊情况出现循环引用时，shared_ptr 无法正常释放资源。

1、shared_ptr的尺寸是原生指针的两倍，内部包含了指向对象的指针和指向控制块的指针

2、控制块所在的内存必须通过动态分配得到。是因为控制块和被指向的对象是相关联的，但是被指向的对象却不知道控制块的地址。即需要两次动态内存分配 ，分别分配对象的空间和控制块的空间。但是后面提到的make_ptr可以避免额外的动态分配的成本。

3、对引用计数的递增和递减必须是原子操作的，当在不同的线程中使用shared_ptr来指向同一对象，可能会同时修改引用计数造成引用计数的错误。

**注意：**

- shared_ptr的实现机制是在拷贝构造时**使用同一份引用计数**
- 将一个计数器与类指向对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建**类的新对象**时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，**赋值操作符减少左操作数所指对象的引用计数**（如果引用计数为减至0，则删除对象），并**增加右操作数所指对象的引用计数**
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

////通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，同时将计数减一，当计数减为 0 时会自动释放内存空间，从而避免了内存泄漏。shared_ptr 是为了解决 **auto_ptr** 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。





**unique_ptr**

**独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值，转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；**

- unique_ptr**不支持普通的拷贝和赋值操作**；如果拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，**造成在结束时对同一内存指针多次释放而导致程序崩溃**。局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；
- 可以通过移动语义move将unique_ptr所持有的**对象**转移到另一个unique_ptr。所以**unique_ptr是一个只移类型**。
- unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直**到离开作用域**。**离开作用域时，若其指向对象，则将其所指对象销毁**(默认使用delete操作符，用户可指定其他操作)。
- unique_ptr指针与其所指对象的关系：**在智能指针生命周期内**，可以改变智能指针所指对象，如**创建智能指针时通过构造函数指定**、通过**reset方法重新指定**、通过**release方法释放所有权**、通过**移动语义转移所有权**
- **当unique_ptr所指向的对象生命期终结时，默认会调用unique_ptr内部的析构函数进行资源释放。当然也可以自定义unique_ptr的析构函数**



**weak_ptr** 

 **weak_ptr 是一种不控制对象生命周期的智能指针**, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

**weak_ptr是用来解决shared_ptr相互引用时的死锁问题**，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，**它可以通过调用lock函数来获得shared_ptr**。

**weak_ptr通常从shared_ptr上创建，这时候两者指向同一对象**，但是weak_ptr不会影响**控制块的引用计数**，而是会影响控制块中**weak count的计数**。











**auto_ptr**

- 实现**独占式拥有**的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在C++11中被摒弃，其主要问题在于：
  - 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；
  - 不能指向数组，也不能作为STL容器的成员。

### unique_ptr如何处理资源管理

1. **独占所有权**：`std::unique_ptr` 是一个独占所有权的智能指针，这意味着在任何时候，只能有一个 `std::unique_ptr` 指向一个给定的对象。当另一个 `unique_ptr` 获得了对象的所有权（例如，通过移动语义），原始的 `unique_ptr` 将失去所有权，并且不再指向该对象。
2. **自动释放**：当 `std::unique_ptr` 被销毁（例如，它离开了其作用域）时，它将自动删除其所管理的对象。对于 `std::unique_ptr<T>`，它默认使用 `delete` 操作符来删除其所管理的对象。
3. **自定义删除器**：`std::unique_ptr` 允许用户提供自定义的删除器。这在管理不是通过 `new` 分配的资源时非常有用，例如文件描述符、`FILE*` 或其他需要特殊处理的资源。
4. **移动语义**：`std::unique_ptr` 不能被复制，但可以被移动。这意味着你可以将一个 `unique_ptr` 的所有权转移给另一个，但不能创建其副本。
5. **重置和释放**：使用 `reset` 成员函数，你可以更改 `unique_ptr` 所管理的对象或释放其所有权。`release` 成员函数允许你释放所有权并返回原始指针，但不删除对象。



### 智能指针有没有内存泄露、循环引用解决、**weak_ptr作用：**

**智能指针有内存泄露的情况：**

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。使引用计数失效，从而导致内存泄漏。 

**解决shared_ptr循环引用导致的内存泄漏：**

shared_ptr改成weak_ptr即可，它是对对象的一种弱引用，weak_ptr的构造函数**不会修改引用计数**的值**，从而**不会对对象的内存进行管理**，其类似一个普通指针，但是**不会指向引用计数的共享内存，**但是**可以检测到所管理的对象是否已经被释放，从而避免非法访问。有可能资源已被释放，但 weak_ptr 仍然存在**，share_ptr 必须等待**所有引用的 weak_ptr 全部被释放才会进行释放。因此每次访问资源时都需要判断资源是否有效。

weak_ptr是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，**shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr**。



**weak_ptr作用：**

**检验某个指针指向的对象是否已经被析构**：**需要一个原子操作来检测weak_ptr是否expire**。**通过weak_ptr创建shared_ptr能够解决这个问题：**

先通过以下方法**创建一个悬空的weak_ptr**：**空悬的weak_ptr也被称作是expired（过期的）**，但是由于weak_ptr缺乏解引用操作，无法直接对weak_ptr进行解引用判断是否为空。即使有这样的解引用操作，对weak_ptr通常是先解引用后检测，在解引用至检测的期间可能有其他线程对其所指空间进行赋值，从而导致未定义的行为。**需要一个原子操作来检测weak_ptr是否expire**。**通过weak_ptr创建shared_ptr能够解决这个问题：**



### 智能指针线程安全

**shared_ptr 本身是线程安全的，但是其指向对象的线程安全，需要由用户自己保证。**

shared_ptr 智能指针的**引用计数**在手段上使用了 atomic 原子操作，**只要 shared_ptr 在拷贝或赋值时增加引用**，析构时减少引用就可以了。首先**原子操作是线程安全的**，所有 shared_ptr 智能指针在多线程下引用计数也是安全的，也就是说 shared_ptr 智能指针在**多线程下传递使用时引用计数是不会有线程安全问题的**。

 但是**指向对象的指针不是线程安全的**，使用 shared_ptr 智能指针**访问资源不是线程安全的**，需要**手动加锁解锁。智能指针的拷贝也不是线程安全的**。

**线程安全问题**

- 同一个`shared_ptr`被多个线程"读"是安全的：

- 同一个`shared_ptr`被多个线程"写"是不安全的：

  因为对一个**`shared_ptr`写操作**分为两步：**更改实际指针指向，然后再修改引用计数**，如果第一步完成后就切换线程了，可能会因为引用计数没增加而导致实际指针被释放。

- **共享引用计数的不同的shared_ptr被多个线程"写“是安全的。**

- **结论：多个线程访问同一个shared_ptr时，应该要进行加锁操作**



### weak指针在shared指针释放后，它的值会变吗

**简而言之：**

1. **`std::weak_ptr`在关联的`std::shared_ptr`释放后不会立即变为`nullptr`，但会变成悬空状态。**
2. **"悬空"的`std::weak_ptr`是不能直接被解引用的。要访问其指向的对象，你首先需要通过`lock()`获得一个`std::shared_ptr`。**
3. **使用`expired()`可以检查一个`std::weak_ptr`是否悬空，如果`expired()`返回`true`，则表示该`std::weak_ptr`已经悬空。**
4. 如果你想从一个非悬空的`std::weak_ptr`获得一个有效的`std::shared_ptr`，可以使用`lock()`成员函数。如果`std::weak_ptr`已经悬空，则通过`lock()`得到的`std::shared_ptr`是无效的。

这样设计的目的是为了避免数据竞争和潜在的未定义行为，同时保证当从`std::weak_ptr`调用`lock()`时，你能得到一个安全有效的`std::shared_ptr`，或者当资源已被释放时得到一个无效的`std::shared_ptr`。



### weak指针悬空后该怎么办、weak_ptr是否失效

**weak指针悬空后该怎么办：**

当`std::weak_ptr`悬空时，应当保证不再尝试访问其关联的已经被销毁的对象，并根据需要更新或重置`std::weak_ptr`。**

1. **`std::weak_ptr`指向某对象，当所有关联的`std::shared_ptr`都被销毁后，该对象也会被销毁，std::weak_ptr`为“悬空”的。
2. **不能**直接解引用一个`std::weak_ptr`，无论其是否悬空。
3. 通过`lock()`方法从一个悬空的`std::weak_ptr`获取`std::shared_ptr`时，会得到一个空的`std::shared_ptr`。
4. 不会因为尝试从悬空的`std::weak_ptr`中获取对象而导致程序崩溃。`std::weak_ptr`的设计就是为了避免这种情况。



**weak_ptr是否失效：**

为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数**不会修改引用计数**的值**，从而**不会对对象的内存进行管理**，其类似一个普通指针，但是**不会指向引用计数的共享内存，**但是**可以检测到所管理的对象是否已经被释放，从而避免非法访问。

**通过expired()函数**：

判断指针所指的内存空间是否被释放掉/指针是否为空/是否还有shared_ptr指针指向weak_ptr指向的内存空间。`std::weak_ptr`的`expired()`函数是用来检查被`weak_ptr`追踪的对象是否已经被释放。

**如果`weak_ptr`追踪的对象已经被销毁（没有任何`std::shared_ptr`指向该对象，引用计数为0），那么`expired()`函数会返回`true`。如果被追踪的对象仍然存在（至少有一个`std::shared_ptr`仍然指向该对象），那么`expired()`函数会返回`false`。**

注意：尽管`expired()`函数可以用来检查`weak_ptr`追踪的对象是否存在，但是它并不能安全地转换`weak_ptr`到`shared_ptr`。这是因为在多线程环境中，可能在调用`expired()`函数之后，`weak_ptr`追踪的对象就被销毁了。因此，如果你想要安全地使用`weak_ptr`追踪的对象，**应该使用`lock()`函数，它会返回一个`shared_ptr`。如果对象仍然存在，这个`shared_ptr`会指向该对象；如果对象已经被销毁，`lock()`函数会返回一个空的`shared_ptr`。**





### lock函数如何工作、为什么能检测weak指针

**`lock()`函数是如何工作的：**

1. **`lock()`首先检查控制块中的`shared_ptr`引用计数。**
2. **如果`shared_ptr`引用计数是0，这意味着所指向的对象已经被销毁。在这种情况下，`lock()`返回一个空的`std::shared_ptr`。**
3. **如果`shared_ptr`引用计数不是0，这意味着对象仍然存在。`lock()`会创建并返回一个新的`std::shared_ptr`，同时增加`shared_ptr`的引用计数。**

因为这些操作需要确保线程安全，所以它们通常是通过原子操作实现的，以确保在多线程环境下的正确性。

总的来说，`lock()`函数通过查看与`std::weak_ptr`相关联的控制块中的`shared_ptr`引用计数来确定对象是否还存在，并据此决定如何行动。



**控制块里有Reference Count和Weak Count**

`std::weak_ptr`和`std::shared_ptr`都与一个控制块（control block）相关联。这个控制块存储了关于所指向对象的信息，包括：

- 对象的实际指针。
- **`shared_ptr`的引用计数。**
- **`weak_ptr`的引用计数。**

**当我们说`std::shared_ptr`的引用计数，我们实际上是指这个控制块中的计数值。同样，`std::weak_ptr`的引用计数也指的是控制块中的另一个计数值。**





### shared指针怎么做到自动释放的、shared_ptr的引用计数实现、栈工作

**shared指针怎么做到自动释放的：**

`std::shared_ptr`是C++的智能指针，它提供了自动内存管理的能力，**主要依赖于引用计数机制来实现自动释放资源。**下面是`std::shared_ptr`如何做到自动释放的简单说明：

1. **自动释放**:
   - 当引用计数降到0（即没有任何`std::shared_ptr`实例指向对象），对象会被自动删除。如果提供了自定义删除器，它将被调用，否则默认使用`delete`操作符。
   - 当对象被删除后，控制块的`std::shared_ptr`引用计数和`std::weak_ptr`引用计数都会检查。如果两者都为0，则控制块也会被释放。
2. **控制块和引用计数**:
   - 当你创建一个`std::shared_ptr`实例并让它指向一个对象时，除了对象的内存之外，还会分配一个控制块（control block）的内存。这个控制块中存储了`shared_ptr`的引用计数、`weak_ptr`的引用计数以及相关的资源（例如自定义的删除器等）。
   - 引用计数初始设置为1。
3. **复制和赋值**:
   - 当你复制或赋值一个`std::shared_ptr`，控制块中的引用计数会增加。
   - 每当一个`std::shared_ptr`实例被销毁或超出其作用域，控制块中的引用计数会减少。
4. **线程安全**:
   - 引用计数的增加和减少操作是原子的，这意味着`std::shared_ptr`在多线程环境中也是安全的（但请注意，这并不意味着通过`std::shared_ptr`访问对象的操作也是线程安全的，你可能需要其他同步机制）。



**shared_ptr的引用计数实现：**

**shared_ptr 的引用计数是存放在堆上的，多个 shared_ptr 的对象的引用计数都指向同一个堆地址。**

1、shared_ptr的尺寸是原生指针的两倍，内部包含了指向资源的指针和指向控制块的指针

2、控制块所在的内存必须通过动态分配得到。是因为控制块和被指向的对象是相关联的，但是被指向的对象却不知道控制块的地址。即**需要两次动态内存分配 ，分别分配对象的空间和控制块的空间**。但是后面提到的**make_ptr可以避免额外的动态分配的成本。**

3、对引用计数的递增和递减必须是**原子操**作的，当在不同的线程中使用shared_ptr来指向同一对象，

可能会同时修改引用计数造成引用计数的错误。shared_ptr和unique_ptr一样也可以自定义析构函数，但unique_ptr的析构函数是智能指针的一部分，但对于shared_ptr并不是，

因为析构函数是unique_ptr的一部分，自定义析构函数不同的unique_ptr不可以互相赋值，但是指向对象类型相同析构函数不同的shared_ptr可以相互赋值。当指向对象的shared_ptr创建，那么控制块也就会创建，



**栈工作？**

智能指针，如`std::shared_ptr`和`std::unique_ptr`，通常在栈上创建和使用，但它们所管理的资源（例如，通过`new`分配的动态内存）通常位于堆上。这是智能指针最常见的使用方式，因为它利用了栈的自动内存管理特性来确保资源的正确释放。

智能指针如`std::shared_ptr`和`std::unique_ptr`使用内部的数据结构和机制来管理在堆上的对象。这些机制确保了资源的自动管理和释放。以下是智能指针



### 引用计数怎么变化、weak_ptr不能知道对象引用计数为0

**引用计数怎么变化：**

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
4. 析构函数中引用计数减1；
5. 在赋值运算符和析构函数中，如果减1后为0，则调用`delete`释放对象。

**weak_ptr不能知道对象引用计数为0：**

**不能**。weak_ptr是一种**不控制对象生命周期的智能指针**，它**指向一个shared_ptr**管理的对象**。进行该对象管理的是那个引用的shared_ptr。weak_ptr**只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，**它的构造和析构不会引起计数的增加或减少**。



### 在析构函数里将引用计数减1、是谁的析构函数

是的，当一个`std::shared_ptr`对象被销毁时，它的析构函数会减少其控制块中的引用计数。

**这个析构函数是`std::shared_ptr`自己的析构函数。每次一个`std::shared_ptr`实例被销毁（例如，因为它超出了作用域或者被明确地重置或销毁），其析构函数都会被调用。在这个析构函数中，引用计数会被减少。如果引用计数变为0，`std::shared_ptr`会释放其管理的对象。同时，如果与该`std::shared_ptr`关联的`weak_ptr`的计数也为0，那么控制块也会被释放。**

这种自动的引用计数管理确保了只要还有一个`std::shared_ptr`引用着一个对象，那么该对象就不会被销毁，但一旦没有任何`std::shared_ptr`引用它，它将被自动释放。



###  new 和 make_shared 初始化智能指针对象不一样

```cpp
A* a = new A;
std::shared_ptr<A> pa1(a);  //①

std::shared_ptr<A> pa2 = std::make_shared<A>(1);  //②
```

1. 对于 `new` 来说，会在堆上分配两次内存，一次是在**堆上分配内存给需要建立的对象**，另一次是**创建共享指针时，在堆上为引用计数分配内存**，会造成内存碎片化。
2. 对于 `std::make_shared` 来说，会直接**在堆上分配一段大的内**存，一部分分**配给需要建立的对象，一部分分配给引用计数**。



### make_unique 、make_shared的创建

- **make_unique 在 C++ 14 以后才被加入到标准的 C++ 中**，make_shared 则是 C++ 11 中加入的。优先选用 std::make_unique 和 std::make_shared,而非直接 new

- **make_unique：**

  减少代码量，能够加快编译速度，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外情况下可能会导致内存泄漏。但是 make_unique **不允许自定析构器**，不接受 std::initializer_list 对象

- **`make_shared`：**

  主要是可以**减少对堆中申请内存的次数**，只需要申请一次即可

  - 使用 new 时，我们将 new 出的资源指针赋给 share_ptr 的 ptr, 然后 share_ptr 本身还需要再次在堆上申请一块单独的内存作为它的管理区，**存放引用计数、用户自定的函数**等，因此创建 shared_ptr 时需要在堆上申请两次。
    `C++ [] std::shared_ptr<Widget>(new Widget);`
  - 当我们使用 **make_share** 时，我们只需要**申请一块大的内存，**一半用来存储资源，另一半作为管理区, 存放引用计数、用户自定的函数等，此时需要在堆上申请一次即可。
    `C++ auto upw1(std::make_unique<Widget>());`
  - make_share 虽然效率高，但是**同样不能自定义析构器**，同时 share_ptr 的对象资源可能会延迟释放，因为此时**对象资源与管理区域在同一块内存中，必须要同时释放**。



**std::enable_share_from_this:**

**内部原理是：**

- 当你创建一个从 `std::enable_shared_from_this` 派生的类的 `std::shared_ptr` 时**，`shared_ptr` 的构造函数会检测这个类是否从 `std::enable_shared_from_this` 派生。如果是，它会更新 `std::enable_shared_from_this` 基类部分的内部 `weak_ptr`，使其指向新创建的 `shared_ptr`。**

- `std::enable_shared_from_this` 内部维护了一个 `weak_ptr` 成员。`weak_ptr` 是一种智能指针，它指向一个对象，但不拥有它。这意味着，尽管 `weak_ptr` 会失效（指向空）当对象被销毁，但它不会阻止对象被销毁。

- **然后，当你调用 `shared_from_this` 时，`std::enable_shared_from_this` 实际上是调用内部的 `weak_ptr` 的 `lock` 方法来创建并返回一个新的 `shared_ptr`。因为 `weak_ptr` 是共享 `shared_ptr` 的所有权的，所以新创建的 `shared_ptr` 也会共享同一个对象的所有权。**

- 这是如何工作的关键原因：`shared_ptr` 的构造函数和 `enable_shared_from_this` 的 `shared_from_this` 方法都与同一个 `weak_ptr` 交互，从而共享同一个对象的所有权。

- 重要的是，`shared_from_this` 只能从已经由 `shared_ptr` 管理的对象中调用。如果尝试在任何 `shared_ptr` 管理之前调用 `shared_from_this`，例如在构造函数中，或者在只有一个裸指针的情况下，那么内部的 `weak_ptr` 将没有与之共享所有权的 `shared_ptr`，`shared_from_this` 会抛出 `std::bad_weak_ptr` 异常。

`std::enable_shared_from_this` 是一个模板类，它是 C++ 标准库中的一部分，**允许对象自己生成 `std::shared_ptr`。**这在需要创建当前类对象的 `shared_ptr`，但是你只有该类的普通指针或引用的时候非常有用。

一种常见的使用场景是，**在类的成员函数中，你可能需要生成一个当前对象的 `shared_ptr`。如果你尝试直接使用 `std::shared_ptr` 的构造函数来创建新的 `shared_ptr`，会导致对象的引用计数不正确，甚至可能会在运行时出错。**

通过让**你的类公开继承 `std::enable_shared_from_this`，你的类就可以使用 `shared_from_this` 成员函数，该函数会返回一个新的 `shared_ptr`，它和其他指向该对象的 `shared_ptr` 共享所有权。**

```c++
#include <memory>

class MyClass : public std::enable_shared_from_this<MyClass> {
public:
    std::shared_ptr<MyClass> get_shared_ptr() {
        return shared_from_this();
    }
};

int main() {
    std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
    std::shared_ptr<MyClass> another = obj->get_shared_ptr();
    return 0;
}

```

在这个例子中，`obj` 和 `another` 共享对同一个 `MyClass` 对象的所有权。这意味着，当它们都离开作用域并被销毁时，`MyClass` 对象也会被删除。如果你没有使用 `std::enable_shared_from_this`，而是直接创建了一个新的 `shared_ptr`，那么 `MyClass` 对象会在第一个 `shared_ptr` 被销毁时立即删除，然后再次尝试删除它时会出现运行时错误。

在类的成员函数中尝试直接使用 `std::shared_ptr` 的构造函数来创建当前对象的 `shared_ptr` 可能会导致引用计数不正确，因为这会生成一个新的控制块（也叫控制结构），这个控制块独立地跟踪引用计数。如果原来的对象也被一个 `shared_ptr` 管理，那么现在你就有两个独立的 `shared_ptr` 控制块，它们都试图管理同一个对象，这显然是错误的。

**注意：`shared_from_this` 只能从已经存在的 `std::shared_ptr` 所管理的对象中调用，否则它的行为是未定义的。换句话说，你不应该在对象的构造函数中调用 `shared_from_this`，因为在构造函数执行时，`shared_ptr` 还未完全构造。**













### unique_ptr 的unique 如何实现、unique_lock和lock_guard有什么区别：

**unique_ptr 的unique 如何实现：**

unique_ptr 中**拷贝构造函数和赋值操作符**都声明为delete或private。
优先使用 make_shared 和 make_unique 的原因是**为了避免内存泄露。**

**unique_lock和lock_guard有什么区别：**

`std::lock_guard`和`std::unique_lock`都是C++标准库提供的用来管理互斥锁（mutex）的工具，它们可以确保在出现异常或者提前返回的情况下仍能正确地解锁，避免了死锁的发生。然而，它们在功能上有一些不同：

1. `std::lock_guard`: 这是一个简单的RAII封装，它**在构造时会获取互斥锁，然后在销毁时会释放互斥锁**。`std::lock_guard`提供了最基本的互斥锁管理功能，它不能手动控制锁的获取和释放，也不能对互斥锁进行尝试锁定和条件锁定。
2. `std::unique_lock`: 这是一个更灵活的RAII封装，它提供了`std::lock_guard`所有的功能，还有一些额外的特性。首先，**`std::unique_lock`可以手动控制锁的获取和释放**。其次，它可以尝试锁定一个互斥锁，而不会阻塞当前线程。最后，**它可以用在条件变量上，使得我们可以在一个特定的条件满足时获取锁**。

简单来说，如果你只需要简单地管理一个互斥锁，那么`std::lock_guard`就足够了。如果你需要更多的控制，比如手动释放锁、尝试锁定或者条件锁定，那么你就需要使用`std::unique_lock`。在我们的例子中，我们需要在条件变量上等待一个条件，所以我们使用了`std::unique_lock`。

















### 不用智能指针，避免内存泄露的办法、注意事项

**不用智能指针，避免内存泄露的办法：**

通过手动管理内存来避免内存泄漏。以下是一些常用的办法：

1. **使用 RAII（资源获取即初始化）原则**：在对象的构造函数中分配资源，在析构函数中释放资源。确保**资源在对象的生命周期结束时**得到释放。
2. **手动释放资源：**如果使用了 `new` 分配内存，需要在不再使用该内存时手动调用 `delete` 来释放内存。
3. **使用容器和算法：**使用标准库提供的容器和算法，避免手动分配内存和管理资源。标准库中的容器会自动处理内存分配和释放。
4. **限制资源的作用域**：尽量将资源的作用域限制在需要的范围内，避免资源在不需要的地方被误用或遗忘释放。



**智能指针的注意事项：**

不使用**相同的内置指针值**初始化，或reset多个智能指针
不delete get()返回的指针
不使用get()初始化或reset另一个智能指针
get()返回的智能指针可能变成dangling pointer
如果智能指针管理的内存不是new出来的，需要提供删除器

1、尽量用make_shared/make_unique，少用new
std::shared_ptr在实现的时候使用的**refcount技术**，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr<A> p2(new A) 的时候，首先**会申请数据的内存，然后申请内控制块**，因此是两次内存申请，而std::make_shared<A>()则是只执行一次内存申请，将**数据和控制块的申请**放到一起。

2、不要使用相同的内置指针来初始化(或者reset)多个智能指针

3、不要delete get()返回的指针

4、不要用get()初始化/reset另一个智能指针

5、**智能指针管理的资源它只会默认删除new分配的内存,**如果不是new分配的则要传递给其一个删除器

6、不要把this指针交给智能指针管理

以下代码发生了什么事情呢？还是同样的错误。把原生指针 this 同时交付给了 m_sp 和 p 管理，这样会导致 this 指针被 delete 两次。
这里值得注意的是：以上所说的交付给m_sp 和 p 管理不对，并不是指不能多个shared_ptr同时占有同一类资源。shared_ptr之间的资源共享是通过shared_ptr智能指针拷贝、赋值实现的，因为这样可以引起计数器的更新；而如果直接通过原生指针来初始化，就会导致m_sp和p都根本不知道对方的存在，然而却两者都管理同一块地方。相当于”一间庙里请了两尊神”。

```c++
class Test{
public:
    void Do(){  m_sp =  shared_ptr<Test>(this);  }
private:
    shared_ptr<Test> m_sp;
};
int main()
{
    Test* t = new Test;
    shared_ptr<Test> p(t);
    p->Do();
    return 0;
}
```

7、不要把一个原生指针给多个shared_ptr或者unique_ptr管理

我们知道，在使用原生指针对智能指针初始化的时候，智能指针对象都视原生指针为自己管理的资源。换句话意思就说：初始化多个智能指针之后，这些智能指针都担负起释放内存的作用。那么就会导致该原生指针会被释放多次！！

```C++
int* ptr = new int;
shared_ptr<int> p1(ptr);
shared_ptr<int> p2(ptr);
//p1,p2析构的时候都会释放ptr，同一内存被释放多次！
```

8、不是使用new出来的空间要自定义删除器
以下代码试图将malloc产生的动态内存交给shared_ptr管理；显然是有问题的，delete 和 malloc 牛头不对马嘴！！！
所以我们需要自定义删除器[](int* p){ free§; }传递给shared_ptr。

```C++
    int main()
{
    int* pi = (int*)malloc(4 * sizeof(int));
    shared_ptr<int> sp(pi);
    return 0;
}
```

9、尽量不要使用 get()
智能指针设计者之处提供get()接口是为了使得智能指针也能够适配原生指针使用的相关函数。这个设计可以说是个好的设计，也可以说是个失败的设计。因为根据封装的封闭原则，我们将原生指针交付给智能指针管理，我们就不应该也不能得到原生指针了；因为原**生指针唯一的管理者就应该是智能指针**。而不是客户逻辑区的其他什么代码。
所以我们在**使用get()的时候要额外小心**，禁止使用get()返回的原生指针再去初始化其他智能指针或者释放。(只能够被使用，不能够被管理)。而下面这段代码就违反了这个规定：

```c++
int main()
{
    shared_ptr<int> sp(new int(4));
    shared_ptr<int> pp(sp.get());
    return 0;
}
```





   

**智能指针因异常没释放内存，导致内存膨胀**

智能指针因为异常原因没有释放掉内存，导致内存不断膨胀，不断的堆积下去可能是因为以下情况：

1. 异常处理不当：如果在使用智能指针的过程中发生异常，但没有适当的异常处理机制来保证资源的正确释放，那么可能导致内存没有被释放，从而产生内存泄漏。例如，在函数中使用 `std::shared_ptr` 管理资源，**发生了异常但没有捕获并释放资源，就可能导致资源泄漏**。
2. 异常忽略：有时在编程中可能会忽略异常，例如在构造函数中分配资源，但在异常发生时忽略了资源的释放。这样就会导致资源没有正确释放，引起内存泄漏。
3. **循环引用**：循环引用是指多个对象相互引用形成环状，而且这些对象都是使用智能指针管理的。由于 `std::shared_ptr` 使用引用计数来跟踪资源的引用次数，循环引用会导致资源的引用计数无法降为零，从而导致内存泄漏。

解决这些问题的方法包括：

- 确保在**使用智能指针时有适当的异常处理机制**，以确保资源在发生异常时能够正确释放。
- 不要**忽略异常**，确保在构造函数或其他可能发生异常的地方正确释放资源。
- 避免循环引用问题，使用 `std::weak_ptr` 或其他手段打破循环引用。





### enable_shared_from_this

类里面有个函数返回**一个指向自己的智能指针、原理**，这样可以避免悬空指针问题

继承enable_shared_from_this，使用shared_from_this()返回

**当一个类继承自`std::enable_shared_from_this<T>`，通过调用`shared_from_this()`函数来返回指向自己的`std::shared_ptr`，这样做的底层原理**涉及到了C++智能指针的内部实现和**引用计数**机制。

在`std::shared_ptr`内部，它维护了一个引用计数（reference count）。引用计数用于记录有多少个智能指针共享同一个对象。每当一个新的`std::shared_ptr`指向一个对象时，引用计数会增加；当一个`std::shared_ptr`不再指向对象时，引用计数会减少。当引用计数变为0时，表示没有任何`std::shared_ptr`指向对象，此时对象会自动被销毁，从而确保内存的正确释放。

`std::enable_shared_from_this`提供了一种安全的方式，让**类中的成员函数获取指向自己的`std::shared_ptr`**，即使在已有`std::shared_ptr`管理的情况下。

当类继承自`std::enable_shared_from_this<T>`时，它会有一个**隐藏的`weak_ptr<T>`成员变量**。`std::weak_ptr`是`std::shared_ptr`的一种弱引用，它不会增加对象的引用计数，**只用于监测对象是否还存在**。

`std::enable_shared_from_this`中的**`shared_from_this()`函数会首先检查自身的`weak_ptr`是否存在，如果存在且引用计数大于0，那么它会返回一个指向自己的`std::shared_ptr`。**如**果`weak_ptr`不存在或引用计数为0，则会抛出`std::bad_weak_ptr`异常，这样可以避免悬空指针问题。**

**内部原理是：**

- 当你创建一个从 `std::enable_shared_from_this` 派生的类的 `std::shared_ptr` 时**，`shared_ptr` 的构造函数会检测这个类是否从 `std::enable_shared_from_this` 派生。如果是，它会更新 `std::enable_shared_from_this` 基类部分的内部 `weak_ptr`，使其指向新创建的 `shared_ptr`。**

- `std::enable_shared_from_this` 内部维护了一个 `weak_ptr` 成员。`weak_ptr` 是一种智能指针，它指向一个对象，但不拥有它。这意味着，尽管 `weak_ptr` 会失效（指向空）当对象被销毁，但它不会阻止对象被销毁。

- **然后，当你调用 `shared_from_this` 时，`std::enable_shared_from_this` 实际上是调用内部的 `weak_ptr` 的 `lock` 方法来创建并返回一个新的 `shared_ptr`。因为 `weak_ptr` 是共享 `shared_ptr` 的所有权的，所以新创建的 `shared_ptr` 也会共享同一个对象的所有权。**

- 这是如何工作的关键原因：`shared_ptr` 的构造函数和 `enable_shared_from_this` 的 `shared_from_this` 方法都与同一个 `weak_ptr` 交互，从而共享同一个对象的所有权。

- 重要的是，`shared_from_this` 只能从已经由 `shared_ptr` 管理的对象中调用。如果尝试在任何 `shared_ptr` 管理之前调用 `shared_from_this`，例如在构造函数中，或者在只有一个裸指针的情况下，那么内部的 `weak_ptr` 将没有与之共享所有权的 `shared_ptr`，`shared_from_this` 会抛出 `std::bad_weak_ptr` 异常。

  

手撕智能指针：

```c++
template<typename T>
class SharedPtr {
private:
   size_t* m_count_;
   T* m_ptr_;
public:
 //构造函数
  SharedPtr():m_ptr_(nullptr),m_count_(new size_t) {}
  SharedPtr(T* ptr): m_ptr_(ptr),m_count_(new size_t) { m_count_ = 1;}
 //析构函数
 ~SharedPtr() {
    -- (*m_count_);
    if (*m_count_ == 0) {
         delete m_ptr_;
         delete m_count_;
         m_ptr_ = nullptr;
         m_count_ = nullptr;
     }
 }
 //拷⻉构造函数
 SharedPtr(const SharedPtr& ptr) {
        m_count_ = ptr.m_count_;
        m_ptr_ = ptr.m_ptr_;
        ++(*m_count_);
 }
 //拷⻉赋值运算
 void operator=(const SharedPtr& ptr) { SharedPtr(std::move(ptr)); }
 //移动构造函数
 SharedPtr(SharedPtr&& ptr) : m_ptr_(ptr.m_ptr_), m_count_(ptr.m_count_) { 
     ++(*m_count_); }
 //移动赋值运算
 void operator=(SharedPtr&& ptr) { SharedPtr(std::move(ptr)); }
 //解引⽤
 T& operator*() { return *m_ptr_; }
 //箭头运算
 T* operator->() { return m_ptr_; }
 //᯿载bool操作符
 operator bool() {return m_ptr_ == nullptr;}
 T* get() { return m_ptr_;}
 size_t use_count() { return *m_count_;}
 bool unique() { return *m_count_ == 1; }
 void swap(SharedPtr& ptr) { std::swap(*this, ptr); }
};
```



### **shared_ptr实现:**

- 一个模板指针 `T* ptr`，指向实际的对象

- 一个引用计数

  必须 new 出来的，不然会多个 shared_ptr 里面会有不同的引用次数而导致多次 delete

- 重载 `operator*` 和 `operator->`

  使得能像指针一样使用shared_ptr

- 重载 copy constructor

  使其引用次数加一（拷贝构造函数）

- 重载 `operator=`（赋值运算符）

  如果原来的shared_ptr已经有对象，则让其引用次数减一并判断引用是否为零（是否调用delete），然后将新的对象引用次数加一

- 重载析构函数

  使引用次数减一并判断引用是否为零；（是否调用delete）
  
  
  
  这个共享指针类的关键特点是引用计数（`_pRefCount`）的管理和互斥锁（`_pMutex`）的使用，以确保在多线程环境中对资源的访问和释放都是安全的。此外，它还支持拷贝构造函数和赋值运算符重载，以允许多个共享指针共享相同的资源，而不会造成资源的重复释放。

```c++
template <typename T>
class Shared_Ptr {
public:
    // 构造函数，初始化成员变量
    Shared_Ptr(T* ptr = nullptr)
        : _pPtr(ptr)
        , _pRefCount(new int(1)) // 引用计数初始化为1，表示当前只有一个指针共享资源
        , _pMutex(new mutex)     // 用于多线程安全操作的互斥锁
    {}
    // 析构函数，释放资源
    ~Shared_Ptr() {
        Release();
    }
    // 拷贝构造函数，用于创建共享指针的副本，同时增加引用计数
    Shared_Ptr(const Shared_Ptr<T>& sp)
        : _pPtr(sp._pPtr)
        , _pRefCount(sp._pRefCount)
        , _pMutex(sp._pMutex)
    {
        AddRefCount();
    }
    // 赋值运算符重载，用于赋值新的共享指针，先释放旧资源，然后共享新资源
    Shared_Ptr<T>& operator=(const Shared_Ptr<T>& sp) {
        if (_pPtr != sp._pPtr) {
            Release();  // 释放管理的旧资源
            _pPtr = sp._pPtr;
            _pRefCount = sp._pRefCount;
            _pMutex = sp._pMutex;
            AddRefCount(); // 共享新资源，并增加引用计数
        }
        return *this;
    }
    // 解引用操作符重载，返回指向资源的引用
    T& operator*() {
        return *_pPtr;
    }
    // 成员访问操作符重载，返回指向资源的指针
    T* operator->() {
        return _pPtr;
    }
    // 返回当前资源的引用计数
    int UseCount() {
        return *_pRefCount;
    }
    // 返回指向资源的指针
    T* Get() {
        return _pPtr;
    }
private:
    // 增加引用计数，使用互斥锁确保多线程安全
    void AddRefCount() {
        _pMutex->lock();
        ++(*_pRefCount);
        _pMutex->unlock();
    }
    // 释放资源，如果引用计数为0，则删除资源
    void Release() {
        bool deleteflag = false;
        _pMutex->lock();
        if (--(*_pRefCount) == 0) {
            delete _pRefCount;
            delete _pPtr;
            deleteflag = true;
        }
        _pMutex->unlock();
        if (deleteflag == true)
            delete _pMutex;
    }
private:
    int *_pRefCount; // 引用计数
    T* _pPtr;        // 指向资源的指针
    mutex* _pMutex;  // 用于多线程安全的互斥锁
};

```



**简短版本**

```c++
template<typename T>
class SharedPtr {
private:
 size_t* m_count_;
 T* m_ptr_;
public:
 //构造函数
 SharedPtr(): m_ptr_(nullptr),m_count_(new size_t) {}
 SharedPtr(T* ptr): m_ptr_(ptr),m_count_(new size_t) { m_count_ = 1;}
 //析构函数
 ~SharedPtr() {
 -- (*m_count_);
 if (*m_count_ == 0) {
 delete m_ptr_;
 delete m_count_;
 m_ptr_ = nullptr;
 m_count_ = nullptr;
 }
 }
 //拷⻉构造函数
 SharedPtr(const SharedPtr& ptr) {
 m_count_ = ptr.m_count_;
 m_ptr_ = ptr.m_ptr_;
 ++(*m_count_);
 }
 //拷⻉赋值运算
 void operator=(const SharedPtr& ptr) { SharedPtr(std::move(ptr)); }
    //移动构造函数
 SharedPtr(SharedPtr&& ptr) : m_ptr_(ptr.m_ptr_), m_count_(ptr.m_count_) { ++
(*m_count_); }
 //移动赋值运算
 void operator=(SharedPtr&& ptr) { SharedPtr(std::move(ptr)); }
 //解引⽤
 T& operator*() { return *m_ptr_; }
 //箭头运算
 T* operator->() { return m_ptr_; }
 //᯿载bool操作符
 operator bool() {return m_ptr_ == nullptr;}
 T* get() { return m_ptr_;}
 size_t use_count() { return *m_count_;}
 bool unique() { return *m_count_ == 1; }
 void swap(SharedPtr& ptr) { std::swap(*this, ptr); }
};
```





**unique_ptr实现：**

**1、unique_ptr"唯一"拥有其所指对象**

同一时刻只能有一个unique_ptr指向给定对象，离开作用域时，若其指向对象，则将其所指对象销毁（默认delete）

**2、定义unique_ptr时**

需要将其绑定到一个new返回的指针上。

**3、unique_ptr不支持普通的拷贝和赋值（因为拥有指向的对象）**

但是可以**拷贝和赋值一个将要被销毁的unique_ptr**；可以通过**release或者reset**将**指针所有权**从一个（非const）unique_ptr转移到另一个unique。

```c++
template <typename T> 
struct PointerDeleter{
    void operator()(const T *ptr) {
        if(ptr) {
            delete ptr;
            ptr = nullptr;
        }
    }
};

template <typename T, typename Deleter = PointerDeleter<T> >
class UniquePtr{
public:
    UniquePtr();
    UniquePtr(T *_ptr);
    UniquePtr(UniquePtr&& p); // 移动构造函数  原对象的内存空间 移动到 新对象使用
    ~UniquePtr();

// non-copyable
private:
    UniquePtr(const UniquePtr& p) = delete;
    UniquePtr& operator= (const UniquePtr& p) = delete;

public:
    T& operator* ();
    T* operator-> ();
    UniquePtr &operator= (UniquePtr&& p); // 移动赋值，右值
    operator bool() const;

    // 返回原始指针
    T* get() const;
    // 返回指针，释放所有权
    T* release();
    // 替换被管理的对象
    void reset(T *_ptr);
    // 交换被管理的对象
    void swap(UniquePtr &p);

private:
    T *ptr;
};

template <typename T, typename Deleter>
UniquePtr<T, Deleter>::UniquePtr() : ptr(nullptr)
{}

template <typename T, typename Deleter>
UniquePtr<T, Deleter>::UniquePtr(T *_ptr) : ptr(_ptr)
{}

// 移交所有权
template <typename T, typename Deleter>
UniquePtr<T, Deleter>::UniquePtr(UniquePtr &&p) : ptr(p.ptr)
{
    p.ptr = nullptr;
}

// 析构函数
template<typename T, typename Deleter>
UniquePtr<T, Deleter>::~UniquePtr() 
{
    Deleter()(ptr);
    std::cout << "unique ptr destory." << std::endl;
}

// 
template<typename T, typename Deleter>
T& UniquePtr<T, Deleter>::operator*()
{
    return *ptr;
}

// 
template<typename T, typename Deleter>
T* UniquePtr<T, Deleter>::operator->()
{
    return ptr;
}

// 
template<typename T, typename Deleter>
UniquePtr<T, Deleter>& UniquePtr<T, Deleter>::operator=(UniquePtr &&p) 
{
    std::swap(ptr, p.ptr);
    return *this;
}

template<typename T, typename Deleter>
UniquePtr<T, Deleter>::operator bool() const 
{
    return ptr != nullptr;
}

template<typename T, typename Deleter>
T* UniquePtr<T, Deleter>::get() const 
{
    return ptr;
}

template<typename T, typename Deleter>
T* UniquePtr<T, Deleter>::release()
{
    T *pointer = ptr;
    ptr = nullptr;
    return pointer;
}

template<typename T, typename Deleter>
void UniquePtr<T, Deleter>::reset(T *_ptr) 
{
    UniquePtr<T, Deleter>().swap(*this);
    ptr = _ptr;
}

template<typename T, typename Deleter>
void UniquePtr<T, Deleter>::swap(UniquePtr &p) 
{
    std::swap(ptr, p.ptr);
}
```



**weak_ptr实现：**

**1、weak_ptr是为了配合shared_ptr而引入的一种智能指针**

它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况，但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。

**2、和shared_ptr指向相同内存**

shared_ptr析构之后内存释放，在**使用之前使用函数 `lock()` 检查weak_ptr是否为空指针**。

```c++
template<typename T>
class WeakPtr
{
public:
    WeakPtr() {};

    WeakPtr(const SharedPtr<T> &p) : ptr(p.get())
    {}

    ~WeakPtr()
    {}

    WeakPtr<T>& operator= (const WeakPtr &p)
    {
        ptr = p.ptr;
        return *this;
    }

    T& operator*()
    {
        return *ptr;
    }

    T* operator->()
    {
        return ptr;
    }
    
    shared_ptr<T> lock() { return shared_ptr<T>(*this); };

    operator bool()
    {
        return ptr != nullptr;
    }

private:
    // weak point 只引用，不计数
    T *ptr;
};
```











循环引用代码：

```c++
class B;
class A
{
public:
 A(  ) : m_sptrB(nullptr) { };
 ~A( )
 {
  cout<<" A is destroyed"<<endl;
 }
 shared_ptr<B> m_sptrB;
};
class B
{
public:
 B(  ) : m_sptrA(nullptr) { };
 ~B( )
 {
  cout<<" B is destroyed"<<endl;
 }
 shared_ptr<A> m_sptrA;
};
//***********************************************************
void main( )
{
 shared_ptr<B> sptrB( new B );  // sptB count 1
 shared_ptr<A> sptrA( new A );  // sptB count 1
 sptrB->m_sptrA = sptrA;    // sptB count 2
 sptrA->m_sptrB = sptrB;    // sptA count 2
}

// 超出定义域
// sptA count 1
// sptB count 2
```

**weakptr解决循环引用代码：**

```c++
解决 shared_ptr 循环引用问题
class B;
class A
{
public:
 A(  ) : m_a(5)  { };
 ~A( )
 {
  cout<<" A is destroyed"<<endl;
 }
 void PrintSpB( );
 weak_ptr<B> m_sptrB;
 int m_a;
};
class B
{
public:
 B(  ) : m_b(10) { };
 ~B( )
 {
  cout<<" B is destroyed"<<endl;
 }
 weak_ptr<A> m_sptrA;
 int m_b;
};

void A::PrintSpB( )
{
 if( !m_sptrB.expired() )
 {  
  cout<< m_sptrB.lock( )->m_b<<endl;
 }
}

void main( )
{
 shared_ptr<B> sptrB( new B );
 shared_ptr<A> sptrA( new A );
 sptrB->m_sptrA = sptrA;
 sptrA->m_sptrB = sptrB;
 sptrA->PrintSpB( );
}
```









**左值和右值**

**左值：**可以放在等号左边，表达式结束后依然存在的持久对象。可以取地址，可以通过内置（不包含重载） & 来获取地址，我们可以将一个右值赋给左值。

**右值：**不可以放在等号左边，表达式结束就不再存在的临时对象。不可取地址，不可以通过内置（不包含重载） & 来获取地址。由于右值不可取地址，因此我们不能将任何值赋给右值。

**`++i,--i` 是左值（返回的是引用），`i++,i--` 是右值（返回的是对象）**，使用 = 进行赋值时，= 的左边必须为左值，右值只能出现在 = 的右边。函数返回值即可以是左值，也可以是右值

**右值=将亡值**

将亡值可以理解为即将要**销毁的值**，通过**“盗取”其它变量内存空间**方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以**避免内存空间的释放和分配**，延长变量值的生命周期，常用来完成**移动构造或者移动赋值**的特殊任务





## C++11 新特性

1.新增语法、2.智能指针、3.thread库相关、4.**右值引用和移动语义**、5.auto关键字,auto 类型推导的原理,auto 类型完美转发.

6.**decltype类型推导**、7.范围 `for` 语句、8.constexpr、9.初始化列表 initializer list

1. **新增语法**

   - nullptr
   - auto 自动类型推导（auto声明的变量必须要初始化，不能被声明为返回值，不能作为形参，不能被修饰为模板参数）
   - 范围 for 循环
   - 初始化列表
   - lambda 表达式

2. **智能指针**

   - unique_ptr：遵循**独占语义的智能指针**，在任何时间点，**资源智能唯一地被一个unique_ptr所占有**，当其离开作用域时自动析构。资源所有权的转移只能通过 `std::move()` 而不能通过赋值。
   - shared_ptr：基于**引用计数**的智能指针，会统计当前有多少个对象同时拥有该内部指针；当引用计数降为0时，自动释放。
   - weak_ptr：解决 shared_ptr 循环引用的问题。

3. **库相关**

   - thread库及其相配套的同步原语mutex, lock_guard, condition_variable, 以及异步 std::furture
   - 函数对象和bind绑定器
   - `std::thread` 是 C++ 标准库中用于创建和管理线程的类。您可以使用它来创建新线程，传递函数或函数对象作为线程的入口点，并启动线程执行。
   - `std::mutex`（互斥锁）是一种用于保护共享资源免受并发访问的同步原语。通过在临界区（可能被多个线程同时访问的代码区域）周围使用互斥锁，可以确保线程安全。
   - `std::lock_guard` 是一个 C++ 标准库类，用于在作用域结束时自动释放互斥锁。这有助于防止忘记手动释放锁，从而避免死锁等问题。
   - `std::condition_variable` 是一种同步原语，用于在多个线程之间进行通信和协调。它允许线程等待某些条件满足，然后继续执行。
   - `std::future` 是 C++ 标准库中用于处理异步操作结果的机制。它允许您在一个线程中启动异步任务，然后在需要结果时在另一个线程中获取结果。
   - 函数对象是可调用的对象，可以像函数一样使用。`std::bind` 是一个函数，用于创建新的函数对象，并可以绑定参数。

4. **右值引用和移动语义**

   - 右值引用是C++11新特性，它实现了**转移语义和完美转发**。

   - 主要作用：

     （1）消除两个对象交互时**不必要的对象拷贝**，节省运算存储资源，提高效率

     （2）能够更简洁明确地定义泛型函数

   - **移动语义**：编译器**只对右值引用**才能调用移动构造函数，所以需要用户定义自己的移动构造函数，然后调用 `std::move()` 将左值转换为右值

   - **完美转发**：将**一组参数原封不动地**传递给另一个函数（C++11对T&&的类型推导： 右值实参为右值引用，左值实参仍然为左值），使用 `std::forward()`

5. **auto关键字、auto 类型推导的原理、auto 类型完美转发**

   auto可以让编译器在**编译期**就推导出变量的类型

   - auto的使用必须马上初始化，否则无法推导出类型
   - auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败
   - auto不能用作函数参数
   - 在类中auto不能用作非静态成员变量
   - auto不能定义数组，可以定义指针
   - auto无法推导出模板参数
   - 在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定
   - 在声明为引用或者指针时，auto会保留等号右边的引用和cv属性

   #####  auto 关键字

   auto 是自动类型推断，用于从**初始化表达式**中推断出变量的数据类型，这个推导的工作由编译器完成。

   注意点：

   1. auto不能自动推导成constant 或者 volatile，会覆盖顶层的引用和修饰，除非被声明为引用类型
   2. auto会**退化成指向数组的指针**，除非被声明为引用
   3. 如果需要保留**顶层的引用和修饰**，需要声明为 auto 引用或者使用 decltype

   

   **auto 类型推导的原理、auto 类型完美转发**

   - auto 是 C++ 语言的关键字。C++11 规定，auto 关键字用于两种情况：
     - 声明变量时根据初始化表达式自动推断该变量的类型；
     - 声明函数时函数返回值的占位符；
   - auto 声明变量时，**根据初始化的表达式来推导该变量的类型，此时变量必须进行初始化。使用 auto 类型可以使变量定义变得更为简单，程序结构更为清晰一些**
   - 使用 auto 关键字做**类型自动推导时的规则**：
     - 如果**初始化表达式是引用**，首先去除引用，如果 auto 类型关键字带上 & 则不进行去除
     - 其次，**去掉剩下的初始化表达式顶层的 const 或 volatile 限定符**。
     - C++ 14 以后如果用 {} 来进行赋值，此时 **auto 类型推导出的类型为 std::initializer_list**；而模板函数的形参推导时不认为这种**值列表是一个类型**，此时则不能推导出 std::initializer_list 类型

   **auto 类型完美转发**

   - C++11 使用 auto 声明变量时，如：auto&& var=initValue;，则此时 “auto&&” **并不意味着这一定是右值引用类型的变量，而是类似于模板函数参数的类型推导，既可能是左值引用，也可能是右值引用**。

   - 其目的是把**初始化表达式的值分类情况，完美转发给由 auto 声明的变量**。

     如果初始化值是类型 A 的左值，则声明的变量类型为**左值引用 A&**；

     如果初始化值是类型 A 的右值，则声明的变量类型为**右值引用 A&&**
     
     

6. **decltype类型推导**

   decltype  /di cler tpye/ 则用于**推导表达式类型**，这里只用于**编译器分析表达式的类型**，表达式实际不会进行运算

   **decltype 关键字：**decltype 是 “declare type” 的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是**不想用该表达式的值初始化变量**，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型

   auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。

   对于decltype(exp)有：

   1. exp是表达式，decltype(exp)和exp类型相同
   2. exp是函数调用，decltype(exp)和函数返回值类型相同
   3. 其它情况,若exp是左值，decltype(exp)是exp类型的左值引用

   **根据表达式的值分类**（value categories），设 T 为 e 的类型：

   若 e 是一个左值（lvalue，即“可寻址值”），则 decltype(e) 将返回**T&**；
   若 e 是一个临终值（x value），则返回值为 **T&&** ；
   若 e 是一个纯右值（prvalue），则返回值为 **T**。

   **auto和decltype的配合使用：**

   ```c++
   template<typename T, typename U>
   auto add(T t, U u) -> decltype(t + u) {
       return t + u;
   }
   ```

   

   **7.范围 `for` 语句：**
   
   - 语法格式：
   
     ```c++
     for (declaration : expression){
         statement
     }
     ```
   
   - expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector，string 等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。
   
   - declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。
   
   
   
   **8.constexpr：**
   
   - 常量表示式对编译器来说是优化的机会，编译器时常在编译期执行它们并且将值存入程序中。同样地，在许多场合下，C++ 标准要求使用常量表示式。例如在数组大小的定义上，以及枚举值（enumerator values）都要求必须是常量表示式。常量表示式不能含有函数调用或是对象构造函数
   - `C++ 11` 引进关键字 `constexpr` 允许用户保证函数或是对象构造函数是编译期常量，编译器在编译时将去验证函数返回常量
   - 用 constexpr 修饰函数将限制函数的行为。
     - 函数的回返值类型不能为void；
     - 函数体不能声明变量或定义新的类型；
     - 函数体只能包含声明、null语句或者一段return语句；
     - 函数的内容必须依照 "return expr" 的形式，在参数替换后，expr 必须是个常量表达式；
     - 这些常量表达式只能够调用其他被定义为 constexpr 的函数，或是其他常量形式的参数。
   - constexpr 修饰符的函数直到在该编译单元内被定义之前是不能够被调用的。声明为 constexpr 的函数也可以像其他函数一样用于常量表达式以外的调用。
   - C++ 11 中的常量表达式中的变量都必须是常量，可以使用 constexpr 关键字来定义表达式中的变量
   
   
   
   
   
   **9.初始化列表 initializer list：**
   
   - C++ 11 把**初始化列表的定义**为标准类型，称作 std::initializer_list。允许构造函数或其他函数像参数般地使用初始化列表，在对象中可以定义初始化列表构造函数。
   - **初始化列表是常量**；一旦被创建，其成员均不能被改变，成员中的资料也不能够被变动。
   - 在 C++ 11 中初始化列表是标准类型，除了对象的构造函数之外还能够被用在其他地方，一般的函数能够使用初始化列表作为形参
   
   








### **左值引用、右值引用**、两者区别、左值转换为右值move

**基础概念：**

- **左值**，就是在内存有确定**存储地址、有变量名**，**赋值表达式结束**依然存在的值。
- **左值引用**，就是绑定到左值的引用。
- **右值引用**，本质上是将引用的右值内容存储到空间中，该右值引用变量具有名称和地址，所以**右值引用变量是一个左值**。
- **右值**，就是在内存没有确定存储地址、没有变量名的值。c++11中的右值分为**纯右值和将亡值**两种。
  1. 纯右值：**字面常量**或者是一个**不具名的临时对象**，比如一个数，一个字符常量
  2. 将亡值：生命周期即将**结束的变量**，通常用于**移动构造或移动赋值**。

使用**左值**去初始化对象或为对象赋值时，会调用**拷贝构造函数或赋值构造**函数。

而使用一个**右值来初始化或赋值**时，会调用**移动构造函数或移动赋值运算符**来移动资源，从而**避免拷贝**，提高效率。

**左值引用：**

- 左值引用可以区分为**常量左值引用和非常量**左值引用。左值引用的底层实现是**指针实现**。
- **非常量左值引用只能绑定到非常量左值**，不能绑定到常量左值和右值。如果绑定到非常量右值，就有可能指向一个已经被销毁的对象。
- 常量左值引用能绑定到非常量左值，常量左值和右值；
- 如果函数的形参定义为非常量的左值引用，则会出现错误，因为此时我们将**一个左值引用绑定到右值上**
- 如果**函数的形参定义为常量的左值引用**，则可以正常运行，因为此时我们将一个常量左值引用绑定到一个右值上

**右值引用：**

**右值引用，就是绑定到右值的引用，通过&&来获得右值引用**。右值，就是在内存没有确定存储地址、没有变量名，表达式结束就会销毁的值。

1. 实现**移动语义和完美转发，**&& 作为右值引用的声明符**。右值引用必须绑定到右值的引用，通过 && 获得。**右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。
2. 让编译器能够正确按照**左值和右值**去调用**对应的构造函数或者赋值运算符**，传入的**右值优先调用移动构造函数和移动赋值运算符**。在移动构造函数中进行对象的**浅拷贝，并将临时对象的资源置空**，从而直接使用临时对象。
3. 实现可以**移动但不能拷贝的类对象**，这种情况是在拷贝构造函数和拷贝赋值运算中加入delete关键字，并定义自己的移动构造函数和移动赋值运算符。

右值引用 作用：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。



**右值引用和左值引用的区别：**

1、左值引用绑定到有确定**存储空间以及变量名**的对象上，表达式结束后对象依然存在；右值引用绑定到**要求转换的表达式、字面常量、返回右值**的表达式等临时对象上，赋值表达式结束后就对象就会被**销毁**。
2、值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。

**3、右值引用的实例对应于临时对象**；右值引用并区别于左值引用，用作形参时能通过函数重载来区别对象是调用拷贝构造函数还是移动拷贝构造函数。实际上无论是左值引用还是右值引用，从编译后的反汇编层面上，都是**对象的存储地址的引用**。右值引用与左值引用的变量都**不能悬空**，也即定义时必须初始化从而绑定到一个对象上。

4、C++ 右值引用即绑定到右值的引用，用 && 来获得右值引用，**右值引用只能绑定到要销毁的对象**。为了和右值引用区分开，常规的引用称为左值引用。**左值引用是绑定到左值对象上；右值引用是绑定到临时对象上**。左值对象是指可以通过取地址 & 运算符得到该对象的内存地址；而临时对象是不能用取地址 & 运算符获取到对象的内存地址，具体的引用绑定规则如下:

- 非常量左值引用（X &）：只能绑定到 X 类型的左值对象；
- 常量左值引用（const X &）：可以绑定到 X、const X 类型的左值对象，或 X、const X 类型的右值；
- 非常量右值引用（X &&）：只能绑定到 X 类型的右值；
- **常量右值引用（const X &&）**：可以绑定规定到 X、const X 类型的右值。

*引用类型与可以引用的值类型的对应关系*

| 引用类型       | 非常量左值 | 常量左值 | 非常量右值 | 常量右值 | 使用场景                   |
| -------------- | ---------- | -------- | ---------- | -------- | -------------------------- |
| 非常量左值引用 | Y          | N        | N          | N        | 无                         |
| 常量左值引用   | Y          | Y        | Y          | Y        | 常用于类中构建拷贝构造函数 |
| 非常量右值引用 | N          | N        | Y          | N        | 移动语义、完美转发         |
| 常量右值引用   | N          | N        | Y          | Y        | 无实际                     |





**左值转换为右值:**

可以通过 `std::move` 可以将一个左值强制转化为右值，继而可以通过**右值引用使用该值**，以用于移动语义，从而完成将资源的所有权进行转移。

- 引用折叠: 通过**类型别名**或者通过**模板参数间接定义**，多重引用最终折叠成**左值引用或者右值引用**。有两种引用（左值和右值），所以就有四种可能的引用+引用的组合（左值 + 左值，左值 + 右值，右值 + 左值，右值 + 右值）。如果引用的引用出现在允许的语境，该双重引用会折叠成单个引用，规则如下：

  - 所有的**右值引用叠加到右值引用上仍然还是一个右值引用；T&& && 折叠成 T&&**
  - 所有的**其他引用类型之间的叠加都将变成左值引用。T& &&,T&& &, T&& 折叠成 T&**。

- **万能引用类型:**

  - 在模板中 T&& t 在发生自动类型推断的时候，它是未定的引用类型（universal references），它既可以接受一个左值又可以接受一个右值。如果**被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。**

  - 对于函数

    template<typename T>void f(T&& t)，当参数为右值 10 的时候，根据 universal references 的特点，t 被一个右值初始化，那么 t 就是右值；当参数为左值 x 时，t 被一个左值引用初始化，那么 t 就是一个左值

  - 上面的例子中，param 是 universal reference，rhs 是 Test&& 右值引用，因为模版函数 f 发生了类型推断，而 Test&& 并没有发生类型推导，**因为 Test&& 是确定的类型了**。正是因为右值引用可能是左值也可能是右值，依赖于**初始化，我们可以利用这一点来实现移动语义和完美转发**







### move移动语义的作用，实现原理、完美转发forward 的实现

- **移动语义：**转移所有权，**拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源**，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的**移动语义可以省去很多拷贝负担**，**如何利用移动语义，主要通过移动构造函数**。

  通过移动构造函数使用移动语义，也就是`std:move`；移动语义仅针对于那些**实现了移动构造函数的类的对象**，对于那种**基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数**

- **作用：**通过该函数可获得绑定到左值上的右值引用。通过 move 获取**变量的右值引用，从而可以调用对象的移动拷贝构造函数和移动赋值构造函数。**



- **move() 函数实现原理：**

  - `std::move()` 函数原型：`move` 函数是将任意类型的左值转为其类型的右值引用。

    ```c++
    template <typename T>
    typename remove_reference<T>::type&& move(T&& t)
    {
    	return static_cast<typename remove_reference<T>::type &&>(t);
    }
    ```

    - **引用折叠原理:**
      - 右值传递给上述函数的形参 T&& 依然是右值，**即 T&& && 相当于 T&&**。
      - 左值传递给上述函数的形参 T&& 依然是左值，**即 T&& & 相当于 T&**。
      - 通过引用折叠原理可以知道，move() 函数的形参既可以是**左值也可以是右值**。
    - **move 函数的处理流程:**
      - 首先**利用万能模板将传入的参数 t 进行处理**，右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&& 变为普通的左值引用，**以保证模板可以传递任意实参，且保持类型不变；万能模板既可以接受左值作为实参也可以接受右值作为实参。**
      - 通过 **remove_refrence 移除引用**，得到参数 t 具体的类型 type；
      - 最后通过 static_cast<> 进行强制类型转换，返回 type && 右值引用。

  - `remove_reference` 具体实现：`remove_reference` 主要作用是**解除类型中引用并返回变量的实际类型**。

  

  

**完美转发forward 的实现：**

**完美转发：**指可以写一个**接受任意实参的函数模板**，并**转发到其它函数**，**目标函数会收到与转发函数完全相同的实参**。转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数也是右值。

forward 保证了在**转发时左值右值特性不会被更改，实现完美转发**。主要解决**引用函数参数为右值时**，传进来之后有了变量名就变成了左值。

- **forward 函数的处理流程**:
  - forward 同样利用**引用折叠的特性**，对参数 t 做一次右值引用，根据引用折叠规则，右值的右值引用是右值引用，而左值的右值引用是普通的左值引用。forward 的实现有两个函数：
  - **第一个，接受的参数是左值引用，只能接受左值。**
  - **第二个，接受的参数是右值引用，只能接受右值。**
- **根据引用折叠的原理**：
  - 如果传递的是左值，\_Tp 推断为 T &，则**返回**变成static_cast<T& &&>，也就是 static_cast<T&>，所以返回的是左值引用。
  - 如果传递的是右值，_Tp 推断为 T&& 或者 T，则返回变成 static_cast<T && &&>，所以**返回的是右值引用**。
- **forward 与 move** 最大的区别是，move 在进行类型转换时，利用 remove_reference 将外层的引用全部去掉，这样可以将 **t 强制转换为指定类型的右值引用**，而 forward 则利用**引用折叠的技巧**，巧妙的保留了**变量原有的属性**。





### lambda 表达式、std::function、函数指针

这三个都可以作为函数对象来使用，但lambda表达式创建的是匿名函数对象，std::function是一个模板类，我一般是结合着bind使用，函数指针就是最传统的

- 如果一个 lambda 表达式作为参数传递给一个函数，那这个函数可以使用这个 lambda 表达式捕获的变量吗？**可以的**。

lambda表达式的主要优势在于它提供了一种便捷的方式来定义简短的、一次性的函数，而不必去定义一个完整的、命名的函数。在很多情况下，这可以使代码变得更加清晰和简洁。



### lambda表达式捕获、lambda表达式陷阱、lambda应用

**Lambda 表达式的一大特性是它可以捕获其封闭作用域中的变量，使这些变量在 Lambda 的函数体内部可用。**

Lambda 表达式的一般形式是：

```c++
[capture](parameters) -> return_type { body_of_lambda }
```

其中，`capture` 是捕获子句，它定义了 Lambda 从封闭作用域捕获哪些变量以及如何捕获它们。

捕获子句的主要形式：

1. `[=]`: 通过值捕获所有外部作用域的局部变量。
2. `[&]`: 通过引用捕获所有外部作用域的局部变量。
3. `[a, &b]`: 通过值捕获变量 `a` 并通过引用捕获变量 `b`。
4. `[this]`: 捕获当前类的 `this` 指针，允许 Lambda 访问类的成员。



**lambda表达式陷阱：**

1. **引用捕获陷阱**: 使用引用捕获（`[&]`）时，lambda 函数会保留所有外部变量的引用。问题是，如果外部变量的生命周期结束了（例如，局部变量离开其作用域），lambda 仍然持有它们的引用，但这些引用已经无效。这会导致悬挂引用，进而可能引发未定义行为。

   ```c++
   auto getLambda() {
       int val = 10;
       return [&] { return val; }; // 陷阱: lambda 返回了对局部变量 val 的引用
   }
   ```

2. **this陷阱**: 在类成员函数中创建的 lambda 表达式会隐式捕获 `this` 指针。如果 lambda 生存的时间超过了对象的生命周期，那么对该对象的成员的访问将导致未定义行为。

   ```c++
   class MyClass {
   public:
       int value = 5;
       auto getLambda() {
           return [=] { return value; }; // 隐式捕获 this 指针
       }
   };
   ```

   在这个例子中，尽管 `value` 看起来是被按值捕获的，但实际上是 `this` 指针被捕获，并通过 `this` 指针来访问 `value`。

3. **避免使用默认捕获模式**: "Effective Modern C++" 的条款31建议避免使用默认捕获模式，原因是它可能会导致不清晰或出乎意料的捕获行为。特别是，程序员可能没有意识到他们捕获了 `this` 指针或某些他们原本不想捕获的外部变量。



**lambda应用：**

1. **定制排序**：

   使用`std::sort`对自定义类型进行排序时，可以使用lambda作为比较函数。

   假设你有一个`Person`对象的集合，并且希望基于年龄排序。可以使用lambda来定义排序逻辑：

   ```c++
   struct Person {
       std::string name;
       int age;
   };
   std::vector<Person> people = {{"Alice", 30}, {"Bob", 25}, {"Charlie", 35}};
   std::sort(people.begin(), people.end(), [](const Person &a, const Person &b) {
       return a.age < b.age;
   });
   ```

2. **数据过滤**(查找）：

   使用`std::find_if`查找满足特定条件的元素。

   ```c++
   auto it = std::find_if(numbers.begin(), numbers.end(), [](int n) {
       return n > 5;
   });
   ```

3. **资源管理**：

   假设你想确保在某作用域结束时自动执行一些操作（类似于RAII）。你可以使用lambda与`std::shared_ptr`的自定义析构函数结合来达到这个效果。

   ```c++
   auto cleanup = [](auto *p) {
       // Your custom cleanup code here.
       delete p;
   };
   
   std::shared_ptr<MyResource> resource(new MyResource(), cleanup);
   ```

4. **实现计时器**：

   想要测量某个代码块的运行时间？使用lambda可以很容易地做到。

   ```c++
   auto start = std::chrono::high_resolution_clock::now();
   
   // Code to be timed
   auto task = []() {
       // ... your code here ...
   };
   task();
   
   auto end = std::chrono::high_resolution_clock::now();
   auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
   std::cout << "Task took " << duration << " milliseconds.\n";
   ```

5. **与函数式编程结合**：

   使用lambda表达式可以使C++的代码风格更加函数式。例如，假设你希望将一个整数的集合映射为它们的平方。

   ```c++
    codestd::transform(numbers.begin(), numbers.end(), numbers.begin(), [](int n) {
       return n * n;
   });
   ```

6. **事件处理**：

   如果你正在编写一个需要响应事件的系统，例如GUI或游戏，lambda可以很容易地定义事件处理器。

   ```c++
   button.onClick([]() {
       std::cout << "Button clicked!" << std::endl;
   });
   ```

​    7.**异步编程**： 当使用`std::async`进行异步任务时，可以使用lambda定义任务。

```c++
auto future = std::async(std::launch::async, []() {
    // some asynchronous task
    return "Hello from the future!";
});
```







以下是一些示例：

```c++
int x = 0;
int y = 42;

// 通过值捕获 x 和 y
auto by_value = [=] { return x + y; };

// 通过引用捕获 x 和 y
auto by_reference = [&] { x = 10; return x + y; };

// 通过值捕获 x，通过引用捕获 y
auto mixed_capture = [x, &y] { return x + y; };

std::cout << by_value() << std::endl;         // 输出 42
std::cout << by_reference() << std::endl;     // 输出 52，并修改 x 的值
std::cout << mixed_capture() << std::endl;    // 输出 52
//捕获this的
#include <iostream>

class MyClass {
private:
    int value = 42;

public:
    void printValue() {
        // 使用Lambda捕获this指针
        auto lambda = [this]() {
            std::cout << "Value: " << this->value << std::endl;
        };

        lambda();
    }
};

int main() {
    MyClass obj;
    obj.printValue();  // 输出 "Value: 42"
    return 0;
}

```







lambda表达式=匿名函数

lambda表达式表示一个**可调用的代码单元，没有命名的内联函数**，不需要函数名因为我们直接（一次性的）用它，不需要其他地方调用它。

**lambda表达式的语法**

```c++
[capture list] (parameter list) -> return type {function body}
// [捕获列表] (参数列表) -> 返回类型 {函数体}
// 只有捕获列表和函数体是必选的

auto lam = []() -> int { cout << "Hello"; return 88; }
auto ret = lam();
cout << ret << endl;
```

大部分情况下lambda表达式的返回值可以由编译器得出，所以**不需要显式指定返回值类型**。

```c++
[capture list] (params list) mutable exception-> return type {function body}

```

1. captrue list：捕获**外部变量列表**（必须）

2. params list：形参列表

3. mutable 指示符：用来说明是否可以**修改捕获的变量**

4. exception：异常设定

5. return type：返回类型（可省略）

   （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定；
   （2）：如果function body中没有return语句，则返回值为void类型。

6. function body：函数体



lambda 怎么捕获外部变量

Lambda表达式可以使用**其可见范围内的外部变量**，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。

主要有值捕获、引用捕获和隐式捕获三种。

1、**值捕获**: 值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值，并且不可修改传入的值（如果真的要修改，需要加上 mutable 关键字）。
2、**引用捕获:** 使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&。
3、**隐式捕获:** 还可以让编译器根**据函数体中的代码来推断需要捕获哪些变**量，这种方式称之为隐式捕获
4、**混合方式捕获:** 即同时使用显式捕获和隐式捕获。混合捕获时，捕获列表中的第一个元素必须是 = 或 &，此符号指定了默认捕获的方式是值捕获或引用捕获。



lambda表达式特点(变量捕获)

**（1）变量捕获形式**

1. []不捕获任何变量,这种情况下lambda表达式内部**不能访问外部的变量**
2. [&]以**引用方式**捕获所有外部变量(保证lambda执行时变量存在)
3. [=]用**值的方式**捕获所有外部变量(创建时拷贝,修改对lambda内对象无影响)
4. [=,&foo]以**引用捕获变量foo**,但其余变量都靠值捕获
5. [&,foo]以值捕获foo,但其余变量都靠引用捕获
6. [bar]以值方式捕获bar;不捕获其它变量
7. [this]捕获所在**类的this指针**

**（2）排序**

```c++
int arr[] = {6, 4, 3, 2, 1, 5, 4};
bool compare(int& a, int& b) { //谓词函数
    return a > b;
}
std::sort(arr, arr + 6, compare);

// lambda形式
std::sort(arr, arr + 6, [](const int& a, const int& b) {return a < b});
```



lambda回调用在thread的注意事项

使用到外部引用要小心谨慎，避免悬空引用。
若需要用到的**外部局部变量**，需以**值传递的方式捕获**而非引用捕获（若是外部指针变量则需深拷贝）。
谨慎**使用或者不用外部指针**。
如果用**值捕获了个指针**，在lambda创建的闭包中持有这个指针的拷贝，但你不能阻止lambda外面的代码删除指针指向的内容，从而导致你**拷贝的指针空悬**。
**注意引用捕获陷阱**：**引用捕获[&]不要使用外部局部变量**。
**注意this陷阱：**lambda里避免有全局变量或静态变量或者比**当前类生命周期更长的变量**。Effective Modern C++ 条款31 对于lambda表达式，**避免使用默认捕获模式**。
避免使用默认捕获模式(（即“[=]”或“[&]”,它可能导致你看不出悬空引用问题)。
默认值捕获就意外地捕获了this指针，而不是你以为的外部变量。



lambda 表达式的应用

- `lambda` 匿名函数的定义:

  ```c++
  [capture list] (parameter list) -> return type
  {
  function body;
  };
  ```

  - capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表。定义在与 lambda 函数相同作用域的参数引用也可以被使用，一般被称作 closure（闭包），以下为闭包的常见用法

    ```c++
    []      // 沒有定义任何变量。使用未定义变量会引发错误。
    [x, &y] // x以传值方式传入（默认），y以引用方式传入。
    [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
    [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
    [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
    ```

  - `return type`、`parameter list`、`function body`：分别表示返回值类型、参数列表、函数体，和普通函数一样

值方式捕获注意1

是 lambda 函数按照**值方式捕获的环境中的变量，在 lambda 函数内部是不能修改的，否则编译器会报错**。其值是 lambda 函数定义时捕获的值，不再改变。如果在 lambda 函数定义时加上 **mutable 关键字**，则该捕获的传值变量在 lambda 函数内部是可以修改的，对同一个 lambda 函数的随后调用也会累加影响该捕获的传值变量，但对外部被捕获的那个变量本身无影响

**引用捕获注意2：**

**引用捕获可能带来悬挂引用**常见于使用 lambda 表达式使用引用捕获某个局部变量，而调用 lambda 表达式时，局部变量已经被清理导致捕获的引用指向被清理的内存空间，从而产生悬挂引用。

- **在 `C++ 14` 以后**，`lambda` 函数的**形式参数允许泛型和初始化捕获**。返回值和参数均使用泛型，编译器会根据实际进行类型推导。允许在 `lambda` 捕获列表中对变量进行表达式赋值，并且支持定义新的变量并进行初始化
- **`C++ 17` 以后**，`lambda` 函数也支持使用用 `constexpr` 修饰，此时 `lambda` 函数内部应当满足 `constexpr` 的要求。



#### lamda表达式支持模板吗、有哪些组成、返回类型如何根据其参数进行推导？想指定返回类型，应该怎么做？

 **lambda 表达式和模板**

在C++14之前，lambda表达式本身不能直接支持模板。但从C++14开始，泛型lambdas被引入，允许我们写模板化的lambda表达式。这是通过使用`auto`关键字作为参数类型来实现的。

例如：

```c++
auto generic_lambda = [](auto x) { return x * x; };
```

上面的`generic_lambda`可以用于各种数据类型，如整数、浮点数等。

**lambda 表达式的特性**

1. **闭包**：lambda可以捕获其所在作用域中的变量。这可以通过值（`[=]`）或引用（`[&]`）进行。
2. **默认捕获**：可以使用`[=]`或`[&]`来分别以值或引用的方式捕获所有外部变量。
3. **指定捕获**：例如`[x, &y]`表示捕获`x`（通过值）和`y`（通过引用）。
4. **隐式返回类型**：如果lambda的主体只包含一个返回语句，则返回类型会被自动推导。
5. **泛型**：如前所述，C++14后支持泛型lambdas。

**返回类型推导**

lambda表达式可以根据其主体自动推导返回类型。例如：

```c++
auto lambda = [](int x, int y) { return x + y; }; // 推导为 int
```

**指定返回类型**

如果需要指定lambda表达式的返回类型，可以使用`->`语法：

```c++
auto lambda = [](double x, double y) -> int { return static_cast<int>(x + y); };
```

在上面的例子中，即使`x + y`的结果是`double`，由于我们指定了返回类型为`int`，结果会被转换为整数类型。





### 4种强制类型转换、nullptr与NULL 

**4种强制类型转换：**

**static_cast主要用来基本数据类型的转换，而且没有类型检查，所以向下转换是不安全的，const_cast主要用来去除const属性，reinterpret_cast主要用来将类型转换为指针类型，但是他不安全，因为没有类型检查，（几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用），dynamic_cast主要是用来将类型转换为类指针，类引用，有类型检查，所以向下转换是安全的。**

- **static_cast：**static_cast 是“静态转换”的意思，也即在**编译期间转换**，转换失败的话会抛出一个编译错误。一般用于如下:
  
  - 用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。
  - 用于基本数据类型的转换。
  - 用于**类层次之间的基类和派生类之间指针或者引用的转换**（不要求必须包含虚函数，但必须是有相互联系的类），进行**上行转换**（派生类的指针或引用转换成基类表示）是安全的；进行**下行转换**（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 **dynamic_cast 进行下行转换**。
  - 可以将**空指针**转化成**目标类型的空指针**。
  - 可以将任何类型的表达式转化成 **void 类型**。
  - **不用于在不同类型的指针之间互相转换**，也不能用于**整型和指针之间的互相转换**，当然也不能用于不同类型的引用之间的转换。
- **const_cast：**主要用于 const 与非 const、volatile 与非 volatile 之间的转换。**强制去掉常量属性**，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将**常量指针转化为非常量指针或者将常量引用转化为非常量引用**（注意：表达式的类型和要转化的类型是相同的）。
- **reinterpret_cast：****改变指针或引用的类型**、将指针或引用转换为一个足够长度的整型、**将整型转化为指针或引用类型**。reinterpret_cast 转换时，执行的过程是逐个比特复制的操作。
- **dynamic_cast：**其他三种都是编译时完成的，**动态类型转换是在程序运行时**处理的，运行时会进行**类型检查**。
  - 只能用于**带有虚函数的基类或派生类的指针**或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。
  - 在向上进行转换时，即派生类的指针转换成基类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）
  - 在**下行转换**时，基类的指针类型转化为派生类的指针类型，只有**当要转换的指针指向的对象类型和转化以后的对象类型相同**时，才会转化成功。
  
  

**nullptr与NULL 的优势比较：**

- NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。
- nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。
- 二者相比 nullptr 的优势：
  - **有类型**，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。
  - **函数重载**：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况



### thread_local、RVO 和 NRVO 机制、zero overhead

**thread_local**

有且只有thread_local关键字修饰的变量具有**线程周期**(thread duration)，这些变量(或者说对象）**在线程开始的时候被生成(allocated)，在线程结束的时候被销毁(deallocated)。**

并且每 **一个线程都拥有一个独立的变量实例**(Each thread has its own instance of the object)。**thread_local 可以和static 与 extern关键字联合使用**，这将影响变量的链接属性(to adjust linkage)。

**哪些变量可以被声明为thread_local？**

命名空间下的全局变量
类的static成员变量
本地变量



**RVO 和 NRVO 机制：**

RVO 是**返回值优化**，就是在一个函数内部返回一个匿名对象时，由编译器对这个返回过程进行优化，**直接将匿名对象作为返回值**，避免**函数返回过程中调用拷贝构造函数**的开销。

NRVO 是**具名返回值优化**，函数返回值是一个在函数内部构建的有名对象，同样由编译器对这个返回过程进行优化，直接**将有名作为返回值，避免函数返回过程中调用拷贝构造函数的开销**。

这两个机制用于返回值是**结构体或者类**。





**zero overhead（零开销原则）理解**

1. 不需要为没有使用到的语言特性付出代价。
2. 使用某种语言特性，不会带来运行时的代价。



可调用对象

1. 普通函数
2. 函数指针
3. 仿函数，即重载了operator()运算符的类对象
4. 匿名函数，即 **Lambda表达式**
5. std::function































正则表达式

正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：

| 符号  | 意义                           |
| ----- | ------------------------------ |
| ^     | 匹配行的开头                   |
| $     | 匹配行的结尾                   |
| .     | 匹配任意单个字符               |
| […]   | 匹配[]中的任意一个字符         |
| (…)   | 设定分组                       |
| \     | 转义字符                       |
| \d    | 匹配数字[0-9]                  |
| \D    | \d 取反                        |
| \w    | 匹配字母[a-z]，数字，下划线    |
| \W    | \w 取反                        |
| \s    | 匹配空格                       |
| \S    | \s 取反                        |
| +     | 前面的元素重复1次或多次        |
| *     | 前面的元素重复任意次           |
| ?     | 前面的元素重复0次或1次         |
| {n}   | 前面的元素重复n次              |
| {n,}  | 前面的元素重复至少n次          |
| {n,m} | 前面的元素重复至少n次，至多m次 |
| \|    | 逻辑或                         |



### enum class的原因 、enum struct 和 enum

**引入enum class的原因**

1、C++98 的 enum 是“非域化的”；而 C++11 的 enum class 是“域化的”，**限制了枚举成员只在域内可见**。
2、enum class 的**缺省潜在类型** (underlying type) 是 **int 型**，而 enum 没有缺省潜在类型。
3、enum class 一般总是**前置声明**，而 enum 只有在指定了**潜在类型时才可以是前置声明**。



枚举类型(enumeration)使我们可以将一组整型常量组织在一起。每个枚举类型定义了一种新的类型。枚举属于**字面值常量类型**。

- enum class 、enum struct 

  有更好的**类型安全和封装的特性**。

  1. 与**整形之间不会发生隐式类型转换**，除非用static_cast强制转换
  2. 可以指定**底层的数据类型**，默认是int
  3. 需要通过**域运算符来访问枚举成员**

- 旧版本enum存在的问题

  1. 没有非常**完全的类型安全**。即**不同枚举之间不能赋值**，同时整形不能向枚举类型转换，但是枚举可以向整形转。
  2. 无法确定数据的类型，导致无法明确枚举类型所占用的内存大小。
  3. 枚举中的成员可以在括号外部直接访问，而不需要使用域运算符。

  



C++ 的闭包

闭包：与函数A调用函数B相比较，**闭包中函数A调用函数B**，可以不通过函数A给函数B传递函数参数，而使函数B可以访问函数A的上下文环境才可见(函数A可直接访问到)的变量；
c++11提供的闭包方式：**lambda、function、bind**

闭包是指可以包含**自由（未绑定到特定对象）变量的代码块**；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是**在定义代码块的环境中定义**（局部变量）。

“闭包” 一词来源于以下两者的结合：

**要执行的代码块（**由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）

**和为自由变量提供绑定的计算环境（作用域）**。



C++ 的垃圾回收机制

很多语言都有对**内存自动管理，即所谓的垃圾回收机制**。所谓垃圾，指的是**那些不再使用或者没有任何指针指向的内存空间**，而“回收”则指的是将**这些“垃圾”收集起来以便再次利用。**

C++采用 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来**实现堆内存的自动回收。来实现自动释放分配的内存**。





### C++14和C++11区别、引入make_unique，解决哪些问题

1. 通用Lambda表达式：
   - C++14中，Lambda表达式的形式得到了改进，**允许使用auto关键字来捕获变量**，从而使得Lambda表达式更加通用和灵活。
2. **泛型Lambda**：
   - C++14允许Lambda**表达式内部使用auto关键字作为函数参数类型**，使得编写更通用的Lambda表达式变得更容易。
3. 初始化列表的返回类型推导：
   - 在C++14中，允许使用**auto关键字来推导返回类型为std::initializer_list的函数**。
4. 泛型的Lambda**捕获初始化**：
   - C++14允许在Lambda表达式的**捕获列表中使用初始化器**，用于对捕获的变量进行初始化。
5. **std::make_unique：**
   - **C++14引入了std::make_unique函数，用于创建std::unique_ptr对象，类似于std::make_shared**。
6. 常量表达式函数成员：
   - 在C++14中，允许将**成员函数标记为constexpr**，使其能够在编译期间进行计算。

**C++14引入make_unique，解决哪些问题**

在 C++11 中，引入了 `std::shared_ptr` 和 `std::unique_ptr` 用于管理动态分配的资源，分别支持共享所有权和独占所有权的语义。然而，在 **C++11 中缺少了一个对应的 `std::make_unique` 函数**，用于创建 `std::unique_ptr`，这导致使用 `std::unique_ptr` 时**不够方便。**

为了解决这个问题，**C++14 引入了 `std::make_unique`，用于创建 `std::unique_ptr` 对象**。`std::make_unique` 解决了以下问题：

1. 简化语法：在 C++11 中，要使用 `std::unique_ptr` 创建对象，需要通过 `new` 关键字显式地分配内存，并将结果传递给 `std::unique_ptr` 构造函数。这使得语法较为繁琐，也增加了出错的可能性。而 `std::make_unique` 可以更简洁地创建 `std::unique_ptr` 对象，只需传递构造参数即可。
2. **避免资源泄漏：使用 `std::make_unique` 可以避免因为`new` 分配内存成功后，但在创建 `std::unique_ptr` 时过早抛出异常而导致之后的资源泄漏。`std::make_unique` 保证内存的自动释放，即使在创建 `std::unique_ptr` 时发生异常。**



### C++ 14、C++ 17 新特性

**C++ 14新特性**

1. 通用Lambda表达式：
   - C++14中，Lambda表达式的形式得到了改进，允许使用**auto关键字来捕获变量**，从而使得Lambda表达式更加通用和灵活。
2. 泛型Lambda：
   - C++14允许Lambda**表达式内部使用auto关键字作为函数参数类型**，使得编写更通用的Lambda表达式变得更容易。
3. **初始化列表的返回类型推导**：
   - 在C++14中，允许使用**auto关键字来推导返回类型为std::initializer_list的函数**。
4. 泛型的Lambda捕获初始化：
   - C++14允许在Lambda**表达式的捕获列表中使用初始化器**，用于对**捕获的变量进行初始化**。
5. std::make_unique：
   - C++ 11 中有 std::make_shared，却没有std::make_unique，C++14引入了std::make_unique函数，用于创建**std::unique_ptr对象**
6. **常量表达式函数成员**：
   - 在C++14中，允许将成员函数标记为constexpr，使其能够在**编译期间进行计算**。



**函数返回值类型推导:**

也可以用 `auto` 类型，编译时会有编译器进行类型推导。

- 函数内如果有多个 return 语句，它们必须返回相同的类型，否则编译失败。
- 如果 return 语句**返回初始化列表，返回值类型推导**也会失败。
- 如果函数是**虚函数**，不能使用**返回值类型推导**。
- 返回类型推导可以用在递归函数中，但是**递归调用必须以至少一个返回语句作为先导**，以便编译器推导出返回类型。
- 在 C++ 14 中，**lambda 函数的形式参数允许泛型**

**`Lambda` 初始化捕获:** 

允许在 `lambda` **捕获列表**中对**变量进行表达式赋值**，并且支持定义新的变量并进行初始化

**constexpr 函数限制变动:**

常量表达式函数成员：

- 在C++14中，允许将**成员函数标记为constexpr**，使其能够在**编译期间**进行计算。
- C++ 11 中 constexpr 函数**只含有一个将被返回的表达式**，C++ 14 放松了这些限制：

- 除了 **static 或 thread_local 变量** 以外，可以声明新的变量，且**声明的变量必须初始化**
- 可以包含条件分支语句 if 和 switch。
- 可以包含所有的循环语句，包括**基于范围的for循环**。
- 表达式可以**改变一个对象的值**，只需该对象的生命期在声明为 constexpr 的函数内部开始

**共享的互斥体和锁:** 

C++ 14 增加了一类**共享的互斥体和相应的共享锁**，通过使用 std::shared_timed_mutex 和 std::shared_lock 来进**行线程同步**。



**C++ 17 新特性：**

- **结构化绑定**，利用该特性可以把以 `C++` 中的 `pair`，`tuple`，`array`，`struct` 的成员赋值给多个变量

  ```c++
  auto [x, y, z] = std::make_tuple(1, 2.3, "456");
  ```

- `if**-switch` 语句初始化**:  `if` 语句可以支持 `if (init; condition)` 写法，即在判断条件中对变量进行初始化

- **constexpr lambda 表达式**: C++ 17 前 lambda 表达式**只能在运行时使用**，C++ 17 引入了 constexpr lambda 表达式，可以用于在**编译期进行计算**

- `namespace` 嵌套:**`C++ 17` 支持命名空间嵌套**

- `std::any`：增加了 **`any` 可以存储任何类型**，可以将其转化为任意类型。













# C++内存相关======================



## 内存泄漏、怎么处理、怎么排查

内存泄漏是指程序中已分配的内存没有被释放，并且在程序的未来运行中无法被访问或释放的情况。随着时间的推移，这可能导致程序使用的内存不断增加，从而可能导致系统的性能下降甚至崩溃。

**怎么处理？**

1. **编码习惯**：**避免泄漏的最佳策略是养成良好的编码习惯。确保每次使用`malloc`, `calloc`, `new`等分配内存的时候都有对应的`free`或`delete`来释放内存。**
   - 一定要将基类的析构函数声明为**虚函数**

   - 对象数组的释放一定要用**delete []**

   - 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
2. **使用智能指针**（仅限于C++）：例如`std::shared_ptr`和`std::unique_ptr`，它们会在不再需要时自动释放内存。
3. **内存管理策略**：例如使用对象池，避免频繁的内存分配和释放，这不仅可以提高效率，还可以减少泄漏的机会。

**怎么排查？**

1. **使用工具**：
   - **Valgrind**：这是一个Linux上的工具，它可以检测内存泄漏、未初始化的内存访问等问题。最常用的子工具是`memcheck`。
   - **AddressSanitizer**：这是由LLVM/Clang提供的工具，也被GCC采用。它可以在运行时检测内存错误。
   - **LeakSanitizer**：也是由LLVM提供的，专门用于检测内存泄漏。
   - **Visual Studio**：在Windows上，Visual Studio提供了内存泄漏检测功能。
2. **代码审查**：定期进行代码审查可以帮助发现可能的内存泄漏，并且，其他开发者的新鲜视角可能会看到你可能忽略的问题。
3. **引入RAII（Resource Acquisition Is Initialization）原则**：这是C++的一个原则，意思是对象的生命周期管理其资源（如内存、文件句柄等）的生命周期。确保资源在对象的构造函数中获取，并在析构函数中释放，从而避免内存泄漏。
4. **日志与追踪**：在关键的内存分配和释放地方添加日志，可以帮助追踪和确认内存使用情况。
5. **引入断言**：使用断言来确保预期的内存释放确实发生了。



## **内存泄漏的场景、检测原理、防止内存泄漏**

**内存泄漏的场景：**

- **malloc和free未成对出现；new/new []和delete/delete []未成对出现；**

  - 在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放：

  ```cpp
  char* getMemory() {
      char *p = (char *)malloc(30);
      return p;
  }
  int main() {
      char *p = getMemory();
      return 0;
  }
  ```

  - 在构造函数中动态分配内存，但未在析构函数中正确释放内存；

- **未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；**比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，**使得两个对象包含指向同一内存空间的指针**，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的；

- **没有将基类的析构函数定义为虚函数**。

**判断和定位内存泄漏的方法**：

在Linux系统下，可以使用valgrind、mtrace等内存泄漏检测工具。



**内存泄漏的检测原理：**

- 检测内存泄漏的关键是要能**截获住对分配内存和释放内存的函数的调用**。截获住这两个函数，我们就能**跟踪每一块内存的生命周期**，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当程序结束的时候，**list中剩余的指针就是指向那些没有被释放的内存**。
- 如果要**检测堆内存的泄漏**，那么需要**截获住malloc / realloc / free和new/delete**就可以了。对于其他的泄漏，可以采用类似的方法，**截获住相应的分配和释放函数**
- 要想**检测内存泄漏**，就必须对**程序中的内存分配和释放情况进行记录**，所能够采取的办法就是**重载所有形式的operator new 和 operator delete**，截**获 new operator 和 delete operator 执行过程中的内存操作信息**。
- **内存泄漏主要指**堆上分配的变量，因为栈中分配的变量，随着函数退出时会自动回收。**而堆是动态分配的，一旦用户申请了内存分配而没及时释放，那么该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存**。



**如何防止内存泄漏：**

将**内存的分配封装在类**中，**构造函数分配内存，析构函数释放内存**；使用智能指针

- **内部封装：**将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存；但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况:

  ```C++
  void fun1()
  {
      A ex(100);
      A ex1 = ex; 
      char *p = ex.GetPointer();
      strcpy(p, "Test");
      cout << p << endl;
  }
  ```

  对于 fun1 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间。但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过增加计数机制来避免这种情况

- **使用智能指针：**智能指针是 C++ 中已经对内存泄漏封装好了一个工具，智能指针对象会**自动释放所申请的内存**

- 良好的编码习惯：**良好的编码习惯**可以有效的避免内存泄漏的问题，内存申请和释放要一一对应：

  - **在 C++ 中需要将基类的析构函数定义为虚函数；**
  - **遵循 RAII（Resource acquisition is initialization）原则：在对象构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源；**
  - **尽量使用智能指针；**
  - **有效引入内存检测工具；**









**内存泄漏有哪几种？**

**（1）堆内存泄漏（Heap leak）**

没有正确释放malloc、realloc、new等从堆中分配的内存。

如：

1、类的构造函数和析构函数中new和delete没有配套
2、在释放对象数组时没有使用delete[]，使用了delete

**（2）系统资源泄露（Resource Leak）**

主要指程序使用系统分配的资源比如**Bitmap, handle, SOCKET**等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

**（3）没有将基类的析构函数定义为虚函数**

当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。



**内存泄漏导致的问题：**

由于内存未得到及时释放，从而可能导致可使用的动态**内存空间会越来越少，一旦内存空间全部使用完，则程序可能会导致因为内存不够中止运行**。由于内存泄漏导致的问题比较严重，现在许多语言都带有 GC 程序会自动对不使用的内存进行回收，从而避免内存泄漏。

**如何检测内存泄漏？**

1. 自己写一个**内存检测工具**，定位内存分配的位置，覆盖operator new和operator delete这种弱符号函数

   ```c++
   #define new new (__FILE__, __LINE__)
   void* operator new(std::size_t size, const char* file, int line);
   void* operator new[](std::size_t size, const char* file, int line);
   ```

2. 使用内存检测工具**valgrind、mtrace**等

**内存泄漏检测与预防：**

- 对于 C/C++ 没有 GC 程序的语言来说因为内存造成的问题较多，当然一般情况下如果存在严重的内存泄漏，通过查看内存使用统计即可检测到内存泄漏，但是细小的内存泄漏很难通过统计观察到，目前一般都是**利用各种内存检测工具**来检测内存泄漏，当然关键还是**在于统计和分析申请和释放的相关日志**。**内存检测工具有很多比如valgrind**等











## 内存对齐定义、原因、原则、问题、应用场景

**什么是内存对齐：**

**内存对齐是按照结构体里最大的基本数据类型对齐的，所以整个结构体的大小应该是最大的基本数据类型的整数倍**

指的是**内存中数据的首地址是CPU单次获取数据大小的整数倍**

计算机中内存空间是按照 byte 来划分划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：**在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置进行限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。**编译器将程序中的**每个 数据单元 的地址**安排在机器字的**整数倍的地址指向的内存**之中。



**为什么要内存对齐：**

主要是**由于 CPU 的访问内存的特性决定**，CPU 访问内存时并不是以字节为单位来读取内存，而是**以机器字长为单位，由 CPU 的数据总线的宽度来决定的**。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 一次可以读取和写入数据总线宽度的数据。比如 32 位的 CPU，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。这么设计的目的是**为了减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量**。假设读取 8 个字节的数据，按照每次读取 4 个字节的速度，则 8 个字节需要 CPU 耗费 2 次读取操作。**CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数**。

除了能够**减少内存访问次数**，**增加内存读取的吞吐量**以外，还有其他原因：

- 比如**某些特定的硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常**，比如对于 CPU 中 SIMD 指令，则必须要求内存严格对齐；
- **每次内存访问是原子的**，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的。某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作，因此此时 CPU 需要可能需要读取多次内存，这样就破坏了变量的原子性；
- 相比于**存取对齐的数据，存取非对齐的数据需要花费更多的时间，提高内存的访问效率**，因为 CPU 在读取内存时，是一块一块的读取；
- 某些处理器虽然**支持非对齐数据的访问**，但会引发对齐陷阱（alignment trap）；
- 某些硬件设备**只支持简单数据指令非对齐存取**，不支持复杂数据指令的非对齐存取。



**内存对齐的原则：**

- 实际的内存对齐处理都是由**编译器**来处理，编译器会**自动在内存之间填充字节**。

- 结构体变量**对齐的基本规则**：

  - **结构体变量的首地址**能够被其**最宽基本类型成员大小与对齐基数中的较小者**所整除；
  - 结构体中的 **static 成员变量**不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域；
  - **结构体每个成员相对于结构体首地址的偏移量 （offset）** 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；
  - **结构体的总大小**为结构体最宽基本类型成员大小与**对齐基数中的较小者**的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）；

- 在**某些特定场景下需要指定结构体内存进行对齐**，比如**在发送特定网络协议报文、硬件协议控制、消息传递、硬件寄存器访问**时，这时就就**需要避免内存对齐**，因为双方均按照预先定义的消息格式来进行交互，从而**避免不同的硬件平台造成的差异**，同时能够将双方传递的数据进行空间压缩，避免不必要的空间浪费。可以用 **`#progma pack(x)` 指定结构体以 x 为单位进行对齐**

  

**结构体内存对齐问题：**

- 结构体内成员按照**声明顺序存储**，第一个**成员地址和整个结构体地址**相同。
- 未特殊说明时，按**结构体中size最大的成员对齐**（若有double成员，按8字节对齐。）

c++11以后引入两个关键字 `alignas`与 `[alignof]`。其中**`alignof`可以计算出类型的对齐方式**，**`alignas`可以指定结构体的对齐方式**。



**应用场景：**

内存对齐应用于三种数据类型中：**struct/class/union**

- **数据成员对齐规则**：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
- **结构体作为成员**:如果一个结构里有某些结构体成员,则结构体成员要从其内部"**最宽基本类型成员**"的**整数倍地址开始存储**。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
- **收尾工作:**结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"**最宽基本类型成员**"的整数倍。**不足的要补齐**。(基本类型不包括struct/class/uinon)。
- sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

1. **取消对齐**

   使用 `__attribute__((packed))` 关键字，让编译器取消对齐优化



1. **32位系统**：
   - `char`：1字节
   - `short`：2字节
   - `int`：4字节 (常见值，但并不是固定的)
   - `long`：4字节 (在大多数32位系统上)
   - `long long`：8字节
   - `float`：4字节
   - `double`：8字节
   - `指针`：4字节（因为32位地址总线宽度）
2. **64位系统**：
   - `char`：1字节
   - `short`：2字节
   - `int`：4字节 (这通常在大多数64位系统上都是这样，但并不是固定的)
   - `long`：8字节 (在许多64位Unix-like系统上，如Linux和macOS)
   - `long`：4字节 (在Windows的64位系统上)
   - `long long`：8字节
   - `float`：4字节
   - `double`：8字节
   - `指针`：8字节（因为64位地址总线宽度）





##  内存分区、分配方式、静动态分配区别

**内存分区：**

C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：**栈、堆、全局/静态存储区、常量存储区、代码区**。

- **栈**：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的局部变量、函数参数、返回地址等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，**操作系统才会对栈空间进行回收**。
- **堆：**动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。
- **全局区/静态存储区：**主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- **常量存储区：**.rodata 段，存放的是常量，不允许修改，程序运行结束自动释放。
- **代码区：**.text 段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。
- 从操作系统的本身来讲，以上存储区在该程序内存中的虚拟地址分布是如下形式（虚拟地址从低地址到高地址，实际的物理地址可能是随机的）： .text→.data→.bss→heap→unused→stack→⋯



**内存分配方式有几种:**

**（1）从静态存储区分配**

内存在程序**编译**的时候就已经分配好，这块内存在程序的整个运行期间都存在，如全局变量，static变量。

**（2）在栈上创建**

在执行函数时，函数内**局部变量的存储单元**都可以在栈上创建，函数执行结束时这些存储单元自动被释放。**栈内存分配运算内置于处理器的指令集中**，效率很高，但是分配的内存容量有限。

**（3）从堆上分配（动态内存分配）**

程序在运行的时候用malloc或new申请任意多少的内存，程序员负责在何时用free或delete释放内存。动态内存的生存期自己决定，使用非常灵活。

- 从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价
- 从常量存储区分配：特殊的存储区，存放的是常量，不可修改；



**静态、动态内存分配的区别**

- 静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；
- 静态内存分配是在**栈**上分配的；动态内存分配是在**堆**上分配的；
- 静态内存分配**不需要指针或引用类型**的支持；动态内存分配需要；
- 静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；
- 静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；
- 静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。



### 类只堆，栈上分配内存、ELF 文件

**类只堆，栈上分配内存：**

- 只能在堆上分配内存：将**析构函数声明为`private`**；
- 只能在栈上生成对象：**将`new`和`delete`重载为`private`**。

**ELF 文件：**

可执行与可链接格式 (Executable and Linkable Format) 是一种用于**可执行文件、目标代码、共享库**和**核心转储 （core dump）** 的标准文件格式，每个 ELF 文件都由一个 **ELF header 和紧跟其后的文件数据部分**组成，可执行程序内部都是**分段进行存储**的，ELF 文件的构成如下:

- .rodatasection：**只读数据段**。此段的数据不可修改，存放程序中会使用的常量。比如程序中的常量字符串"aasdasdaaasdasd"。
- .text section：**代码段**。通常存放已编译程序的机器代码，一般操作系统加载后，这部分是只读的。
- .datasection：**数据段**。主要用于存放已初始化的全局变量、常量。
- .bsssection: **bss 段**。该段主要存储未初始化全局变量，仅是占位符，不占据任何实际磁盘空间。目标文件格式区分初始化和非初始化是为了空间效率。

操作系统在加载 ELF 文件时会将按照**标准依次读取每个段中的内容**，并**将其加载到内存**中，同时为**该进程分配栈空间**，并将 **pc 寄存器指向代码段的起始位置**，然后启动进程



## new 与malloc 底层实现原理、new 不抛出异常

1. new是操作符，而malloc是函数。
2. new在调用的时候**先分配内存**，在**调用构造函数**，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
3. malloc需要**给定申请**内存的大小，返回的指针需要强转；new会调用构造函数，**不用指定内存的大小**，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

**malloc底层实现：**当开辟的空间小于 128K 时，调用 `brk()` 函数；当开辟的空间大于 128K 时，调用 `mmap()`。malloc采用的是**内存池**的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用**隐式链表**将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：**new关键字在底层调用的是**operator new**：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空间不足的应对措施，如果该应对措施用户设置了，则继续申请，否则抛异常。

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

**如何让 new 不抛出异常？**

1. 使用 `new(std::nothrow)` 关键字，当 new 一个对象失败时，默认设置对象为 NULL。

2. 通过 `set_new_handler(noMoreMemory);` 让 new 抛出异常时，执行程序给定的handler。一般来说 handler 只有两个选择：

   - 让更多memory可用（调用了程序员指定的handler，表示内存基本用完了，程序员可以选择释放一些其他的内存，C++会再次尝试new）
   - 调用 abort() 或 exit()

   

###  free /delete 区别、new/delete和malloc/free区别

**free /delete 的区别：**

- delete 是 C++ 中的一个操作符，可以进行重载；而 free 是 C 中的一个函数，不能进行重载；

- free 只会释放指向的内存，不会执行对象的析构函数；delete 则可以执行对象的析构函数；

- **free 释放** heap 中申请的动态内存空间，只能释放 malloc，calloc，realloc 申请的内存。

  - free 函数只是将参数指针指向的内存归还给操作系统，并不会把参数指针置 NULL，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 free 之后，通常需要手动将指针置 NULL。
  - 内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 free 函数是没有能力去真正的 free 内存的，只是向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存。

- **delete 是** C++ 中的一个操作符，如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 operator delete 的标准库函数来释放所占的内存空间。

  - delete 用来释放单个对象所占的空间，只会调用一次析构函数；
  - delete [] 用来释放数组空间，会对数组中的每个元素都调用一次析构函数。
  - delete 只能用来释放 new 操作返回的指针，否则会产生不可预知的后果。

  

**new/delete和malloc/free的区别：**

```cpp
int *p = new int[2];
int *q = (int *)malloc(2*sizeof(int));
```

- new与delete直接带具体类型的指针，malloc和free返回void类型的指针。
- **new类型是安全的，**而malloc不是。例如int *p = new float[2];就会报错；而int p = malloc(2sizeof(int))编译时编译器就无法指出错误来。
- new一般分为两步：**new操作和构造**。new操作对应与malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。
- new**调用构造函数，malloc不能**；delete调用析构函数，而free不能。
- malloc/free需要库文件stdlib.h的支持，new/delete则不需要！

**「注意」**：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。



**delete与delete []的区别：**

- 对于自定义类型来说，就需要对于**单个对象使用delete**，对于**对象数组使用delete []**，逐个调用数组中对象的析构函数，从而释放所有内存；如果反过来使用，即对于单个对象使用`delete []`，对于对象数组使用`delete`，其行为是未定义的；

- 对于简单类型来说，使用new分配后，不管是数组数组还是非数组形式，两种方式都可以释放内存：

  ```cpp
  int *a = new int(1);
  delete a;
  int *b = new int(2);
  delete [] b;
  int *c = new int[11];
  delete c;
  int *d = new int[12];
  delete [] d;
  ```

- 所以，最恰当的方式就是如果用了`new`，就用`delete`；如果用了`new []`，就用`delete []`。



**内存块太小malloc和new返回空指针：**

- 对于malloc来说，需要判断其是否返回空指针，如果是则马上用return语句终止该函数或者exit终止该程序；

- 对于**`new`来说，默认抛出异常，所以可以使用`try...catch...`代码块的方式**：

  ```cpp
  try {
    int *ptr = new int[10000000];
  } catch(bad_alloc &memExp) {
    cerr << memExp.what() << endl;
  }
  ```

  还可**使用`set_new_handler`函数的方式**：

  ```cpp
  void no_more_memory() {
    cerr << "Unable to satisfy request for memory" << endl;
    abort();
  }
  int main() {
    set_new_handler(no_more_memory);
    int *ptr = new int[10000000];
  }
  ```

  在这种方式里，如果**`new`不能满足内存分配请求，`no_more_memory`会被反复调用**，所以`new_handler`函数必须完成以下事情：

  - 让更**多内存可被使用：可以在程序一开始执行就分配一大块内存**，之后当`new_handler`第一次被调用，就将这些内存释放还给程序使用；
  - 使用另一个`new_handler`；
  - 卸除`new_handler`：返回空指针，这样`new`就会抛出异常；
  - 直接抛出`bad_alloc`异常；
  - 调用`abort`或`exit`。
  
  

**malloc申请内存用delete释放？new用free**

不能。

malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。malloc /free的操作对象都是必须明确大小的。

而且不能用在动态类上。**new 和delete会自动进行类型检查和，也不需要自己明确内存大小**，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。



## 堆和栈的区别、原理、优缺点、效率对比、栈溢出避免

**堆和栈的区别：**

|                  |                              堆                              |                              栈                              |
| ---------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **管理方式**     |         堆中资源由程序员控制（容易产生memory leak）          |             栈资源由编译器自动管理，无需手工控制             |
| **内存管理机制** | 系统有一个**记录空闲内存地址的链表**，当系统收到程序申请时，遍历该链表，**寻找第一个空间大于申请空间的堆结点**，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。 |
| **空间大小**     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 |        栈是一块连续的内存区域，大小是操作系统预定好的        |
| **碎片问题**     |    对于堆，频繁的new/delete会造成大量碎片，使程序效率降低    | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片 |
| **生长方向**     |                  堆向上，向高地址方向增长。                  |                  栈向下，向低地址方向增长。                  |
| **分配方式**     |              堆都是动态分配（没有静态分配的堆）              | 栈有**静态分配和动态分配**，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
| **分配效率**     |  堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。   | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，**分配专门寄存器存放栈地址**，栈操作有专门指令。 |



**堆和栈的原理：**

栈：每次在调用函数时，会按照从**右向左的顺序依次将函数调用参数压入到栈中**，并**在栈中压入返回地址与当前的栈帧**，然后跳转到调用函数内部，pc 跳转函数内部执行该函数的指令；

堆：当程序在运行时，需要**动态申请额外的内存**来存放相应的数据和变量，此时就需要用到堆。堆的内存空间一般由操作系统或者专门内存程序来管理的。在 C/C++ 一般用 malloc 或者 new 来从堆中申请内存，使用 free 或者 delete 来释放空间，空间释放后会有**操作系统**进行回收。



**堆与栈的优缺点：**

- 申请方式：**栈中存放的变量在编译时由编译器为其在栈上分配了空间**，即程序编译后该变量在栈中使用的内存即确定，释放时也由于函数调用的返回，栈的空间会自动进行回收。**堆中存放的变量由程序运行时决定的**，会有操作系统或者内存管理模块来进行分配的。
- 申请后系统响应：
  - **分配栈空间时如果剩余空间大于申请空间则分配成功**，否则分配失败栈溢出，绝大多数情况下，栈的空间较小，一般栈上分配的变量不会占用太大的空间，且当函数返回时，当前栈帧中的变量生存周期会结束；
  - **申请堆空间，堆在内存中呈现的方式类似于链表**（记录空闲地址空间的链表），在链表上寻找**第一个大于申请空间的节点分配给程序**，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上，堆上可以分配较大的空间，**如果不进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出**
  - **栈在内存中是连续的一块空间**（向低地址扩展）最大容量是系统预定好的，且只能被当前的线程访问；**堆在内存中的空间**（向高地址扩展）是不连续的，中间允许有间隔，堆中的内存并**不是线程安全的，同一进程的线程都都可访问**。
- 申请效率：**栈是有系统自动分配，申请效率高**，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
- 存放的内容：栈中存放的是**局部变量**，函数的参数；堆中存放的内容由程序员控制。



**堆和栈的效率对比**

因为操作系统会在**底层对栈**提供支持，会分配**专门的寄存器存放栈的地址**，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且**获取堆的内容需要两次访问**，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。



**栈溢出？如何避免？**

栈溢出是指程序在使用栈的过程中，由于存储需求超过了栈的大小限制，导致数据溢出到栈的边界之外。当栈溢出发生时，可能会覆盖并破坏其他内存区域的数据，结果往往是导致程序崩溃或者产生未定义的行为。

以下是一些常见的导致栈溢出的原因：

1. **递归太深**：在函数递归调用过程中，每次调用都会将返回地址和局部变量压入栈中，如果递归深度过大，会导致栈空间被用尽。
2. **过大的局部变量**：如果函数中定义了过大的局部变量（如**大数组**），也可能导致栈空间不足。

**避免栈溢出**的方法包括：

1. **限制递归深度**：在编写递归函数时，注意设置递归的终止条件，并且避免递归深度过深。
2. **避免过大的局部变量**：如果需要使用大量内存，应考虑使用动态内存分配（如 `new` 或 `malloc`），将数据存储在堆中，而不是栈中。
3. **使用尾递归**：尾递归是一种特殊的递归形式，如果编译器支持尾递归优化，那么它将不会增加额外的栈深度。
4. **增加栈的大小**：在一些情况下，你可能需要增加程序的栈大小。这通常可以在编译时或运行时设置，具体方法取决于操作系统和编译器。
5. **使用迭代而不是递归**：在可能的情况下，考虑使用循环（迭代）而不是递归，因为迭代通常不会增加栈的使用。



栈和队列的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是 “后进先出”。

**堆和自由存储区的区别：**

- 堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。
- 而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的**C++编译器默认使用堆来实现自由存储**，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确







## 变量作用域与生存周期定义、全局变量不在头文件定义：

`C/C++` 变量有两个非常重要的属性：**作用域与生命周期**，这两个属性代表从时间和空间两个不同的维度来描述一个变量

**作用域：**

作用域即一个变量可以被引用的范围，常见的作用域可分为 6 种：**全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域**。

- **全局变量**：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。
- **静态全局变量**：具有**文件作用域**。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 **static 关键字修饰过的变量具有文件作用域**。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
- **局部变量**：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回，局部变量对于函数外部的程序来说是不可见的。当然内部实际更复杂，实际是以 {} 为作用域的。
- **静态局部变量**：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见, 只有定义该变量的函数内部可以使用访问和修改该变量。

**生命周期：**

生命周期即该变量可以被引用的时间段（生存期表示变量存在的时间）。

- **全局变量与局部全局变量**: 全局变量在整个程序运行期间都会一直存在，都可以随时访问，当程序结束时，对应的变量则会自动销毁，内存会被系统回收。
- **局部变量**: 局部变量的生命周期仅限于函数被调用期间，当函数调用结束时，该变量会自动销毁。
- **静态局部变量：**实际上静态局部变量的作用域仅限于**函数内部**，它的作用域与局部变量相同，但实际上该变量在程序运行期间是一直存在的，**生命周期贯穿于整个程序运行期间**。局部静态变量只能被初始化一次。


- **从分配内存空间看：**不同生命周期的变量，在程序内存中的分布位置是不一样的。程序的内存分为**代码区（.text）、全局数据区（.data，.bss，.rodata）、堆区（heap）、栈区（stack），不同的内存区域，对应不同的生命周期**
  - **静态变量**一般存储在数据段，包括 **data 段、bss 段、rodata 段**，其中data 存储已经初始化的静态变量和全局变量，bss 存储未初始化的静态变量与全局变量。静态变量包括全局变量，局部全局变量，静态局部变量。
  - 局部变量一般存储在栈区或者堆区。
  
  

**全局变量不在头文件定义：**

如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为**重复定义而报错**，因此不能再头文件中定义全局变量。一般情况下我们将**变量的定义放在 .cpp** 文件中，一般在 **.h 文件使用extern** 对变量进行声明。





### 静态变量和栈、堆、全局变量的区别：

**静态变量**会被放在程序的**静态数据存储区**（.data 段，bss 段，rodata 段）中（静态变量会自动初始化），这样可以在**下一次调用的时候还可以保持原来的赋值**。

而**栈变量或堆变量**不能保证在下一次调用的时候依然保持原来的值。



**静态变量和全局变量的区别：**

静态变量仅在**变量的作用范围内可见**，实际是依靠编译器来控制作用域。

全局变量在**整个程序范围内都可可见**，只需声明该全局变量，即可使用。



## 大小端、内存屏障、原子操作、无锁队列

**大端与小端：**

- **字节序**又称**端序或尾序**，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。

  - **小端**：将**低序字节**存储在**起始地址（低位编址）**，在**变量指针转换**的时候地址保持不变，比如 int64* 转到 int32*
  - **大端**：将**高序字节**存储在**起始地址**（高位编址），网络字节序统一规定采用 Big-Endian。

- **检测字节序:**
  一般情况下我们直接调用宏定义 **__BYTE_ORDER 即可，可以通过引用 <bits/endian.h>** 即可。也可以编写程序来判断当前的字节序

  ```C
  bool byteorder_check() {
      int a = 1;
      return (*(char *)&a); // 1 为小端机，0 为大端机 
  }
  ```

- **字节序转换:**

  在程序中字节序转换时，将**高位与低位依次进行交换**即可完成

  常用的网络字节序转换函数:

  ```c++
  ntohl(uint32 x)       // uint32 类型 网络序转主机序
  htonl(uint32 x)       // uint32 类型 主机序转网络序
  ntohs(uint16 x)       // uint16 类型 网络序转主机序
  htons(uint16 x)       // uint16 类型 主机序转网络序
  ```

**如何检测：**

**直接读取存放在内存中的⼗六进制数值，取低位进⾏值判断**

```c++
int a = 0x12345678;
int *c = &a;
c[0] == 0x12 ⼤端模式
c[0] == 0x78 ⼩段模式
```

**⽤共同体来进⾏判断**

union 共同体所有数据成员是共享⼀段内存的，后写⼊的成员数据将覆盖之前的成员数据，成员数据都有相同的⾸地址。Union 的⼤⼩为最⼤数据成员的⼤⼩。

union 的成员数据共⽤内存，并且⾸地址都是低地址⾸字节。Int i= 1时：⼤端存储1放在最⾼位，⼩端存储1放在最低位。当读取char ch时，是最低地址⾸字节，⼤⼩端会显示不同的值。





**内存屏障作用：**

**内存栅栏**，是一种**编程指令或语义**，用于在**多线程编程中控制内存访问的顺序和可见性**。

**内存屏障的作用：**

内存屏障是在多线程编程中用于**控制内存访问顺序和可见性**的重要工具。通过**插入内存屏障**，可以**防止指令重排序**，并确保对共享变量的修改在其他线程中可见，从而避免常见的并发问题。

在C++中，内存屏障通常通过使用特殊的**内置函数或编译器指令**来实现。在C++11之后，引入了**`std::atomic`库**，提供了跨平台的内存屏障支持。

1. **作用：**
   - **禁止重排序：**内存屏障可以防止**编译器和处理器对屏障前后的指令进行重排序**，保证指令的执行顺序。
   - **提供内存可见性**：内存屏障可以确保在屏障前的写操作对其他线程可见，保证内存的一致性。
2. **使用方式（C++）**： 在C++中，可以使用**`std::atomic_thread_fence()`函数**来插入内存屏障。

- **优化屏障：保证在操作原语之前的指令不会被优化到任何出现在操作原语之后的指令的后面。**

- **保证CPU执行时原语操作之前的指令在原语之后的指令前完成。**

```c++
#include <atomic>
std::atomic<int> shared_var;
void Thread1() {
    shared_var.store(42, std::memory_order_relaxed);  // Write to shared variable
   std::atomic_thread_fence(std::memory_order_release);  // Release barrier
}
void Thread2() {
   std::atomic_thread_fence(std::memory_order_acquire); 
    int value = shared_var.load(std::memory_order_relaxed);  
}
```



**原子操作底层：**

**基于CPU层面的话**

有一个**总线锁定**和**缓存锁定**，

（1）总线锁定 

当一个处理器要操作共享变量时，在 BUS 总线上发出一个 Lock 信号，其他处理就无法操作这个共享变量了。

缺点很明显，总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。

（2）缓存锁定

后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效，待其他线程读取时会重新从主内存中读取最新的数据，基于 **MESI 缓存一致性协议来实现的。**这个在系统篇

**然后还知道个CAS**



**无锁队列：**

无锁队列，也称为 lock-free 队列，是一种在多线程环境中可以在无需锁定（即无需使用互斥量或锁）的情况下进行并发访问的数据结构。在无锁队列中，各线程可以并发地进行入队（push）和出队（pop）操作，而无需等待其他线程。这样可以提高并发性能，尤其在高争用的环境中。

**无锁队列通常通过原子操作和内存顺序（即内存屏障）来实现。在 C++ 中，可以使用 `std::atomic` 和 `std::memory_order` 来实现无锁队列。**



**原子操作定义：**

原子操作是指指令以原子方式执行，过程不会被打断。在多进程（线程）的操作系统中不能被其它进程（线程）打断的操作就叫原子操作，文件的原子操作是指操作文件时的不能被打断的操作。原子操作是不可分割的，在执行过程中不会被任何其它任务或事件中断。

linux内核提供了一系列函数来实现内核中的两类原子操作，分别针对位和整型变量进行原子操作。它们的共同点是在任何情况下操作都是原子的，内核代码可以安全地调用它们而不被打断。位和整型变量原子操作都依赖底层CPU的原子操作实现，因此所有这些函数都与CPU的架构密切相关。

因此原子操作有两类：**一类是各种临界区的锁，一类是操作原子变量的函数**

对于临界区的操作可以加锁来保证原子性，对于全局变量或静态变量操作则需要依赖于硬件平台的原子变量操作。









自旋锁

1） 自旋锁实际上是忙等锁， 当锁不可用时， CPU一直循环执行“测试并设置”该锁直到可用而取得该锁， CPU在等待自旋锁时不做任何有用的工作， 仅仅是等待。 因此， 只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。 当临界区很大， 或有共享设备的时候， 需要较长时间占用锁， 使用自旋锁会降低系统的性能。
2） 自旋锁可能导致系统死锁。 引发这个问题最常见的情况是[递归](https://www.zhihu.com/search?q=递归&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2641076955})使用一个自旋锁， 即如果一个已经拥有某个自旋锁的CPU想第二次获得这个自旋锁， 则该CPU将死锁

3） **在自旋锁锁定期间不能调用可能引起进程调度的函数。 如果进程获得自旋锁之后再阻塞， 如调用[copy_from_user](https://www.zhihu.com/search?q=copy_from_user&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2641076955})（） 、 copy_to_user（） 、 kmalloc（） 和msleep（） 等函数， 则可能导致内核的崩溃**。





## codedump

coredump是**程序由于异常或者bug在运行时异常退出或者终止**，在一定的条件下生成的一个叫做**core的文件**，这个core文件会记录**程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息**等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。













# C++STL====================



## vector

### vector底层原理、扩容机制（成倍）

**vector底层原理：**

vector的底层是**动态数组空间**，随着元素的加入它内部机制会自行空充空间以容纳新元素。vector维护了一个**连续的线性**空间，普通指针就可以满足要求作为vector的迭代器，**随机访问迭代器**。vector里面其实有三个迭代器，分别是指向**空间头部的iterator，指向空间尾部的iterator和指向可用空间的iterator**。

当有新的元素插入时，如果当前容量够就直接插入，如果容量不够则扩容至两倍或1.5倍，如果两倍不足，则扩容至足够大的空间。由于扩充过程不是在原有的空间后面追加，而是**重新申请一块新的连续内存，所以所有迭代器都会失效**。



**扩容机制：**

**当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间**(gcc是2倍，vs下的mingw是1.5倍)

当释放或者删除（vec.clear()）里面的数据时，**其存储空间不释放，仅仅是清空了里面的数据**。

因此，对vector的任何操作一旦引起了空间的重新配置，指向**原vector的所有迭代器会都失效**了。



**vector扩容问题：**

**扩容方式**

vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。

- 固定扩容：每次扩容的时候在原capacity的基础上加上固定的容量
- 加倍扩容：每次扩容的时候原capacity翻倍

**为什么成倍扩容而不增加固定大小的容量**

采用成倍方式扩容，可以保证**常数的时间复杂度**，而增加指定大小的容量只能达到O(n)的时间复杂度。

空间和时间的权衡。空间分配的多，平摊时间复杂度低，但浪费空间也多。

**为什么是两倍扩容而不是三倍四倍？**

扩容原理为：申请新空间，拷贝元素，释放旧空间，理想的分配方案是在第N次扩容时如果能复用之前N-1次释放的空间就太好了。

考虑可能**产生的堆空间浪费**，所以增长倍数不能太大，一般是1.5或2

使用2倍（k=2）扩容机制扩容时，每次扩容后的新内存大小必定大于前面的总和。

**而使用1.5倍（k=1.5)扩容时，在几次扩展以后，可以重用之前的内存空间了。**

**linux下GCC是按照2倍的方式扩容的，而vs下是按照1.5倍的方式扩容的。**



### reserve和resize、size()和capacity()的区别

**reserve和resize区别**

**reserve是预留内存，**直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back）。为的是避免内存重新申请以及容器内对象的拷贝。说白了，reserve()是给push_back()准备的！reserve()只有一个参数。reserve增加了vector的capacity，但是它的size没有改变！

而resize除了预留内存以外，还会**调用容器元素的构造函数，不仅分配了N个对象的内存，还会构造N个对象**。从这个层面上来说，resize()在时间效率上是比reserve()低的。但是在多线程的场景下，用resize再合适不过。resize改变了vector的capacity同时也增加了它的size！

1.  reserve是**容器预留空间**，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push_back()/insert()函数。
2.  resize是**改变容器的大小，且在创建对象**，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再**调用push_back()函数，是加在这个新的空间后面的。**

**size()和capacity()的区别**

size()指容器当前拥有的元素个数（对应的resize(size_type)会在容器尾添加或删除一些元素，来调整容器中实际的内容，使容器达到指定的大小。

capacity()指容器在必须分配存储空间之前可以存储的元素总数。

size表示的这个vector里容纳了多少个元素，capacity表示vector能够容纳多少元素，它们的不同是在于**vector的size是2倍增长的**。如果vector的大小不够了，比如现在的capacity是4，插入到第五个元素的时候，发现不够了，此时会给他重新分配8个空间，把原来的数据及新的数据复制到这个新分配的空间里。（会有迭代器失效的问题)







### push_back 和 emplace_back 、迭代器失效的情况

1. **push_back**: 这个方法将元素添加到容器的末尾。如果需要，它会先创建一个新的元素的副本，然后将这个副本放入容器中。**也就是说，`push_back`需要调用元素的拷贝构造函数或者移动构造函数。**

2. **emplace_back**: 这个方法也将元素添加到容器的末尾，但是它直接在容器内存上构造元素，而不是先创建一个新的元素的副本。**也就是说，`emplace_back`可以避免不必要的拷贝或移动操作，因此在某些情况下可能更加高效。**
3. **接受的参数类型不同**：`push_back(const T&)` 或 `push_back(T&&)` ，参数为**常量左值或者右值引用**；而 `emplace_back(Args&&... args)` 接受的是参数包（**右值引用形式**的）。

4. **vector中构造对象的形式不同**：二者传入参数的不同导致了在底层调用 `allocator::construct` 时传入的参数也不同，对于传入的**对象**，`allocator` 会调用**拷贝构造函数或者移动构造函数**，而对于传入的**参数**，`allocator` 会选择在**内存中直接构造对象**，**避免了一次拷贝/构造的过程**。

5. 由此导致 `push_back` 的效率低于 `emplace_back`



**迭代器失效的情况：**

当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。
当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。
当进行**删除操作**（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。

**插入扩容会导致迭代器失效：**vector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效



**防止迭代器失效的性能问题：**

在push_back()、resize()、insert()后有可能引**起重新分配内存，此时原始的迭代器失效，需要重新生成一次迭代器**
为了防止多次扩容造成性能低，可以**先使用reserve()，预留足够的空间**，最后在使用 shrink_to_fit()收缩空间
vector不能用来**存储bool类型的元素**，存储机理不同，bool类型的元素存储到vector中，会转化为1个bit，不是1个byte，可以用**deque或者是bitset存储bool类型**的
vector的扩容：VS是1.5倍、GCC是2倍

**相同**

emplace_back和push_back都**支持左值和右值**的传入。

传入**左值**的时候，会**调用拷贝构造函数构造出一个匿名对象**，然后将该对象存储到vector中

传入**右值**的时候，调用的是**两个函数的移动构造函数**。

**不同**

emplace_back的参数是可变的，传入的参数可以是**vector类型的构造函数的参数，直接原地构造**

比如emplace_back(10, “test”)可以**只调用一次constructor**

而push_back(MyClass(10, “test”))中MyClass(10, “test”)**调用了一次构造函数，同时值传递又调用拷贝构造函数**。



**频繁对vector调用push_back()的性能**

在一个vector的尾部之外的任何位置添加元素，都需要**重新移动元素**。而且，向一个vector添加元素可能引起**整个对象存储空间的重新分配**。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间。



**例子理解：**

```c++
MyString tmp("hello");
1、
vecStr. push_back(std: :move(tmp);
//创建了一个 MyString 对象 tmp 并将其初始化为 "hello"。然后，通过 std::move 将 tmp 对象的资源所有权转移到了 vecStr 向量中，使用 push_back 将其添加到向量的末尾。这会调用 push_back 函数的移动版本，将 tmp 的资源移动到向量中，同时使 tmp 变为无效状态。
vecStr. emplace_back(s td:: move(tmp));
//使用 emplace_back 在 vecStr 向量内构造一个 MyString 对象，使用给定的参数。通过 std::move 将 tmp 对象的资源所有权转移到了 emplace_back 中，然后直接在向量内构造一个新的 MyString 对象。与 push_back 不同，emplace_back 在向量中就地构造对象，而不是创建临时对象然后再移动。
                  
                  
2、
vecStr. push_back(MyString("hello"));
vecStr. emplace_back(MyString("hello"));
//创建一个临时的 MyString 对象，通过将 "hello" 作为参数传递给 MyString 的构造函数进行初始化。然后，该临时对象会被移动到 vecStr 向量中，使用 push_back 将其添加到向量的末尾
//使用 emplace_back 在 vecStr 向量内直接构造一个 MyString 对象，使用 "hello" 作为参数。与上述第一个示例不同，emplace_back 并不会创建临时对象并移动，而是直接在向量中构造对象。
//主要区别在于，push_back 在向量中添加一个经过构造的临时对象（可能会涉及对象的移动或复制），而 emplace_back 在向量中就地构造一个新对象，避免了中间临时对象的创建和移动过程。因此，emplace_back 通常更加高效。
                  
          
3、
vecStr. push_back("hello");
vecStr.emplace_back("hello"); 
//将一个 C 风格的字符串字面量（const char*）直接添加到 vecStr 向量中。然而，这只在向量的元素类型是 const char* 时才能编译通过，如果 vecStr 的元素类型是 MyString，这会导致编译错误，除非 MyString 有一个接受 const char* 的构造函数。
//使用 emplace_back 在 vecStr 向量内直接构造一个 MyString 对象，使用 "hello" 作为参数。与第一个示例不同，emplace_back 不会直接添加字符串字面量，而是根据 MyString 类的构造函数在向量内构造一个新对象。
```



### vector在堆上开10万个元素，扩容，怎么开辟内存

**std::vector是一个动态数组，其元素通常存储在堆上。`std::vector` 对象本身的存储位置取决于其声明方式：如果是在函数的局部作用域内声明，那么它会在栈上分配；如果是通过 `new` 关键字创建，那么它会在堆上分配。**

关于10万个元素的 `vector`，是可以创建的，具体能否创建成功取决于系统的可用内存和元素的大小。

**扩容**

当 `std::vector` 的容量不足以存放新元素时，会触发扩容操作。C++ 标准库的具体实现可能会有所不同，但一般来说，扩容过程如下：

1. **分配新的内存块**：通常会分配当前容量的两倍大小的新内存块。这样做是为了减少扩容次数，从而提高性能。
2. **复制旧元素**：将当前所有元素复制到新的内存块。
3. **释放旧内存块**：释放存放旧元素的内存块。
4. **更新指针和大小**：更新指向新内存块的指针，并更新容量和大小信息。

**开辟内存**

当你创建一个 `std::vector` 时，它会在堆上分配一块连续的内存来存储元素。这是通过**调用分配器（allocator）来实现的**，通常使用的是 `std::allocator` 类。分配器负责管理 `std::vector` 所需的内存，包括分配、构造、析构和释放内存。

如果你知道 `vector` 的大小，可以在创建时预分配内存，这样可以减少之后的扩容操作。例如，如果你要创建一个包含10万个元素的 `vector`

std::vector<int> vec; 

vec.reserve(100000); // **预分配**10万个元素的空间





### 释放vector的内存、如何释放空间、 erase

**释放vector的内存：**

**vec.clear()**：清空内容，但是不释放内存。

**vector().swap(vec)**：清空内容，且释放内存，想得到一个全新的vector。

不管是序列容器（⽐如vector）还是关联容器（⽐如unordered_map)，其**clear()成员函数都是线性时间复杂度O(n)的**。

常用clear()和erase()，实际上只是减少了size()，清除了数据，并不会减少capacity，所以内存空间没有减少。

**clear() 和 erase()**：`clear()`方法删除向量中的所有元素，而`erase()`则用于删除一个或多个特定元素。但它们不释放内存，这意味着`capacity()`保持不变，但`size()`会减少。

**如何释放内存空间呢，正确的做法是swap()操作。**

①可以利用swap()方法去除vector多余的容量：vector<T>(x).swap(x)；其中，x是当前要操作的容器，T是容器的类型。

②利用swap()方法清空vector容器：当 swap() 成员方法用于清空 vector 容器时，可以套用如下的语法格式：vector<T>().swap(x)。

**C++11 的 shrink_to_fit**：在C++11及更高版本中，`std::vector`添加了一个新方法`shrink_to_fit()`，它请求向量释放未使用的内存。不过，这只是一个请求，标准并不保证它会释放内存。尽管如此，对于大多数标准库实现来说，这仍然是释放内存的有效方法。



**如何释放空间：**

由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。

**所有内存空间是在vector析构时候才能被系统回收**。

empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

如果需要**空间动态缩小，可以考虑使用deque**。如果vector，可以用**swap()来帮助你释放内存**。

```cpp
vector(Vec).swap(Vec); //将Vec的内存清除； 
vector().swap(Vec); //清空Vec的内存；
```



**Vector erase：**

vector erase是删除一个元素或一系列元素，参数是一个迭代器或者一个迭代器的范围，返回值是指向下一个元素的迭代器

之所以指向下一个是因为，删除元素后，被删除元素后面的所有元素将向前移动以填补空白，这就导致了

1. **迭代器失效**：所有指向被删除元素的迭代器，包括指向这个元素的指针和引用，都将失效。试图通过失效的迭代器访问元素会导致未定义的行为。
2. **迭代器移位**：所有指向被删除元素之后的元素的迭代器也会失效。因为这些元素已经移位，所以之前的迭代器不再指向相应的元素。

erase()函数，只能删除内容，不能改变容量大小;

erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;

clear()函数，**只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存**，那么你可以选择deque容器。



**顺序容器、关联容器erase效果区别：**

**顺序容器（序列式容器，比如vector、deque）**

erase迭代器不仅使所指向被删除的迭代器失效，而且使**被删元素之后的所有迭代器失效(list除外)**，所以不能使用erase(it++)的方式，但是**erase的返回值是下一个有效迭代器**；

```c++
It = c.erase(it);
```

**关联容器(关联式容器，比如map、set、multimap、multiset等)**

erase迭代器只是被删除元素的迭代器失效，但是返回值是**void**，所以要**采用erase(it++)的方式删除迭代器**；

```c++
c.erase(it++)
```









### 元素类型不为引用、vector为函数返回值（RVO）

**元素类型不为引用：**

不可以

vector中的元素有两个要求：

1. 元素必须能赋值
2. 元素必须能复制

对于**类类型**来说，需要**拷贝构造和赋值运算符**支持，对于像map，set这种容器需要**重载运算符<**的支持，而**引用是必须初始化**的，指向一个特定对象，本质上是一个**常量指针**，因此**引用是不能复制**，意味着容器的拷贝复制就失效了。

容器开辟的时候还没有值，无法初始化，你咋能用引用

**vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。**

vector元素假设是指针类型：

清空 vector 数据时，如果保存的数据项是指针类型，需要逐项 delete，否则会造成内存泄漏。



**vector为函数返回值（RVO）：**

1. 在C++11中提供了**RVO/NRVO机制**可以防止这种**重复拷贝开销**。另一种是RVO/NRVO机制实现**复制消除机制**。
2. RVO机制使用**父栈帧（或任意内存块）来分配返回值的空间**，来避免**对返回值的复制**。也就是将Base fun();改为void fun(Base &x);





















### 频繁用push_back影响、clear()时间复杂度

**频繁用push_back影响：**

向 vector 的尾部添加元素，很有可能引起**整个对象存储空间的重新分配**，重新分配更大的内存，再将原数据拷贝到新空间中，再释放原有内存，这个过程是耗时耗力的，频繁对 vector 调⽤ push_back()会导致性能的下降。

所以我们可以**用reserver（容器预留空间**）解决这个问题。



**clear()时间复杂度：**

不管是序列容器（⽐如vector）还是关联容器（⽐如unordered_map)，其**clear()成员函数都是线性时间复杂度O(n)的**。

因为只要**执行了clear()**就需要对其**存储的元素调⽤析构函数** ，这个析构操作显然是逐个析构的。因⽽时间复杂度是O(n)。
⽐如当**vector存储基本数据类型**或POD类型（⽐如基本数据类型构成的struct）的时候，**由于其元素类型没有析构函数**（也不需要析构函数），加之**vector内部连续存储的特性，编译器的实现是可以在常量时间完成clear()的**。
仅限于vector存储基本数据类型和POD类型的时候，编译器可能有此优化。如果vector存储的
是其他类型的对象，或者是其他容器（⽐如list、map、unordered_map）都是**没办法做这个优化的**！





vector的插入复杂度

<img src="https://img-blog.csdnimg.cn/20190804120900612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpa2VfdGhhdA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%; float: left;" />



vector内部指针值扩容，扩容，与list的区别，中间删除复杂度

Vector 是 C++ 标准库中的一个动态数组容器，具有以下特点：

1. 动态数组：Vector 内部使用动态数组来存储元素，可以根据需要动态增加容器的大小。
2. 连续内存：Vector 的元素在内存中是连续存储的，这意味着可以通过指针进行高效的随机访问。
3. **扩容机制：当 Vector 的大小超过当前容量时，Vector 会自动重新分配更大的内存空间，并将原来的元素拷贝到新的内存空间中，从而实现扩容。扩容的策略一般是将容量翻倍，这样可以保证添加元素的平均时间复杂度仍为 O(1)。**
4. 操作复杂度：Vector 支持快速的随机访问（根据索引访问元素），但在中间位置插入和删除元素可能较慢，因为需要移动其他元素。
5. 预留空间：Vector 提供了 `reserve()` 方法，可以预留一定的内存空间，避免多次扩容带来的性能损耗。

**扩容：** Vector 内部的指针通常会改变。这是因为**扩容会导致重新分配更大的内存空间，并将原来的元素拷贝到新的内存空间中**。因此，扩容后 Vector 的指针指向的是新的内存空间。

与 Vector 不同，**List** 是一个双向链表，具有**以下特点**：

1. 双向链表：List 内部使用双向链表来存储元素，每个元素包含指向前一个和后一个元素的指针。
2. 非连续内存：List 的元素在内存中并不是连续存储的，这意味着不能通过指针进行高效的随机访问，只能通过迭代器依次访问元素。
3. **不会自动扩容：List 不会自动扩容，每次添加元素都会在堆上分配新的内存。**
4. 操作复杂度：List 支持快速的插入和删除操作，因为只需要调整指针来修改链表结构。但是随机访问元素的效率较低，需要遍历链表。

中间删除复杂度：在 Vector 中，如果删除中间位置的元素，会导致后面的元素向前移动，平均时间复杂度为 O(n)。而在 List 中，删除元素则只需要调整链表指针，时间复杂度为 O(1)。因此，如果频繁进行中间位置的插入和删除操作，List 可能更适合。但需要注意的是，在 List 中的随机访问效率较低，如果需要频繁随机访问元素，Vector 更为合适。







## deque底层原理、iterator、与vector的区别

deque 容器存储数据的空间是由**一段一段等长的连续空间**构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。

采用**一块所谓的map作为主控**，这里的map实际上是一块大小连续的空间，其中**每一个元素**我们称之为**节点node**，**都指向了另一段连续线性空间，成为缓冲区**，缓冲区才是deque的真正存储空间主体。

通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“**整体连续”**的效果。换句话说，当 deque 容器需要在**头部或尾部增加存储空间**时，它会申请一段新的连续空间，同时在 **map 数组的开头或结尾添加指向该空间的指针**，由此该空间就串接到了 deque 容器的头部或尾部。

**map 数组满怎办：**

答：再**申请一块更大的连续空间供 map 数组使用**，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧的空间。



**iterator：**

deque另外一个关键的就是它的iterator设计。deque中的iterator有四个部分，cur指向缓冲区现行元素。First指向缓冲区的头，last指向缓出去的尾（有时会包含备用空间），node指向节点管控中心。

总结：，deque数据结构中包含了指向第一个节点的iterator star和指向最后一个节点的iterator finist，**一块儿连续空间作为主控map**，也需要记住map的大小，已备判断何时配置更大的map。

**deque和vector的区别：**

- vector是**单向开口的连续区间**，deque是双向开口的连续区间（可以在头尾两端进行插入和删除操作）
- deque**没有提供空间保留功能**，也就是没有capacity这个概念，而vector提供了空间保留功能。即vector有capacity和reserve函数，deque 和 list一样，没有这两个函数。

**deque优点：**

deque是在功能上合并了vector和list。

1. **随机访问方便，即支持[ ]**操作符和vector.at()

2. 在内部方便的进行**插入和删除**操作

3. 可在两端进行push、pop

缺点：占用内存多





<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203101434582.gif" alt="deque容器的底层存储机制" style="float: left;" />

vector是单向开口的连续线性空间，deque是一种**双向开口的连续线性空间**。双向开口就是说deque支持从头尾两端进行元素的插入和删除操作。**deque没有容量的概念**，因为它是动态以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。由于要**维护这种整体连续的假象，并提供随机存取的接口**，也就是说提供random access iterator，**避开重新配置，复制，释放的轮回**。

代价是复杂的迭代器结构。非必要情况尽量使用vector。



## list底层、和vector、deque区别，何时用

**list底层：**

**list 是⼀个双向链表**，普通指针已经不能满足 list 迭代器的需求，因为 list 的存储空间是不连续的。与 vector 相比，list的好处就是**每次插⼊或删除⼀个元素就配置或释放⼀个空间**，而且原有的迭代器也不会失效。list的迭代器必需具备**前移和后退**功能，list 的数据结构中只要⼀个指向 node 节点的指针就可以了。

**List和Vector区别：**

1. vector底层实现是数组；Iist 是双向链表

2. vector是顺序内存，支持随机访问，list不行

3. vector在**中间节点进行插入删除会导致内存拷贝**，list不会

   **插入操作：** 在向量中间插入一个元素，那么在插入点之后的所有元素都需要向后移动一个位置，以腾出空间来存放新的元素。需要将一部分数据复制到新的内存位置，以便插入新元素，这会导致内存拷贝操作。

   **删除操作：**删除向量中的一个元素，需要将删除点之后的所有元素向前移动一个位置，以填补被删除元素的位置。这也会导致内存拷贝操作。

4. vector一次性分配好内存，不够时才进行翻倍扩容；list每次插入新节点都会进行内存申请

5. vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好

- **内存分配上**

  - `vector` 在内存中以连续方式存储元素，但因为内存空间是连续的，所以在进行**插入和删除操作时，会造成内存块的拷贝**，时间复杂度为o(n)，有扩容机制。
  - `list` 是由**双向链表实现的，内存空间是不连续的**，则是通过链接的节点来存储数据，这些节点可以在内存中分散存储。这也代表了vector比list有高效的随机访问能力，也就是说vector随机访问时间复杂度是O(1)的，而list是O(n)的，但是插入和删除list是O(1)的，vector是O(n)的

- **迭代器失效上**

  - 在 `vector` 中，当一个元素被插入或删除时，**所有指向后续元素的迭代器都会失效**，因为这些元素可能需要被移动到新的位置。此外，如果 `vector` 需要重新分配内存，那么所有的迭代器都会失效。
  - 在 `list` 中，**插入或删除一个元素只会使指向该元素的迭代器失效**，其他的迭代器不会受到影响。这是因为 `list` 中的元素是通过链接的节点来存储的，插入或删除一个节点不会影响到其他节点的位置。

- **适用场景**

  - 如果你的**主要操作是随机访问元素，且插入和删除操作主要发生在容器的尾部**，那么 `vector` 是更好的选择，因为它可以提供更高效的随机访问和尾部插入/删除操作。
  - 如果你的**主要操作是在容器的中间或头部插入和删除元素，而不需要频繁地随机访问特定的元素**，那么 `list` 是更好的选择，因为它可以提供更高效的插入和删除操作。

  List底层用双向链表因为存取方便



**list 与 deque 的区别:**

- **list**不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；
- list插入操作和结合才做都不会造成原有的list迭代器失效;
- list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；
- list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；
- **deque**是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作；
- **deque和vector最大的差异**，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于**deque没有所谓容量**概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能.



**什么情况下用vector、list、deque**

vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。
**list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景**。
需要从**首尾两端进行插入或删除操作**的时候需要选择deque。







## stack、queue(非线程安全)、priority_queue

**stack:**

是⼀种先进后出的数据结构，只有⼀个出口，stack 允许从最顶端新增元素，移除最顶端元素，取得最顶端元素。 deque 是双向开口的数据结构，所以使⽤ deque 作为底部结构并封闭其头端开口，就形成了⼀个 stack。

**queue:**

是⼀种先进先出的数据结构，有两个出口，允许从最底端加入元素，取得最顶端元素，从**最底端新增元素**，从最**顶端移除元素**。deque 是双向开⼝的数据结构，若以 deque 为底部结构并封闭其底端的出口，和头端的⼊口就形成了⼀个 queue。（其实 list 也可以实现 deque）

**queue不是线程安全:**

- STL中的queue是**非线程安全**的，一个组合操作：front(); pop()先读取队首元素然后删除队首元素，若是有**多个线程执行这个组合操作**的话，可能会发生**执行序列交替执行**，导致一些意想不到的行为
- 在**队列内部**增加**条件变量和互斥锁**实现线程安全，wait_pop，try_pop等接口定义；在push的同时进行加锁以及条件变量+1的操作等等
- **STL容器不是线程安全**的。对于vector，即使写方（生产者）是单线程写入，但是**并发读**的时候，由于**潜在的内存重新申请和对象复制**问题，会导致读方（消费者）的**迭代器失效**。实际表现也就是招致了core dump。另外一种情况，如果是多个写方，并发的push_back()，也会导致core dump。

**priority_queue:**

priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个









## 哈希表定义、底层实现、O(1)、怎么解决哈希冲突、扩容

**哈希表定义：**

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度（以时间换空间的思想）。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。

STL的哈希表实现了两个容器unordered_map和unordered_set，哈希表其实可以视为一个数组，每个元素是一个桶，每个桶里又放了一些元素，可以根据严肃的哈希值模上桶的数量来确定放到哪个桶里，如果有的桶有很多元素，有的桶没有元素，或者希望每个元素放入不同的桶这可能就是哈希冲突，解决方法是链地址法，就是每个桶实际上是个链表，当元素被哈希到同一个桶时，我们会将它们都插入到这个桶的链表中。



**底层实现：**

STL中的hashtable哈希表使用的是**开链法**解决hash冲突问题，如下图所示。

hashtable中的bucket桶所维护自己定义的由hashtable_node数据结构组成的**linked-list**，而bucket聚合体本身使用vector进行存储。**hashtable的迭代器只提供前进操作，不提供后退操作**

在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在**创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量**（vector的长度），其中每个bucket所维护的**linked-list长度也等于hashtable的容量**。

如果插入**hashtable的元素个数超过了bucket**的容量，就要进行**重建table操作**，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。



**哈希表时间复杂度是O(1)：**

首先要参考数组的查找，数组在内存中是一块连续的地址空间，只要知道查找数据的下标就可以快速定位到数据的内存。

哈希表就是利用了数组的下标查找的特性，即**hash表的物理存储其实是数组**。

事实上，(“abc”,“hello”) 这样的 Key、Value 数据并不会直接存储在 Hash 表的数组中，因为数组要求存储固定数据类型，主要目的是**每个数组元素中要存放固定长度的数据**。

所以，数组中存储的是 Key、Value 数据元素的地址指针。一旦发生 Hash 冲突，**只需要将相同下标，不同 Key 的数据元素添加到这个链表就可以了**。查找的时候再遍历这个链表，匹配正确的 Key。



**怎么解决哈希冲突**

哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过**哈希函数产生的哈希值**是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的哈希值。这时候就产生了哈希冲突。

> 解决方法

- 开放寻址法

  当发生哈希冲突后，就去寻找下一个空的散列地址，只要散列表足够大，这个空的位置一定能找到

- 再散列法

  当散列表元素太多（即装填因子 α 太大）时，查找效率会下降；当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫做“再散列（Rehashing）”。Hash 表中每次发现 loadFactor==1 时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素全部转移过来到新的桶数组中。注意这里转移是需要元素一个个重新哈希到新桶中的。实用最大装填因子一般取 0.5 <= α<= 0.85

- 链地址法

  当发生冲突时，该位置上的数据会用链表链起来，当表中的某些位置没有结点时，该位置就为 NULL。但是当数据特别大时候，可能链表也很长，查找变成O(n)

  优化：使用红黑树等树形结构来存储，但是要注意红黑树有排序，需要自定义排序算法。

- 公共溢出区

  为所有冲突的关键字记录建立一个公共的溢出区来存放。在查找时，对给定关键字通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表进行顺序查找。如果相对于基本表而言，在有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。

**Hash表的扩容：**

**什么时候扩容？**

当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值(即当前数组的长度乘以加载因子的值的时候)，就要自动扩容了。

**扩容**

1. 增加桶的数量：首先，会创建一个新的哈希表，这个新哈希表的桶的数量通常是原哈希表的两倍，但这个具体数值可能会根据不同的实现而略有不同。
2. 重新计算哈希：然后，会遍历旧哈希表中的所有元素，对每个元素重新计算哈希值，并将其模上新哈希表的桶的数量，从而确定每个元素在新哈希表中的位置。
3. 移动元素：最后，将元素从旧哈希表移动到新哈希表的对应位置。
4. 释放旧的



常见的常见的散列函数：

- 直接寻址法

  取关键字或关键字的某个线性函数值为散列地址

- 平方取中法

  当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址

- 随机数法

  择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不等的场合

- 除留余数法

  取余，取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key % p, p <= m











## map 和 unordered_map 的底层、选择场景、优缺点

- map底层是基于**红黑树**实现的，因此map内部元素排列是有序的。
- unordered_map底层是基于**哈希表**实现的，因此其元素的排列顺序是杂乱无序的。
- `unordered_map` 的查找、插入和删除操作的时间复杂度为 O(1)，但在最坏情况下（所有键都哈希到同一位置时）时间复杂度为 O(n)。而 `map` 的查找、插入和删除操作的时间复杂度总是 O(log n)。

**map 的底层原理：**

map 是基于红黑树（Red-Black Tree）实现的有序关联容器。红黑树是一种自平衡二叉搜索树，它具有以下特点：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色的。
- 每个叶子节点（NIL 节点，通常用空节点表示）是黑色的。
- 如果一个节点是红色的，则它的两个子节点都是黑色的。
- 从任意节点到其每个叶子节点的路径都包含相同数目的黑色节点。

由于红黑树的特性，`map` 内部的数据是有序的，因此在查找、插入和删除操作的平均时间复杂度为 O(log n)，其中 n 是元素个数。



**unordered_map 的底层原理：**

unordered_map 容器和 map 容器一样，以**键值对（pair类型）的形式存储数据**，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是**哈希表存储结构**，该结构本身不具有对**数据的排序**功能，所以此容器内部不会自行对存储的键值对进行排序。

**底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中**。哈希表使用哈希函数将元素的键映射到哈希值，然后将元素存储在对应的哈希桶中。由于哈希表的特性，`unordered_map` 内部的数据是无序的，因此在查找、插入和删除操作的平均时间复杂度为 O(1)。

但是，最坏情况下的时间复杂度是 O(n)，其中 n 是元素个数，这是因为哈希冲突可能导致多个元素存储在同一个哈希桶中，

**解决方法**选用的是**“链地址法**”（又称“开链法”）。这个**连续空间存储的不是键值对，而是各个链表的头指针**。

1. 将该**键值对中键的值**带入设计好的**哈希函数**，会得到一个哈希值（一个整数，用 H 表示）；
2. 将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此**键值对存储到的桶的编号**；
3. 建立**一个新节点存储此键值对**，同时将该节点**链接到相应编号的桶上**。

**总体来说**，unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，如果你考虑效率，特别是在元素达到一定数量级时，考虑unordered_map 。



**选择场景：**

- 如果需要有序的关联容器，并且对内存使用没有太高要求，可以选择 `map`。
- 如果对顺序没有要求，但需要高效的查找、插入和删除操作，可以选择 `unordered_map`。
- `map` 的内存开销通常比 `unordered_map` 大，因为**红黑树需要维护额外的指针和节点颜色信息**。
- `unordered_map` 需要一个**合适的哈希函数**来保证较好的性能，尤其是在**元素较多**时。



**优缺点**：

**map优缺点**：

- **优点**
  1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。
  2. map的查找、删除、增加等一系列操作时间复杂度稳定，都为O(Iogn)
- **缺点**
  1. 查找、删除、增加等操作平均时间复杂度较慢，与n相关。

**unordered_map优缺点：**

- 优点
  1. 查找、删除、添加的速度快，时间复杂度为常数级O(1)
- 缺点
  1. 因为unordered_mapl内部**基于哈希表**，以（key,value）对的形式存储，因此**空间占用率高**。
  2. unordered map的查找、删除、添加的时间复杂度不稳定，平均为O(1)，取决于哈希函数。极端情况下可能为O(n)



map 如何保证key唯一

- 自定义排序规则，重载<操作符或者定义一个函数对象



### **insert后迭代器不失效、插入效率高、插入方式**

**insert后迭代器不失效：**

因为map和set存储的是节点，**不需要内存拷贝和内存移动**。但是像vector在插入数据时如果**内存不够会重新开辟一块内存**。map和set的iterator指向的是**节点的指针**，vector指向的是**内存的某个位置**

因为每次只是节点指针的改变，每个节点的内存没有改变。iterator就是指向每个节点内存的指针，所以插入之后，该指针是不会变的。



**map插入删除效率高**

因为map和set底部使用红黑树实现,插入和删除的时间复杂度是O(logn)，而向vector这样的序列容器插入和删除的时间复杂度是O(N)

**对于关联容器来说，存储的只是节点。插入删除只是节点指针的换来换去，不需要做内存拷贝和内存移动。**



**map插入方式有哪几种：**

1) 用insert函数插入pair数据，

```cpp
mapStudent.insert(pair<int, string>(1, "student_one")); 
```

2) 用insert函数插入value_type数据

```cpp
mapStudent.insert(map<int, string>::value_type (1, "student_one"));
```

3) 在insert函数中使用make_pair()函数

```cpp
mapStudent.insert(make_pair(1, "student_one"));
```

4) 用数组方式插入数据

```cpp
mapStudent[1] = "student_one"; 
```





**hash_map、map对比：**

**构造函数：**hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。
**存储结构：**hash_map以hashtable为底层，而map以RB-TREE为底层。
总的说来，**hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。而map的查找速度是logn级别。**但不一定常数就比log小，而且hash_map还有hash function耗时。
如果考虑效率，特别当元素达到一定数量级时，用hash_map。
考虑内存，或者元素数量较少时，用map。

但对内存使用严格，希望程序尽可能少消耗内存，那么hash_map 对象特别多时，无法控制并且 hash_map 的构造速度较慢。

选择权衡三个因素: **查找速度, 数据量, 内存使用** 。



为何map、set不像vector有reserve来预分配数据?

因为在map和set内部存储的已经不是元素本身了，而是**包含元素的结点**。也就是说map内部使用的Alloc并不是map<Key, Data, Compare, Alloc>声明的时候从参数中传入的Alloc。





## 关联式容器：

### map 、multimap、set、multiset的底层原理、特点

**底层原理：**

map 、set、multiset、multimap的底层实现都是**红黑树**，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。

红黑树的特性：

1. 每个结点或是红色或是黑色；
2. 根结点是黑色；
3. 每个叶结点是黑的；
4. 如果一个结点是红的，则它的两个儿子均是黑色；
5. 每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。

对于STL里的map容器，**count方法与find方法，都可以用来判断一个key是否出现**，mp.count(key) > 0统计的是key出现的次数，因此只能为0/1，而mp.find(key) != mp.end()则表示key存在。



**特点：**

set和multiset会根据**特定的排序准则自动将元素排序**，set中元素不允许重复，multiset可以重复。

map和multimap将**key和value组成的pair作**为元素，根据**key的排序准则自动将元素排序**（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。

map和set的增删改查速度为都是logn，是比较高效的。



### unordered_map、unordered_set的底层原理

底层是一个**防冗余的哈希表（采用除留余数法**）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。

使用一个**下标范围比较大的数组**来存储元素。可以设计一个函数（哈希函数（一般使用除留取余法），也叫做散列函数），使得**每个元素的key**都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，**按照key为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。**

但是，不能够保证每个元素的key与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 一般可采用拉链法解决冲突：



### set 和无序set 如何存自定义数据类型

- `set` 的底层是**红黑树**，只要定义了**比较规则**就能知道存放的位置。但是 `unordered_set` 的底层是**哈希表**，对于自定义的数据类型来说，需要**自定义哈希函数**。
- **自定比较规则**接受的是 `function` 对象，所以要按照构造 `function` 的形式传入参数。

> set

自定义排序规则

1. 定义一个类，**重载()**，或者 **大于，小于运算符**
2. **自定义比较函数，**需要传入函数指针，或者使用 `std::function<>`
3. lambda 表达式

> unordered_set

自定义**哈希函数**

1. 自定义对象
2. 重载opeartor()
3. lambda表达式





set、 multiset 重复数据实现

set提供的插入函数接口：

```c++
pair<iterator,bool> insert(const value_type& elem);
iterator insert(iterator pos_hint, const value_type& elem);
```

**multiset提供的插入函数的接口：**

```c++
iterator insert(const value_type& elem);
iterator insert(iterator pos_hint, const value_type& elem);
```

set的返回值型别是由pair组织起来的两个值：

1. pair第一个元素返回新元素的位置，或返回现存的同值元素的位置。
2. pair第二个元素表示插入是否成功。

set的第二个insert函数，如果插入失败，就只返回重复元素的位置！

**multiset中所有拥有位置提示参数的插入函数的返回值型别是相同的。这样就确保了至少有了一个通用型的插入函数，在各种容器中有共通接口。**





map和set不像vector有个reserve函数来预分配数据

最主要的原因是关联式容器**内部存储的不是元素**的本身，同时还有**元素的节点信息，是无法预分配的**。



当数据元素增多时，map和set的查询速度

查找时间复杂度是logn，所以不会有什么变化



### map访问、用[]越界发生什么

- **通过key访问获得map的方法都有哪些**

  - 首先要判断key存不存在，有两种判断办法
    1. 通过count函数计算key的个数，0表示不存在，1表示存在1个
    2. 通过find函数，如果`map.find(key) != map.end()`，即find指针不是最后一个就表明找到了
  - 获得value的方法
    1. 通过重载的`[]`，即`map[key]`
    2. 通过map自身的迭代器iter，即`iter->first = key`和`iter->second = value`

- **通过下标去访问map中的value会有越界的可能，会发生什么**

  如果当没有要找的key的话，会返回end，然后会执行insert语句，插入一个pair类型的对儿，key是你输入的和默认的value。

  所以会自动插入一个你**搜索的key和默认的value**。如果value为内置类型，其值将被初始化为0；如果value为自定义数据结构且用户定义了默认值则初始化为默认值，否则初始化为0。

  












map和set为什么用红黑树

**高度越小越好**，BST这种有特殊情况，比如**只有左子树有值，导致O(n)复杂度**

AVL树平衡有点太变态了，导致每次自适应的时候效率低一点。所以综合来说红黑树是最优秀的



map中[]与find的区别？

1. map的**下标运算符[]**的作用是：将key作为下标去执行查找，并返回对应的值；如果不存在这个key，就将一个具有**该关键码和值类型的默认值的项**插入这个map。
2. map的**find函数**：用key执行查找，找到了**返回该位置的迭代器**；如果不存在这个关键码，就返回尾迭代器。



vector、list和map插1000万个元素，消耗对比

毫无疑问vector最小

使用std::map和std::list存放数据，消耗内存比实际数据大得多

原因：std::list和std::map属于散列容器，容器的空间之间是通过指针来关联的，所以指针会占用一部分内存，当自身存放的数据较2*8（std::list，双向链表）差别不大时，会有很大的额外内存开销。为了避免此开销，可以使用线性容器，std::vector。













 什么是STL

- Standard Template Library，标准模板库，是C++的标准库之一，一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。

  **STL包含6大部件：容器、迭代器、算法、仿函数、适配器和空间配置器。**

  - 容器：容纳一组元素的对象，提供各种数据结构。
  - 迭代器：提供一种访问容器中每个元素的方法，从实现的角度来说，迭代器是一种将`operator*`, `operator->`, `operator++`等指针操作赋予 重载的类模板。
  - 仿函数：一个行为类似函数的对象，调用它就像调用函数一样，重载了`operator()`的类或者类模板。
  - 算法：包括查找算法、排序算法等等。

  - 适配器：用来修饰容器等，比如queue和stack，底层借助了deque。
  - 空间配置器：负责空间配置和管理，是一个实现了动态空间配置，空间管理，空间释放的类模板



## STL容器简介和底层、时间复杂度

1. **vector（向量）**：vector 是一个动态数组，其底层通常由一个连续的内存块实现。向量支持随机访问，尾部插入和删除操作具有常数时间复杂性，但是在非尾部的位置插入和删除元素需要线性时间复杂度，因为需要移动元素。
2. **list（双向链表）**：list 底层是由一个双向链表实现的。它支持在任意位置进行插入和删除操作，这些操作具有常数时间复杂性。然而，由于链表不支持随机访问，访问特定位置的元素需要线性时间。
3. **deque（双端队列）**：deque 的实现稍复杂一些，它是由一组固定大小的数组组成的动态数组，有一个中心控制器来控制这些数组。deque 支持随机访问，同时也支持两端的插入和删除操作，这些操作都具有常数时间复杂性。
4. **stack（栈）**：stack 是一个后进先出 (LIFO) 的容器，其底层通常由 deque 或 list 实现。插入和删除操作只在栈顶进行，具有常数时间复杂性。
5. **queue（队列）**：queue 是一个先进先出 (FIFO) 的容器，其底层通常由 deque 或 list 实现。插入操作在队尾进行，删除操作在队头进行，这些操作都具有常数时间复杂性。
6. **priority_queue（优先队列）**：优先队列是一种抽象的数据类型，其底层通常由 vector 和一些堆操作实现。它总是保持最高（或最低）优先级的元素在顶部。
7. **set / multiset（集合 / 多重集合）**：set 和 multiset 是基于红黑树实现的，所有元素都自动排序。set 中元素唯一，multiset 中元素可以重复。
8. **map / multimap（映射 / 多重映射）**：map 和 multimap 底层也是基于红黑树实现的，键值对按照键的顺序排序。map 中的键必须是唯一的，而 multimap 允许键重复。
9. **unordered_set / unordered_multiset（无序集合 / 无序多重集合）**：这些容器底层由哈希表实现，元素插入和查找时间复杂度通常为常数。
10. **unordered_map / unordered_multimap（无序映射 / 无序多重映射）**：这些容器也是基于哈希表实现的，对于键值对的插入和查找，时间复杂度通常为常数。



**STL 容器时间复杂度：**

vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等。容器底层实现方式及时间复杂度分别如下：

1. ***vector***

   采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：

   插入: O(N)

   查看: O(1)

   删除: O(N)

2. ***deque***

   采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：

   插入: O(N)

   查看: O(1)

   删除: O(N)

3. ***list***

   采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：

   插入: O(1)

   查看: O(N)

   删除: O(1)

4. ***map、set、multimap、multiset***

   上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:

   插入: O(logN)

   查看: O(logN)

   删除: O(logN)

5. ***unordered_map、unordered_set、unordered_multimap、 unordered_multiset***

   上述四种容器采用哈希表实现，不同操作的时间复杂度为（与哈希函数有关）：

   插入: O(1)，最坏情况O(N)

   查看: O(1)，最坏情况O(N)

   删除: O(1)，最坏情况O(N)

   **注意：**容器的时间复杂度取决于其底层实现方式。



说一下 STL 中有哪些常见的容器（字节）

1. STL 中的容器分为顺序容器、关联式容器、容器适配器三种类型。
2. **顺序容器**：容器并非排序的，元素插入位置与元素的值无关，主要包括 vector、 deque 、 list。
   - vector：动态数组，元素在内存中连续存放。随机存储任何元素都能在常数时间完成。尾端增删元素具有较好的性能。
   - deque：双向队列，元素在内存中连续存放。随机存取任何元素都能在常数时间完成。在两段增删元素具有较佳的性能。
   - list：双向链表，元素在内存中不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
3. **关联式容器**：元素排序的，插入任何元素都按照相应的规则来确定其位置。在查找时有较好的性能，主要包括set、map
   - set：根据 value 来对元素进行排序
   - map：根据键值进行排序
4. **容器适配器**：封装了一些基本的容器，使之具备了新的函数功能，在实例化时可以自行选择底层实现的容器。包括stack、queue、priority_queue。
   - stack：栈中删除、检索和修改的项只能是最近插入序列的项，后进后出。
   - queue：队列，插入只可以在尾部进行，删除、检索和修改只允许从头部进行，先进先出。
   - priority_queue：优先队列，内部维持某种有序，确保优先级最高的元素总是位于头部，最高优先级元素总是第一个出列。





## 在共享内存上用STL、STL内存优化

**在共享内存上用STL：**

1、把STL容器，例如map, vector, list等等，放入共享内存中，IPC有了强大的通用数据结构做辅助，会提升进程间通信的能力。

不为为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。

**当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。**考虑到要将STL容器放到共享内存中，而**容器却自己在堆上分配内存**。

办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。

2、假设**进程A**在共享内存中放入了**数个容器**，进程B如何找到这些容器？

一个方法就是**进程A把容器放在共享内存中的确定地址**上（fixed offsets），则进程B可以从该已知地址上获取容器。

另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给**其取个名字和地址**一并保存到这个map容器里。进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。



**STL内存优化：**

STL内存管理使用二级内存配置器。

**(1) 第一级配置器：**

第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。**一级空间配置器分配的是大于128字节的空间**，如果分配不成功，**调用句柄释放一部分内存，如果还不能分配成功，抛出异常。**

第一级配置器只是对malloc函数和free函数的简单封装，在allocate内调用malloc，在deallocate内调用free。同时第一级配置器的oom_malloc函数，用来处理malloc失败的情况。

**(2) 第二级配置器：**

第一级配置器直接调用malloc和free带来了几个问题：

- **内存分配/释放**的效率低
- 当配置大量的小内存块时，会导致**内存碎片**比较严重
- 配置内存时，需要额外的部分空间存储内存块信息，所以配置大量的小内存块时，还会导致额外内存负担

如果**分配的区块小于128bytes，则以内存池管理，第二级配置器维护了一个自由链表数组**，每次需要分配内存时，直接从**相应的链表上取出一个内存节点**就完成工作，效率很高。





**自由链表数组：**自由链表数组其实就是个指针数组，数组中的每个指针元素指向一个链表的起始节点。数组大小为16，即维护了16个链表，链表的每个节点就是实际的内存块，相同链表上的内存块大小都相同，不同链表的内存块大小不同，从8一直到128。如下所示，obj为链表上的节点，free_list就是链表数组。

**内存分配：**allocate函数内先判断要分配的内存大小，**若大于128字节，直接调用第一级配置器，否则根据要分配的内存大小从16个链表中选出一个链表，**取出该链表的第一个节点。若相应的链表为空，则调用refill函数填充该链表。默认是取出20个数据块。

**填充链表 refill：**若allocate函数内要取出节点的链表为空，则会调用refill函数填充该链表。refill函数内会先调用chunk_alloc函数从内存池分配一大块内存，该内存大小默认为20个链表节点大小，当内存池的内存也不足时，返回的内存块节点数目会不足20个。接着refill的工作就是将这一大块内存分成20份相同大小的内存块，并将各内存块连接起来形成一个链表。

**内存池：**chunk_alloc函数内管理了一块内存池，当refill函数要填充链表时，就会调用chunk_alloc函数，从内存池取出相应的内存。

- 在chunk_alloc函数内首先判断内存池大小是否足够填充一个有20个节点的链表，若内存池足够大，则直接返回20个内存节点大小的内存块给refill；
- 若内存池大小无法满足20个内存节点的大小，但至少满足1个内存节点，则直接返回相应的内存节点大小的内存块给refill；
- 若内存池连1个内存节点大小的内存块都无法提供，则chunk_alloc函数会将内存池中那一点点的内存大小分配给其他合适的链表，然后去调用malloc函数分配的内存大小为所需的两倍。若malloc成功，则返回相应的内存大小给refill；若malloc失败，会先搜寻其他链表的可用的内存块，添加到内存池，然后递归调用chunk_alloc函数来分配内存，若其他链表也无内存块可用，则只能调用**第一级空间配置器**。

STL 是复制性还是侵入性

STL实现的容器都是非侵入式容器，通过模板类可以放入任何类型的结构，与浸入式容器的最大不同是，C++的非侵入式容器必须存储用户数据的拷贝





STL的数据域和指针域分开的好处

适配迭代器，迭代器只需要指针域，只有找到后才会访问数据域，降低消耗











## STL不是线程安全的

STL容器不是线程安全的。对于vector，即使写方（生产者）是单线程写入，但是并发读的时候，由于潜在的**内存重新申请和对象复制**问题，会导致读方（消费者）的迭代器失效。实际表现也就是招致了core dump。另外一种情况，如果是多个写方，并发的push_back()，也会导致core dump。

**解法如下：**

1、加锁

2、通过**固定vector的大小，避免动态扩容**（无push_back）来做到lock-free！即在开始并发读写之前（比如初始化）的时候，给vector设置好大小。代码如下：

```c++
vector<int> v;
v.resize(1000);
```

注意是resize，不是reserve！

**STL线程不安全的情况：**

在对同一个容器进行多线程的读写、写操作时；
在每次调用容器的成员函数期间都要锁定该容器；
在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；
在每个在容器上调用的算法执行期间锁定该容器。

STL 容器动态链接产生哪些问题

向动态库函数传入容器的引用时，如果在动态库里面对容器插入了一些元素，那么这些内存分配的代码是属于dll的，此时从dll返回后再进行容器的释放，程序会崩溃，因为**程序不知道dll中插入元素的内存在哪**。





## 迭代器失效、底层机制、与指针的区别

**迭代器失效的定义：对容器的操作影响了元素的存放位置，称为迭代器失效。**

以下是一些导致迭代器失效的常见情况：

1. **Vector, deque**：
   - 当插入（insert）或删除（erase）元素时，指向容器的所有迭代器都可能失效。这是因为这些操作可能导致容器内部的元素重新分配内存，改变元素的物理位置。
   - 当进行push_back或pop_back操作时，只有指向最后一个元素之后的迭代器（即end迭代器）会失效。
   - resize操作也可能导致迭代器失效。
   - 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。
2. **List**：
   - list容器的插入和删除操作不会使指向其他元素的迭代器失效。
3. **Map, set**：
   - 插入元素不会使已有迭代器失效。
   - 删除某个元素会使指向该元素的迭代器失效，但不影响其他迭代器。
4. **Unordered_map, unordered_set**：
   - 插入元素可能导致迭代器失效，这是因为当容器的元素数量达到某个阈值时，为了保持哈希表的性能，会触发rehash操作，重新分配所有元素的存储空间。
   - 删除元素会使指向该元素的迭代器失效，但不影响其他迭代器。

在进行可能导致迭代器失效的操作后，最好重新获取迭代器，以确保你的迭代器总是指向有效的元素。



**底层实现：**

萃取技术和模板偏特化

- **萃取技术**

  萃取技术可以**进行类型推导**，根据**迭代器的不同类型处理不同流程**。例如vector的迭代器类型为随机访问迭代器，list为双向迭代器

- **模板偏特化**

  模板偏特化可以用来推导参数，如果我们自定义了多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断他们具体属于是个类型。

- 迭代器的类型

  1. 输入迭代器。从容器中读取元素。输入迭代器只能一次读入一个元素向前移动
  2. 输出迭代器。向容器中写入元素。输出迭代器只能一次一个元素向前移动。
  3. 正向迭代器。组合输入迭代器和输出迭代器的功能，并保留在容器中的位置
  4. 双向迭代器。组合正向迭代器和逆向迭代器的功能
  5. 随机访问迭代器。组合双向迭代器的功能与直接访问容器中任何元素的功能，即可向前向后跳过任意个元素

  

**迭代器和指针的区别：**

**迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，->、++、-- 等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，

**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

**迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。







迭代器和指针的区别

迭代器的作用

（1）用于指向顺序容器和关联容器中的元素

（2）通过迭代器可以读取它指向的元素

（3）通过非const迭代器还可以修改其指向的元素

（4）STL 的容器和算法之间通过迭代器进行交互

迭代器的定义：

在设计模式中有迭代器模式，即提供一种方法，使之**能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式**。迭代器**只是一种概念上的抽象，具有迭代器通用功能和方法的对象都可以叫做迭代器**。迭代器有很多不同的能力，可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。









迭代器产生的原因

Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。



使用迭代器的优点：

- 代码编写方便：迭代器提供了通用接口来遍历元素，不用担心容器的大小，使用迭代器我们可以简单地使用成员函数 end() 来判断容器的结尾，遍历内容方便而简洁；
- 代码可重用性高：：迭代器提供了一组通用的 api 访问和遍历容器中的元素。迭代器支持代码的可重用性，它们可以被使用访问任何容器的元素。
- 容器可以动态处理：迭代器能够在需要时方便地从容器中动态添加或删除元素。







迭代器的种类

- 前向迭代器（forward iterator）

  则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。

- 双向迭代器（bidirectional iterator）

  双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）。

- 随机访问迭代器（random access iterator）

  随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：

  1. p+=i：使得 p 往后移动 i 个元素。
  2. p-=i：使得 p 往前移动 i 个元素。
  3. p+i：返回 p 后面第 i 个元素的迭代器。
  4. p-i：返回 p 前面第 i 个元素的迭代器。
  5. p[i]：返回 p 后面第 i 个元素的引用。

- 输入迭代器 (input iterator)

  可用于读取容器中的元素，但是不保证能支持容器的写入操作。

  只支持自增运算

- 输出迭代器 (output iterator)

  可视为与输入迭代器功能互补的迭代器；

  输出迭代器可用于向容器写入元素，但是不保证能支持读取容器内容。

  只支持自增运算













迭代器什么情况下会失效

1. 对于**顺序容器** vector，deque 来说，使用 erase 后，后边的每个元素的迭代器都会失效，**后边每个元素都往前移动一位**，**erase 返回下一个有效的迭代器**。
   - `push_back` 和 `insert` ：对于 `push_back` 来说，`end()` 肯定会失效。如果因为**插入导致了扩容，那么会导致所有元素的迭代器失效**。
   - `insert` 和 `erase` ：会导致**插入/删除位置后面的所有元素都失效。**
2. 对于**关联式容器**map，set来说，使用了erase后，**当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器**，所以在调用erase之前，**记录下一个元素的迭代器**即可。
3. 对于 list 来说，它使用了不连续分配的内存，并且它的erase方法也会返回**下一个有效的迭代器**，因此上面两种方法都可以使用。



迭代器插入、删除操作失效的情况

（1）插入操作

对于vector和string，如果容器内存被重新分配，iterators,pointers,references失效；如果没有重新分配，那么插入点之前的iterator有效，插入点之后的iterator失效；

对于deque，如果插入点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，deque的迭代器失效，但reference和pointers有效；

对于list和forward_list，所有的iterator,pointer和refercnce有效。

（2）删除操作

对于vector和string，删除点之前的iterators,pointers,references有效；off-the-end迭代器总是失效的；

对于deque，如果删除点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，off-the-end失效，其他的iterators,pointers,references有效；

对于list和forward_list，所有的iterator,pointer和refercnce有效。

对于关联容器map来说，如果某一个元素已经被删除，那么其对应的迭代器就失效了，不应该再被使用，否则会导致程序无定义的行为。









**序列式容器失效**

**失效原因：**因为 vetor、deque 使用了连续分配的内存，`erase`操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效。

**解决办法：**由于`erase`可以返回下一个有效的iterator，因此`q.earse(it)`不行，但是`it=q.erase(it)`可以

```c++
int main() {
	vector<int> q{ 1,2,3,4,5,6 };
	// 在这里想把大于2的元素都删除
	for (auto it = q.begin(); it != q.end(); it++) {
		if (*it > 2)
			q.erase(it); // 这里就会发生迭代器失效
	}
	// 打印结果
	for (auto it = q.begin(); it != q.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
	return 0;
}

//解决办法
for(auto it=q.begin();it!=q.end();)
{
    if(*it>2)
    {
    	it=q.erase(it); // 这里会返回指向下一个元素的迭代器，因此不需要再自加了
    }
    else
    {
    	it++;
    }
}
```

**链表式容器失效**和**关联式容器失效**

**失效原因：**链表的插入和删除节点不会对其他节点造成影响，因此只会使得当前的iterator失效

**解决办法：**利用`erase`可以返回下一个有效的iteratord的特性，或者直接iterator++

```c++
//方法1
for (iter = cont.begin(); it != cont.end();)
{
   (*iter)->doSomething();
   if (shouldDelete(*iter))
      cont.erase(iter++);
   else
      iter++;
}
//方法2
for (iter = cont.begin(); iter != cont.end();)
{
   (*it)->doSomething();
   if (shouldDelete(*iter))
      iter = cont.erase(iter);  //erase删除元素，返回下一个迭代器
   else
      ++iter;
}
```





## 类型萃取traits（模板）、原因

- 类型萃取（type traits）使用**模板技术**来萃取类型（包含自定义类型和内置类型）的某些特性，用以判断该类型是否含有某些特性，从而**在泛型算法中来对该类型进行特殊的处理用来提高效率或者得到其他优化**。

  简单的来说**类型萃取即确定变量去除引用修饰以后的真正的变量类型或者 CV 属性**。C++ 关于 type traits 的详细使用技巧可以参考头文件 #include <type_traits>。

**为什么需要 type traits：**

- 使用模板时确定变量的类型就比较困难，模板传入的类型为不确定性
  - **为什么需要确定变量的实际类型**？因为模板函数针**对传入的对不同的类型可能作出不同的处理**，这就需要我们在**处理函数模板对传入的参数类型和特性进行提取**。比如自定义拷贝函数 copy(T *dest, const T *src) ，如果 T 此时为 int 类型，则此时我们只需要 *dest = *src 即可，但是如果我们此时传入的 T 为 char * 字符串类型时，则就不能简单进行指针赋值，所以**函数在实际处理时则需要对传入的类型进行甄别，从而针对不同的类型给予不同的处理，这样才能使得函数具有通用性**。
- remove_reference_t 的原理：
  - move 函数在进行强制类型转换时，会使用到 remove_reference_t，该函数的作用是**确定函数除去 C-V 和引用后的类型**。
  - 通过 remove_reference_t<T> 可以把 t 对应的类型上的引用给去掉，然后把 t 对应的类型的右值引用符号 && 强制绑定在变量 t 上，这样就强制将变量 t 转换为右值引用类型
- C++ **类型萃取一般用于模板中**，当我们定义一个模板函数后，需要知道**模板类型形参**并加以运用时就奥数可以用类型萃取。通过**确定变量的特征我们可以在模板中使用不同的处理方法**

```cpp
// 需要在T为int类型时，Compute方法的参数为int，返回类型也为int，
// 当T为float时，Compute方法的参数为float，返回类型为int
template <typename T>
class Test {
public:
     TraitsHelper<T>::ret_type Compute(TraitsHelper<T>::par_type d);
private:
     T mData;
};

template <typename T>
struct TraitsHelper {
     typedef T ret_type;
     typedef T par_type;
};

// 模板偏特化，处理int类型
template <>
struct TraitsHelper<int> {
     typedef int ret_type;
     typedef int par_type;
};

// 模板偏特化，处理float类型
template <>
struct TraitsHelper<float> {
     typedef float ret_type;
     typedef int par_type;
};
```

当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同时，traits会是一种很好的解决方案。











## 红黑树的特性，原因、与平衡树的区别

**红黑树的特性，原因**

虽然平衡树解决了**二叉查找树退化为近似链表**的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于 1，导致每次进行插入/删除节点的时候，都需要通过**左旋和右旋**来进行调整，使之再次成为一颗符合要求的平衡树。**如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，**

**红黑树具有如下特点：**

1. 具备二叉查找树的特点；
2. 根节点是黑色的；
3. 每个叶子节点都是黑色的空节点，也就是说叶子节点不存数据；（叶子节点是为空的叶子节点）
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 每个节点，从该节点到达其可达的叶子节点，都包含相同数目的黑色节点；

**红黑树和平衡树（AVL）的区别？**

1. RBT的是**近似平衡的二叉搜索树**，就是RBT的左右子树的高度差不会严格小于1，只是保证没有一条路径会比其他路径长出俩倍。但是AVL是严格平衡的，左右子树的高度差保证严格小于1。
2. RBT节点的增加和删除，由于不要求严格平衡，所以可以通过**改变节点的颜色来减少节点的旋转次数**，在插入和删除效率上会比AVL高。
3. 由于不要求严格平衡，所以RBT的搜索效率会略低于AVL
4. RBT和AVL都是二叉查找树



### 红黑树比AVL优势、与B+树的区别

**红黑树比AVL优势：**

红黑树的**查询性能略微**逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在**插入和删除**上完爆avl树，
avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持**红黑性质所做的红黑变换和旋转的开销**，相较于avl树为了维持平衡的开销要小得多



**红黑树和B+树区别：**

1. **红黑树**：红黑树的每一个节点都包含一个键值和一个颜色位（红色或黑色）。此外，它有指向其左右子节点和父节点的指针。
2. **B+树**：B+树的内部节点不存储数据，只存储键值和指向其子节点的指针。所有的数据值都在叶子节点，叶子节点一般通过链表连接，便于进行范围查询。对于B+树，树的度（每个节点的孩子数）通常比二叉树大得多，这在磁盘读写优化中是一个重要的因素，因为这样可以减少磁盘I/O操作。
3. 红黑树的节点数目通常比B+树的节点数目多。

**范围查找的区别：**

1. **红黑树**：在红黑树中进行范围查找需要先找到范围的起始键，然后通过中序遍历去寻找其他在范围内的键。这可能需要遍历树的大部分区域，如果树的平衡性不好，可能会导致效率较低。
2. **B+树**：B+树的所有键值都存储在叶子节点，而且叶子节点之间通过链表连接，所以范围查找非常高效。只需要找到范围的起始键，在叶子节点链表上顺序查找即可，因此在处理范围查询方面，B+树比红黑树更有优势。





红黑树的高度

从任何一个节点到其最远的后代叶子的节点数不超过到最近的后代叶子的节点数的两倍。
每个具有 n 个节点的红黑树的高度 <= 2Log 2 (n+1)

判断链表是不是环形链表

基于循环次数判断的暴力方法
如果一个链表不成环，那么它就是可以穷尽的，我们假定你的链表的节点的个数小于10^4个，如果比这个还多的话，也许你需要用到树型结构了，不然你的速度会比乌龟还慢。因此我们可以一直循环，循环的时候，要么是因为到达了指针的尾部NULL，要么是因为循环次数太多超越了节点的个数，循环结束时判断循环次数就可以了。
**借助Hash表**
每次访问节点的时候都判断是否在hash表中，如果没有就加入，如果存在就说明有环，如果没有环，一个节点只可能被访问一次,这和我们企图修改链表的数据结构去维护访问次数是等价的，只是以一种不影响节点内容的方式去完成。
**快慢指针**
定义两种类型的指针，slow慢指针前进步长为1，快指针前进步长为2（在第一次前进后要判断前进后是否到达了NULL）。这样，如果在循环的过程中，快指针追上了慢指针，那么说明成了环。

队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是
“后进先出”。

注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收。分配方式类似于链表。
它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域



双链表和单链表的优缺点

**单向链表：**单向链表包含两个域，一个是信息域，一个是指针域。也就是单向链表的节点被分成两部分，一部分是保存或显示关于节点的信息，第二部分存储下一个节点的地址，而最后一个节点则指向一个空值。
**优点：**单向链表增加删除节点简单。遍历时候不会死循环。（双向也不会死循环，循环链表忘了进行控制的话很容易进入死循环）；缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。

**双向链表：**每个节点有2个链接，一个是指向前一个节点（当此链接为第一个链接时，指向的是空值或空列表），另一个则指向后一个节点（当此链接为最后一个链接时，指向的是空值或空列表）。意思就是说双向链表有2个指针，一个是指向前一个节点的指针，另一个则指向后一个节点的指针。
**优点：**可以找到前驱和后继，可进可退；缺点：增加删除节点复杂。









# 编译及调试========================



## 编译流程（预处理 -> 编译 -> 汇编 -> 链接）

从 `gcc hello.c` 到 `./a.out` 之间发生什么？**源代码到可执行程序的流程**

这个过程有四个步骤：

**预处理 -> 编译 -> 汇编 -> 链接**

- **预处理**

  生成test.i文件，做一下处理：

  1. 展开宏定义
  2. 处理#if，#end，#ifndef
  3. 处理#include指令，把.h文件插入对应位置
  4. 删除注释

- **编译**

  编译过程所进行的是**对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码文件test.s**

  词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。词法分析程序实现这个任务。词法分析程序可以使用lex等工具自动生成。

  语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述.

  语义分析是编译过程的一个逻辑阶段. 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查, 进行类型审查

  生成test.s文件

- **汇编**

  将**汇编代码转成二进制文件**，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。**生成test.o文件**

- **链接**

  将**二进制文件变成一个可执行文件**。链接会涉及到动态链接和静态链接。



**预处理**

预处理用于将所有的 `#include` **头文件以及宏定义替换成其真正的内容**，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc 的预处理是**预处理器cpp来完成的**，你可以通过如下命令对 `test.c` 进行预处理：

```bash
$ gcc -E hello.c -o hello.i
# 或者
$ cpp hello.c -> hello.i
```

**预处理的规则：**

1. 展开所有的宏定义，完成字符常量替换。
2. 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。

3. 处理#include指令，将被包含的文件插入到该指令所在位置。

4. 过滤掉所有注释语句。

5. 添加行号和文件名标识。

6. 保留所有#pragma编译器指令。

**当无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。**



**编译**

编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定**汇编代码(assembly code)** 的过程。

需要在这个过程中完成词法分析、语法分析、语义分析及优化产生的汇编代码。

```bash
$ gcc -S hello.i -o hello.s
```

编译过程完成后，**将生成程序的汇编代码test.s，这也是文本文件**。



**汇编**

汇编器将上面生成的汇编代码转为机器可以执行的指令。每一条汇编语句对应一条机器指令，这一步产生的文件叫做**目标文件，是二进制格式**。

当然这个目标文件，还需要**重定位**。

```bash
$ gcc -c hello.s -o hello.o
# 或者直接调用汇编器
$ as test.s -o test.o
```

**这一步会为每一个源文件产生一个目标文件**。

```bash
# 查看 obj 文件的主要段
$ objdump -h main.o
```





**链接**

链接过程将**多个目标文件以及所需的库文件(.so等)链接**成最终的**可执行文件**(executable file)。

1. **合并段**

   将各个文件不同的段合并起来，每个.o文件的.text段合并在一起.data段合并在一起，这样，在生成的可执行 文件中，各个段都只有一个，由于在链接时只需要加载代码段(.text段)和数据段（.data段和.bss段）。因此合并段之后，在系统给我们分配内存时，只需要分配两个页面大小就可以，分别存放代码和数据如图

2. **调整段偏移**

   合并段之后，必须进行的一个操作就是调整段偏移和段长度。每个进程都有自己的虚拟地址空间，都是从0地址开始的，将各个文件的各个段加载进来之后，段的大小会有所变化，相对于0地址的偏移量也会不同，因此我们需要调整段偏移和段偏移

3. **汇总所有符号**

   每个 obj 文件在编译时都会生成自己的符号表，要把这些符号都合并起来进行符号解析

4. **完成符号的重定位**

   在进行合并段，调整段偏移时，输入文件的各个段在连接后的虚拟地址就已经确定了，这一步完成后，连接器开始计算各个符号的虚拟地址，因为各个符号在段内的相对位置是固定的，所以段内各个符号的地址也已经是确定的了，只不过连接器需要给每个符号加上一个偏移量，使他们能够调整到正确的虚拟地址，这就是符号的重定位过程

   在 elf 文件中，有一个叫**重定位表**的结构专门用来保存这些与从定位有关的信息，重定位表在elf文件中往往是一个或多个段





## 静态和动态链接库的建立、区别、应用场景

**静态和动态链接库的建立**

- **静态链接**

<img src="https://img-blog.csdnimg.cn/img_convert/b6c466a08f8ea6a626a1a2087816edd6.png" alt="img" style="zoom: 80%;" />

静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib\*\*\*\*.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快。

```bash
$ gcc -c test1.c    # 生成test1.o
$ gcc -c test2.c    # 生成test2.o
$ ar cr libtest.a test1.o test2.o  # 生成静态库
```

首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。

```bash
$ gcc -o main main.c -ltest
```

- **动态链接**

<img src="https://img-blog.csdnimg.cn/img_convert/040d3b4dd5b5dbe0db05e33fefae7dd5.png" alt="img" style="zoom:80%;" />

静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果**多个程序**都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。

动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC 选项，打包时加上-shared选项。

```bash
$ gcc -fPIC -c test1.c # -fPIC:生成位置无关的代码
$ gcc -fPIC -c test2.c
$ gcc -shared test1.o test2.o -o libtest.so  # 生成动态库
```

- **动态链接和静态链接的比较**

1. 动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。
2. 动态库另一个有点就是**更新很容易**，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。

3. 不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。



**静态、动态链接库的区别**

1. 静态库代码装载的速度快，执行速度略比动态库快。
2. 动态库更加节省内存，可执行文件体积比静态库小很多。
3. 静态库是在编译时加载，动态库是在运行时加载。
4. 生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

1. **静态链接**
   - **特点**：静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；
   
     在生成可执行文件的时候(链接阶段)，把所有需要的函数的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表。
   
   - **优点**：在程序发布的时候就**不需要的依赖库**，也就是不再需要带着库一块发布，程序可以独立执行。
   
   - **缺点**：程序体积会相对大一些；如果静态库有更新的话，所有可执行文件都得**重新链接**才能用上新的静态库。
   
2. **动态链接**
   - **特点：** 在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。
   - **优点：** 多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝。
   - **缺点：** 由于是运行时加载，可能会影响程序的前期执行性能。
   
   

**应用场景**

- 当该当链接库还需要链接其它的链接库，包括静态或者动态链接库的场合，应该使用动态链接库。
- 在库文件需要频繁更新时，考虑使用动态链接，可以避免更新时的重新链接
- 动态链接库.dll可以链接到不同编程语言的工程，所以对于多语言的软件开发的场合可以考虑动态链接。
- 在考虑运行速度的小型应用中，应该使用静态链接。



## 动态和静态编译、动态和静态联编、动态和静态绑定

**动态编译和静态编译**

静态编译，编译器在编译可执行文件时，把需要用到的对应链接库中的部分提出来，连接到可执行文件中，使可执行文件在运行时不需要依赖于动态链接库。

动态编译，可执行文件需要**附带一个动态链接库**，在执行的时候，需要调用其对应动态链接库的命令。优点是缩小了执行文件本身的体积，另一方面加快了编译速度，节省系统资源。缺点是需要附着一个动态链接库，当这个**库很大的时候很麻烦**；其次是如果该环境没有安装对应的库，动态编译的可执行文件不能运行。



**动态联编和静态联编**

在c++中联编指的是计算机程序不同部分彼此关联起来的过程。

静态联编指**联编工作在编译期完成，这种联编过程是在程序运行之前完成的，又叫做早期联编**。如果要实现静态联编，就必须在编译阶段**确定程序中的操作调用与执行该操作代码的关系**。静态联编对函数的选择是基于执行对象的指针或引用的类型，优点是效率高，但灵活性太差。

动态联编指的是**程序运行的时候动态的进行**。实际上是**虚函数的实现过程，又叫做晚期联编**。动态联编对成员函数的选择是基于对象类型的，针对不同对象类型做出不同编译结果。

c++一般情况下的联编是静态联编，当涉及到虚函数的时候就会使用动态联编。



**静态绑定、动态绑定的实现**

- **静态绑定（Static Binding）**： 静态绑定是在编译时确定的绑定方式。在静态绑定中，编译器在编译时就能够确定方法调用的具体实现。这通常发生在以下情况下：

  - 当使用普通的函数调用（非虚函数或非动态多态性）时，编译器可以根据编译时的类型信息直接决定要调用的方法。
  - 当使用静态方法（通常是类方法）时，因为它们不依赖于对象的实际类型，所以编译器可以在编译时确定调用的方法。

  静态绑定通常效率更高，因为在编译时就确定了方法的调用，不需要运行时的额外开销。

- **动态绑定（Dynamic Binding）**： 动态绑定是在运行时确定的绑定方式，也称为运行时多态性。在动态绑定中，方法的具体实现是根据对象的实际类型来决定的，而不是编译时的类型。这通常发生在以下情况下：

  - 当使用虚函数（virtual function）时，编译器会创建一个虚函数表（vtable），其中包含了各个虚函数的地址。在运行时，通过对象的指针或引用，可以动态查找并调用正确的虚函数。
  - 当使用继承和多态性时，子类对象可以替代父类对象，并且调用子类重写的虚函数时会调用子类的实现。

  

  **引用是否能实现动态绑定，为什么引用可以实现**
  可以。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。









## 调试流程

### 有哪些引起程序崩溃的原因？如何定位？

> 引起程序崩溃的原因

1. 数组越界
2. 访问非法指针（野指针，或者在用户空间访问了内核空间的指针）
3. 堆栈溢出
4. 除数为0

**定位的话使用gdb调试即可**



### 简述 GDB 常见的调试命令，什么是条件断点，多进程下如何调试？

**GDB调试**：gdb调试的是可执行文件，在gcc编译时加入 -g ，告诉gcc在编译时加入调试信息，这样gdb才能调试这个被编译的文件 gcc -g tesst.c -o test

**GDB命令格式：**

1. quit：退出gdb，结束调试

2. list：查看程序源代码

   list 5，10：显示5到10行的代码

   list test.c:5, 10: 显示源文件5到10行的代码，在调试多个文件时使用

   list get_sum: 显示get_sum函数周围的代码

   list test.c get_sum: 显示源文件get_sum函数周围的代码，在调试多个文件时使用

3. reverse-search：字符串用来从当前行向前查找第一个匹配的字符串

4. run：程序开始执行

5. help list/all：查看帮助信息

6. break：设置断点

   break 7：在第七行设置断点

   break get_sum：以函数名设置断点

   break 行号或者函数名 if 条件：以条件表达式设置断点

7. watch 条件表达式：条件表达式发生改变时程序就会停下来

8. next：继续执行下一条语句 ，会把函数当作一条语句执行

9. step：继续执行下一条语句，会跟踪进入函数，一次一条的执行函数内的代码

**条件断点：**break if 条件 以条件表达式设置断点

**多进程下如何调试：**

- 用set follow-fork-mode child **调试子进程**
- 或者set follow-fork-mode parent **调试父进程**



### 说一下如何使用gdb调试段错误？

1. 在编译过程中，需要加入 `-g` 选项，来加入 gdb 调试的功能
2. 使用 gdb 来运行发生段错误的程序
3. 进入 gdb 调试界面后，输入 `run` 命令运行
4. 段错误一般都是操作系统发出了 `SIGSEGV` 信号，导致程序中断
5. 使用 `backtrace` 命令查看程序的函数调用栈
6. 定位出现问题的堆栈帧，使用 `frame x` 命令切换到指定的堆栈帧 x，查看具体的代码，使用 `print` 命令查看具体参数是否存在问题。
7. 为发生段错误的前面代码添加断点，从断点开始使用 `next` 命令单步执行，最终定位段错误的问题区域。



### gcc常用参数

- -v/--version：查看gcc的版本
- -I：编译的时候指定头文件路径，不然头文件找不到
- -c：将汇编文件转换成二进制文件，得到.o文件
- -g：gdb调试的时候需要加
- -D：编译的时候指定一个宏（调试代码的时候需要使用例如printf函数，但是这种函数太多了对程序性能有影响，因此如果没有宏，则#ifdefine的内容不起作用）
- -wall：添加警告信息
- -On：-O是优化代码，n是优化级别：1，2，3





执行过程

创建子进程

<img src="https://pic1.zhimg.com/80/v2-8bc2eb74785e0486e6c67482030243d0_720w.jpg" alt="img"  />

当通过 shell 执行 C++ 可执行程序后，系统会拷贝当前进程空间的内容，创建子进程空间。然后会清空子进程的空间（包括原动态库、数据段、代码段以及堆栈），只保留环境变量部分。之后内核可以调用 loader() 程序将可执行文件内容加载到子进程内存空间。

加载可执行程序

loader 的作用是将可执行程序内容移动到虚拟内存相应地址当中。loader 根据每一个部分(section) 的读写属性将其归入不同的段（segment）内，然后将各个段加载到虚拟内存中。

用 readelf --segments regularBuild 命令可以查看可执行程序 regularBuild的各个段的组成。可见，该程序由九个段组成，其中类型为 LOAD的段是运行时需要加载的段。权限为RE（可读可执行）的 LOAD 段为程序的代码段，权限为 RW (可读可写) 的 LOAD 段为程序的数据段。

loader 会根据 INTERP 段的内容加载动态链接库。若要完全避免动态链接（包括C++ 标准库）过程，可以用 -static关键字编译：

 g++ -static main.c -o staticBuild 。

loader 通过可执行程序的头部信息获得各个段的长度和虚拟地址，将其赋值到一系列结构体对象中，再根据这些信息和内存管理单元（MMU）将各个段加载到物理内存中。

main() 函数的执行

当然 `main()` 执行之前还需要进行其他操作。



经典面试题

链接时含有多个重名函数会报错吗？

- [ ] 分两点回答：直接链接 + 以库的形式链接

1. **直接链接**

   ```bash
   gcc -c ./test1.c
   gcc -c ./test2.c
   gcc -o main ./test1.o ./test2.o ./main.c
   ```

   将包含同名函数的目标文件进行链接，如果其在同一个命名空间中，会报 `multiple definition` 错误。

2. **以库的形式链接**

   ```bash
   g++ -c ./test1.c
   g++ -c ./test2.c
   ar crv libtest1.a test1.o # 创建静态库
   ar crv libtest2.a test2.o # 创建静态库
   gcc -L. ./main.c -ltest1 -ltest2 -o main
   ```

**静态链接**

1. 编译器根据链接先后顺序，依次查找链接库。
2. 首先查找`libtest1.a`，发现其有main函数需要的函数`void test()`，因此将其进行了链接。
3. 再扫描到`libtest2.a`的时候，由于`void test()`已经被`libtest1.a`中的符号提供，因此不再链接。

**动态链接**

1. 在动态链接时，不同的链接库可以有同名函数，不影响编译。这是由动态链接库的性质决定的，其只有在运行时才会动态加载，并且加载的顺序是由编译时链接的顺序决定的。



头文件相互引用会发生什么？如何解决？写一个判断文件相互引用的程序

在一个头文件内引用定义在另一个头文件内的类。需要在使用这个类之前加入这个类的声明。

判断的话，可以先根据头文件的有引用情况建议一个文件引用的图，然后对文件引用图进行拓扑排序，判断图中是否有环，有环则代表存在相互引用。











现场手撕题

运算符重载

赋值运算符重载（类）

例题：如下为类 `CMyString` 的声明，请为该类添加赋值运算符函数：

**注意的点**：

1. 返回值 `string&` 
2. 参数 `const string&` 
3. 判断自赋值

```c++
class CMyString {
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    CMyString& operator= (const CMyString& str);
    ~CMyString();

private:
    char* pData_;
};

// 一般解法（在new抛出异常时，执行赋值的对象也被改变了）
CMyString& CMyString::operator= (const CMyString& str) {
    if(this == &str)
        return *this;
    
    delete[] pData_;
    pData = nullptr;
    pData = new char[strlen(str.pData_) + 1];
    
    // 如果 char*不是字符串，则里面可能存在'\0'，可以考虑使用memcpy()
    strcpy(pData_, str.pData_);
    
    return *this;
}

// 考虑异常安全性
CMyString& CMyString::operator= (const CMyString& str) {
    if(this == &str)
        return *this;

    // 构造函数里面使用new，可能会抛出异常，导致返回的实例状态不确定
    CMyString temp(str);

    // 构造成功，再交换
    char* pTemp = temp.pData_;
    temp.pData_ = pData_;
    pData_ = pTemp;

    return *this;
}
```







实现常用数据结构

实现 string 类

```cpp
class MyString {
public:
    MyString(const char* pData = nullptr);
    MyString(const MyString& str);
    MyString& operator= (const MyString& str);
    ~MyString();

    size_t size() const { return _size; }
    const char* c_str() const { return _pData; }

private:
    char* _pData;
    size_t _size;
};

MyString::MyString(const char* pData) {
    // 空指针也要赋值
    if (pData == nullptr) {
        _size = 0;
        _pData = new char[1];
        *_pData = '\0';
    }
    else {
        _size = strlen(pData);
        _pData = new char[_size + 1];
        strcpy(_pData, pData);
    }
}

MyString::MyString(const MyString& str) {
    _size = str.size();
    _pData = new char[_size + 1];
    strcpy(_pData, str.c_str());
}

MyString::~MyString() {
    delete[] _pData;
    _pData = nullptr;
    _size = 0;
}

MyString& MyString::operator= (const MyString& str) {
    if (this == &str) {  // 检查自赋值 
        return *this;
    }
    delete[] _pData;
    _size = str.size();
    _pData = new char[_size + 1];
    strcpy(_pData, str.c_str());
    return *this;
}
```



# 设计模式

## 6⼤设计原则、分三类、⼏种设计模式：

**6⼤设计原则：**

**单⼀职责原则：**就⼀个类⽽⾔，应该仅有⼀个引起它变化的原因。

**开放封闭原则：**软件实体可以扩展，但是不可修改。即⾯对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。

**⾥⽒代换原则：**⼀个软件实体如果使⽤的是⼀个基类，那么⼀定适⽤于其派⽣类。即在软件中，把基类替换成派⽣类，程序的⾏为没有变化。

**依赖倒转原则：**抽象不应该依赖细节，细节应该依赖抽象。即针对接⼝编程，不要对实现编程。

**迪⽶特原则：**如果两个类不直接通信，那么这两个类就不应当发⽣直接的相互作⽤。如果⼀个类需要调⽤另⼀个类的某个⽅法的话，可以通过第三个类转发这个调⽤。

**接⼝隔离原则：**每个接⼝中不存在派⽣类⽤不到却必须实现的⽅法，如果不然，就要将接⼝拆分，使⽤多个隔离的接⼝。



**单⼀职责原则和接⼝隔离原则的区别**

单⼀职责原则注重的是职责；⽽接⼝隔离原则注重对接⼝依赖的隔离。

单⼀职责原则主要是约束类，其次才是接⼝和⽅法，它针对的是程序中的实现和细节； ⽽接⼝隔离原则主要

约束接⼝，主要针对抽象，针对程序整体框架的构建。



**设计模式分为三类：**

**创造型模式：**单例模式、⼯⼚模式、建造者模式、原型模式

**结构型模式：**适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式

**⾏为型模式：**责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模

式、策略模式、模板⽅法模式、访问者模式。



**⼏种设计模式：**

**单例模式：**保证⼀个类仅有⼀个实例，并提供⼀个访问它的全局访问点。

**⼯⼚模式：**包括简单⼯⼚模式、抽象⼯⼚模式、⼯⼚⽅法模式

**简单⼯⼚模式：**主要⽤于创建对象。⽤⼀个⼯⼚来根据输⼊的条件产⽣不同的类，然后根据不同类的虚函数得到不同的结果。

**抽象⼯⼚模式：**定义了⼀个创建⼀系列相关或相互依赖的接⼝，⽽⽆需指定他们的具体类。

**观察者模式：**定义了⼀种⼀对多的关系，让多个观察对象同时监听⼀个主题对象，主题对象发⽣变化时，会通知所有的观察者，使他们能够更新⾃⼰。

**装饰模式：**动态地给⼀个对象添加⼀些额外的职责，就增加功能来说，装饰模式⽐⽣成派⽣类更为灵活









## 单例模式注意点、优点、饿汉和懒汉代码

**注意点：**

- 全局只有一个实例，`static` 特性，同时禁止用户自己声明并定义实例（将构造函数和赋值运算符设为 `private` ）
- 线程安全
- 用户通过接口获取示例：使用 `static` 类成员函数
- 客户调⽤类的单个实例只允许使⽤⼀个公共访问点，除了该访问点之外不允许通过其它⽅式访问该实例（就是共有的静态⽅法）

**优点：**

单例模式只创建一个实例，并提供一个对外获取实例的接口，因为只创建一个实例所以它可以节省资源，而且在多线程条件下可以避免竞态条件。



**懒汉和饿汉：**

饿汉：饿了就饥不择⻝了，所以在单例类定义的时候就进⾏实例化。

懒汉：顾名思义，不到万不得已就不会去实例化类，也就是在第⼀次⽤到的类实例的时候才会去实例化。

**饿汉模式（线程安全）：**

在最开始的时候静态对象就已经创建完成，设计⽅法是类中包含⼀个静态成员指针，该指针指向该类的⼀个对象，

提供⼀个公有的静态成员⽅法，返回该对象指针，为了使得对象唯⼀，构造函数设为私有。

```c++
#include <iostream>
#include <algorithm>
using namespace std;
class SingleInstance {
public:
    // 静态成员函数，用于获取单例实例
    static SingleInstance* GetInstance() {
        // 在第一次调用时创建唯一实例
        static SingleInstance instance;
        return &instance;
    }
    // 析构函数（可省略，由于没有资源管理，所以可以不实现）
    ~SingleInstance() {};
private:
    // 构造函数私有化，防止外部创建对象
    SingleInstance() {
        std::cout << "SingleInstance() 饿汉" << std::endl;
    }
    // 阻止拷贝构造函数和赋值操作符
    SingleInstance(const SingleInstance& other) {};
    SingleInstance& operator=(const SingleInstance& other) { return *this; }
};
int main() {
    // 通过静态成员函数获取单例实例
    SingleInstance* ins = SingleInstance::GetInstance();
    return 0;
}
// 输出 SingleInstance() 饿汉
这个代码中，SingleInstance类的构造函数是私有的，这意味着无法在类外部创建实例。通过静态成员函数GetInstance返回单例实例，确保只有一个实例被创建。饿汉式单例模式在程序启动时就创建了实例，因此被称为"饿汉式"，而不是在第一次使用时才创建（懒汉式）。
```

**懒汉模式（线程安全需要加锁）：**

尽可能的晚的创建这个对象的实例，即在单例类第⼀次被引⽤的时候就将⾃⼰初始化，C++ 很多地⽅都有类型的思想，⽐如写时拷⻉，晚绑定等

```C++
#include <pthread.h>
#include <iostream>
#include <algorithm>
using namespace std;
class SingleInstance {
public:
    // 获取单例实例的静态成员函数
    static SingleInstance* GetInstance() {
        // 检查实例是否已经创建
        if (ins == nullptr) {
            // 使用互斥锁确保多线程环境下的安全性
            pthread_mutex_lock(&mutex);
            // 再次检查实例是否已经创建，因为其他线程可能在等待锁的时候已经创建了实例
            if (ins == nullptr) {
                ins = new SingleInstance();
            }
            pthread_mutex_unlock(&mutex);
        }
        return ins;
    }
    // 析构函数（可省略，由于没有资源管理，所以可以不实现）
    ~SingleInstance() {};
private:
    // 构造函数私有化，防止外部创建对象
    SingleInstance() {
        std::cout << "SingleInstance() 懒汉" << std::endl;
    }
    // 阻止拷贝构造函数和赋值操作符
    SingleInstance(const SingleInstance& other) {};
    SingleInstance& operator=(const SingleInstance& other) { return *this; }
    // 静态成员变量，用于保存唯一实例
    static SingleInstance* ins;
    // 互斥锁，用于保证多线程环境下的安全性
    static pthread_mutex_t mutex;
};
// 静态成员变量初始化
SingleInstance* SingleInstance::ins = nullptr;
pthread_mutex_t SingleInstance::mutex;
int main() {
    // 通过静态成员函数获取单例实例
    SingleInstance* ins = SingleInstance::GetInstance();
    // 删除单例实例（不是必需的，可以省略，因为操作系统会在程序结束时回收内存）
    delete ins;
    return 0;
}
// 输出 SingleInstance() 懒汉
这个代码中，SingleInstance类的构造函数是私有的，这意味着无法在类外部创建实例。通过静态成员函数GetInstance返回单例实例，确保只有一个实例被创建。互斥锁用于在多线程环境下确保只有一个线程能够创建实例，避免了多线程竞争条件。懒汉式单例模式在第一次使用时才创建实例。
```



### 使用智能指针和锁（安全单例模式）

 智能指针和双重锁机制实现的**线程安全单例模式**

- 使用 `mutex` 是为了避免多个线程同时获取单例，造成实例化出两个单例对象。
- 使用智能指针是为了避免将释放单例对象的操作交给用户，容易造成内存泄漏。
- 使用双检锁，因为第一次判断通过后才加锁（如果没有第二次判断的话，第一次判断后，另一线程创建出示例，那么会实例化出两个单例对象）

```c++
#include <iostream>
#include <memory>
#include <mutex>
class Singleton {
public:
    // 使用智能指针作为单例指针类型
    using Ptr = std::shared_ptr<Singleton>;
    // 析构函数，用于在单例销毁时输出消息
    ~Singleton() {
        std::cout << "destructor called!" << std::endl;
    }
    // 删除拷贝构造函数和赋值操作符，防止复制和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    // 获取单例实例的静态成员函数
    static Ptr getInstance() {
        // 双重锁检查
        if (m_pInstance == nullptr) {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (m_pInstance == nullptr) {
                m_pInstance = Ptr(new Singleton); // 创建单例实例
            }
        }
        return m_pInstance;
    }
private:
    // 构造函数私有化，防止外部创建实例
    Singleton() {
        std::cout << "constructor called!" << std::endl;
    }
private:
    // 静态成员变量，用于保存唯一实例
    static Ptr m_pInstance;
    // 互斥锁，用于保证多线程环境下的安全性
    static std::mutex m_mutex;
};
// 初始化静态成员变量
Singleton::Ptr Singleton::m_pInstance = nullptr;
std::mutex Singleton::m_mutex;
int main() {
    // 通过静态成员函数获取单例实例
    Singleton::Ptr instance = Singleton::getInstance();
    return 0;
}
```



### 使用局部静态变量（面试就写这个）

函数的静态变量，如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。从而保证了线程安全。

```c++
#include <iostream>
class Singleton {
public:
    // 析构函数，用于在单例销毁时输出消息
    ~Singleton() {
        std::cout << "destructor called!" << std::endl;
    }
    // 删除拷贝构造函数和赋值操作符，防止复制和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    // 获取单例实例的静态成员函数
    static Singleton& getInstance() {
        // 在首次调用时创建唯一实例，利用了C++11的线程安全性保证
        static Singleton instance;
        return instance;
    }
private:
    // 构造函数私有化，防止外部创建实例
    Singleton() {
        std::cout << "constructor called!" << std::endl;
    }
};
int main() {
    // 通过静态成员函数获取单例实例
    Singleton& instance = Singleton::getInstance();
    return 0;
}
```









### 懒汉式局部静态变量提前销毁有什么办法（销毁后不会再创建了）

设置一个bool标志位，然后把实例设置为NULL，然后获取实例的代码会先检查实例是不是NULL并且标志位是不是true，如果是的话直接返回NULL

### 懒汉模式中线程安全需要两次判空的目的

懒汉式单例模式中的“双重检查锁定”（double-checked locking）是一种多线程编程技巧，用来减少同步开销。

懒汉式单例模式是指在第一次使用时实例化单例对象，而不是在程序启动时。因为创建对象可能是一个耗时操作，所以如果该单例对象可能不被用到，使用懒汉式可以避免不必要的性能开销。

然而，这种方法在多线程环境中可能会导致问题。**如果多个线程同时尝试创建单例对象，可能会导致对象被多次创建，破坏单例模式的初衷。**

双重检查锁定是解决这个问题的一种方法。它的步骤是：

1. **首次检查**：如果单例对象已经创建，那么直接返回。这样可以避免已经创建了对象的情况下还要获取锁，从而减少了不必要的开销。
2. **获取锁**：如果对象还未创建，那么获取锁，防止其他线程同时创建对象。
3. **再次检查**：在获取锁之后，再次检查对象是否已经被创建。**这是因为在当前线程等待锁的期间，可能有其他线程已经创建了对象。如果已经创建，直接返回。**
4. **创建对象**：如果对象还未被创建，那么在锁的保护下创建对象。

这种方法可以保证单例对象在多线程环境中只被创建一次，并且在对象已经被创建后避免了获取锁的开销。然而，需要注意的是，这种方法在某些内存模型（例如Java的旧内存模型）中可能会因为重排序问题导致错误，需要使用volatile关键字或者其他方法来防止重排序。





### 如何保证单例模式的线程安全

C11之前双检测、C11后static

### 单例模式中的get方法为什么是static的，可不可以作为成员函数

static函数可以通过类名直接调用，不需要声明对象

不可以，单例私有化了构造函数，外部不可以声明对象，因此无法调用成员函数get

**单例模式它的主要目标是确保一个类只有一个实例，并提供一个全局访问点到这个实例。**



### 继承单例模式，有哪些需要注意的地方？

**实现要点：**

- 构造函数需要是 `protected`，这样子类才能继承；
- 将基类声明为友元，这样才能调用子类的**私有构造函数**。
- 使用了奇异递归模板模式 CRTP(Curiously recurring template pattern) ，`enable_shared_form_this<T>` 也是用的这个

- 基类实现同前

- 在这里基类的析构函数可以不需要 `virtual` ，因为子类在应用中只会用 `Derived` 类型，保证了析构时和构造时的类型一致

```c++
template<typename T>
class Singleton{
public:
    static T& getInstance(){
        static T instance;
        return instance;
    }
 
    virtual ~Singleton(){
        std::cout<<"destructor called!"<<std::endl;
    }
 
    Singleton(const Singleton&)=delete;
    Singleton& operator =(const Singleton&)=delete;
 
protected:
    Singleton(){
        std::cout<<"constructor called!"<<std::endl;
    }
};
 
/********************************************/
// Example:
// 1.friend class declaration is requiered!
// 2.constructor should be private
 
class DerivedSingle : public Singleton<DerivedSingle>{
    // !!!! attention!!!
    // needs to be friend in order to
    // access the private constructor/destructor
    friend class Singleton<DerivedSingle>;
 
public:
    DerivedSingle(const DerivedSingle&) = delete;
    DerivedSingle& operator =(const DerivedSingle&) = delete;
 
private:
    DerivedSingle() = default;
};
```



## 观察者模式

**观察者模式：**定义⼀种⼀（被观察类）对多（观察类）的关系，让多个观察对象同时监听⼀个被观察对象，被观察对象状态发⽣变化时，会通知所有的观察对象，使他们能够更新⾃⼰的状态。

观察者模式中存在两种⻆⾊：

**观察者：**内部包含被观察者对象，当被观察者对象的状态发⽣变化时，更新⾃⼰的状态。（接收通知更新状态）

**被观察者：**内部包含了所有观察者对象，当状态发⽣变化时通知所有的观察者更新⾃⼰的状态。（发送通知）

应⽤场景：

当⼀个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使⽤观察者模式；⼀个抽象模型有两个⽅⾯，其中⼀⽅⾯依赖于另⼀⽅⾯，这时可以⽤观察者模式将这两者封装在独⽴的对象中使它们各⾃独⽴地改变和复⽤。

<img src="https://pic2.zhimg.com/80/v2-0a7ef7d1a328dc37eadefb29e0ea705d_720w.jpg" alt="img"  />

```c++
class NonCopyable{
protected:
    NonCopyable() = default;
    ~NonCopyable() = default;
    NonCopyable(const NonCopyable &) = delete;
    NonCopyable& operator=(const NonCopyable &) = delete;
};

template <typename Func>
class Event : NonCopyable{
public:
    Event() = default;
    ~Event() = delete;
    // 注册观察者,支持右值引用
    int Attach(Func && f){
        return Assign(f);
    }
    // 注册观察者,支持左值引用
    int Attach(Func & f){
        return Assign(f);
    }
    // 移除观察者
    void Deatach(int iKey){
        m_mapOberserve.erase(iKey);
    }
    // 通知接口
    template <typename... Args>
    void Notify(Args&&... args){
        for(auto& it : m_mapOberserve)
        {
            it.second(std::forward<Args>(args)...);
        }
    }
private:
    template <typename F>
    int Assign(F && f){
        int k = m_iObersevre++;
        m_mapOberserve.emplace(k, std::forward<F>(f));
        return k;
    }
    
    int m_iObersevre = 0;
    std::map<int,Func> m_mapOberserve;
};
```



> 观察者模式和发布订阅模式的区别？

![img](https://pic2.zhimg.com/80/v2-b6ed65f370a766620718ad4227d5d4e5_720w.jpg)

- 在**观察者模式**里，当发布者发生事件时，会直接（**由自身**）通知所有订阅者。
- 在**发布订阅模式**里，发布者，**并不会直接通知订阅者**，换句话说，发布者和订阅者，彼此互不相识。发布订阅模式通过第三者，也就是在消息队列里面，我们常说的经纪人Broker。



## 工厂模式

### 简单工厂模式

建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或者接口）的实例。

```cpp
#include <iostream>
using namespace std;

// 产品类（抽象类，不能实例化）
class Product {
public:
    Product() {};
    virtual void show() = 0;  // 纯虚函数
};

class productA : public Product {
public:
    productA() {}
    void show() { cout << "product A create !" << endl; }
    ~productA() {}
};

class productB : public Product {
public:
    productB() {}
    void show() { std::cout << "product B create ! " << endl; }
    ~productB() {}
};

class simpleFactory {
public:
    simpleFactory() {}
    Product* product(const string str) {
        if (str == "productA")	return new productA();
        if (str == "productB")	return new productB();
        return nullptr;
    }
};
```



### 抽象工厂模式

⼯⼚模式⽬的就是代码解耦，如果我们不采⽤⼯⼚模式，如果要创建产品 A、B，通常做法采⽤⽤ switch...case语 句，那么想⼀想后期添加更多的产品进来，我们不是要添加更多的 switch...case 吗？这样就很麻烦，⽽且也不符 合设计模式中的开放封闭原则。

 为了进⼀步解耦，在简单⼯⼚的基础上发展出了抽象⼯⼚模式，即连⼯⼚都抽象出来，实现了进⼀步代码解耦。

```cpp
#include <iostream>
using namespace std;

// 产品类（抽象类，不能实例化）
class Product {
public:
    Product() {};
    virtual void show() = 0;  // 纯虚函数
};

class productA : public Product {
public:
    productA() {}
    void show() { cout << "product A create !" << endl; }
    ~productA() {}
};

class productB : public Product {
public:
    productB() {}
    void show() { std::cout << "product B create ! " << endl; }
    ~productB() {}
};

// 抽象工厂
class Factory {
public:
	virtual Product* CreateProduct() = 0;
};

// 工厂类A，只生产A产品
class FactoryA : public Factory {
public:
    Product* createProduct() {
        Product* _product = nullptr;
        _product = new ProductA();
        return _product;
    }
};

// 工厂类B，只生产B产品
class FactoryB : public Factory {
public:
    Product* createProduct() {
        Product* _product = nullptr;
        _product = new ProductB();
        return _product;
    }
};
```



### 模板工厂模式

针对工厂方法模式封装成模板工厂类，那么这样在新增产品时，是不需要新增具体的工厂类，减少了代码的编写量。

```cpp
#include <iostream>
using namespace std;

// 产品类（抽象类，不能实例化）
class Product {
public:
    Product() {};
    virtual void show() = 0;  // 纯虚函数
};

class productA : public Product {
public:
    productA() {}
    void show() { cout << "product A create !" << endl; }
    ~productA() {}
};

class productB : public Product {
public:
    productB() {}
    void show() { std::cout << "product B create ! " << endl; }
    ~productB() {}
};

// 抽象工厂
class Factory {
public:
	virtual Product* CreateProduct() = 0;
};

// 工厂类A，只生产A产品
class FactoryA : public Factory {
public:
    Product* createProduct() {
        Product* _product = nullptr;
        _product = new ProductA();
        return _product;
    }
};

// 抽象模板工厂类
// 模板参数：AbstractProduct_t 产品抽象类
template <typename AbstractProduct_t>
class AbstractFactory {
public:
    virtual AbstractProduct_t* createProduct() = 0;
    virtual ~AbstractFactory() {}
};

// 具体模板工厂类
// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类
template <typename AbstractProduct_t, typename ConcreteProduct_t>
class ConcreteFactory : public AbstractFactory<AbstractProduct_t> {
public:
    AbstractProduct_t* createProduct() {
        return new ConcreteProduct_t();
    }
}
```



## 装饰器模式

装饰器模式（Decorator Pattern）允许向⼀个现有的对象添加新的功能，**同时⼜不改变其结构**。

`装饰类` 和 `被装饰类` 可以独立发展，不会相互耦合，装饰器模式是继承的一个替代模式，装饰器模式可以动态地扩展实现一个类的功能。**可以将装饰器理解为扩展的功能！！！**

这种类型的设计模式属于结构型模式，它是作为现有的类的⼀个包装。

```cpp
#include <iostream>
#include <list>
#include <memory>
using namespace std;

class Car {
public:
	virtual void show() = 0;
};

// 三个实体的汽车类
class Bmw :public Car {
public:
	void show() {
		cout << "这是一辆宝马汽车，配置有：基本配置";
	}
};

class Audi :public Car {
public:
	void show() {
		cout << "这是一辆奥迪汽车，配置有：基本配置";
	}
};

class Benz :public Car {
public:
	void show() {
		cout << "这是一辆奔驰汽车，配置有：基本配置";
	}
};

// 装饰器1 定速巡航
class Decorator01 :public Car {
public:
	Decorator01(Car* p) : pCar(p) {}
	void show() {
		pCar->show();
		cout << "，定速巡航";
	}
private:
	Car* pCar;
};

// 装饰器2 自动刹车
class Decorator02 :public Car {
public:
	Decorator02(Car* p) : pCar(p) {}
	void show() {
		pCar->show();
		cout << "，自动刹车";
	}
private:
	Car* pCar;
};

// 装饰器3 定速巡航
class Decorator03 :public Car {
public:
	Decorator03(Car* p) : pCar(p) {}
	void show() {
		pCar->show();
		cout << "，车道偏离";
	}
private:
	Car* pCar;
};


int main() {
    // 以自身为装饰器的实例对象，来达到扩展功能的目的。
	Car* p1 = new Decorator01(new Bmw());
	p1 = new Decorator02(p1);
	p1 = new Decorator03(p1);
	p1->show();
	cout << endl;

	Car* p2 = new Decorator02(new Audi());
	p2->show();
	cout << endl;

	Car* p3 = new Decorator03(new Benz());
	p3->show();
	cout << endl;

	return 0;
}
```



## 代理模式

代理模式（Proxy Pattern）是一种结构型设计模式，其主要目的是为其他对象提供一个代理（代表）以控制对这个对象的访问。代理模式可以用于各种不同的场景，例如延迟加载，权限控制，远程代理等。

代理模式通常涉及以下几个角色：

1. **主题接口（Subject Interface）**：定义了真实主题和代理的公共接口，确保代理能够替代真实主题。
2. **真实主题（Real Subject）**：实际执行工作的对象，代理的真正目标。
3. **代理（Proxy）**：提供与真实主题相同的接口，但通常在代理内部包含一个引用（或指针）指向真实主题，代理可以控制对真实主题的访问。

代理模式的优点包括：

- 控制访问：代理可以用于限制对真实主题的访问，例如，通过权限控制来确保只有特定用户能够访问真实主题。
- 延迟加载：代理可以用于延迟加载真实主题，只有在需要时才会真正创建或初始化真实主题，提高性能。
- 远程代理：代理可以用于在客户端和远程服务器之间进行通信，隐藏底层通信细节。

代理模式的实现方式多种多样，下面是一个简单的示例，演示了代理模式的基本结构：

![](https://img-blog.csdnimg.cn/e7b59f2e6d3d4c0bada603b31a0f8ea2.png)







## 生产者消费者模式

```cpp
#include <condition_variable>
#include <mutex>
#include <queue>
#include <iostream>
#include <thread>
#include <Windows.h>

using namespace std;

const int PRODUCER_SIZE = 20;  // 生产者数量
const int CONSUMER_SIZE = 10;  // 消费者数量
const int MAX_SIZE = 10;       // 缓冲区大小

queue<int> que;  // 模拟缓冲区
mutex mtx;
condition_variable con;

// 生产者
void put() {
    while (true) {
        Sleep(5);
        unique_lock<mutex> lock(mtx);
        while (que.size() > MAX_SIZE) {
            con.wait(lock);
        }
        // 生产产品
        int data = rand();
        que.emplace(data);
        cout << this_thread::get_id() << " produce product : " << data << endl;
        con.notify_one();
    }
}

// 消费者
void take() {
    while (true) {
        unique_lock<mutex> lock(mtx);
        while (que.empty()) {
            con.wait(lock);
        }
        // 消费产品
        int data = que.front();
        que.pop();
        cout << this_thread::get_id() << " consume product : " << data << endl;
        con.notify_one();
    }
}

int main() {
    vector<thread> threadPool;
    for (int i = 0; i < PRODUCER_SIZE; ++i) threadPool.emplace_back(put);
    for (int i = 0; i < CONSUMER_SIZE; ++i) threadPool.emplace_back(take);

    for (int i = 0; i < PRODUCER_SIZE + CONSUMER_SIZE; ++i) {
        threadPool[i].join();
    }

    system("pause");
    return 0;
}
```



# 数据结构



### 说一下各种常见数据结构的优缺点？



| 数据结构 | 优点                                                       |                           缺点                           |
| :------- | :--------------------------------------------------------- | :------------------------------------------------------: |
| 数组     | 插入快，如果知道下标，可以非常快的存取                     |                 查找慢，删除慢，大小固定                 |
| 有序数组 | 比无序的数组查找快                                         |                  删除和插入慢，大小固定                  |
| 栈       | 提供后进先出方式的存取                                     |                      存取其他项很慢                      |
| 队列     | 提供先进先出方式的存取                                     |                      存取其他项很慢                      |
| 链表     | 插入快，删除快                                             |                          查找慢                          |
| 二叉树   | 查找，插入，删除都快（如果树保持平衡）                     |                       删除算法复杂                       |
| 红-黑树  | 查找，插入，删除都快，树总是平衡的                         |                         算法复杂                         |
| 2-3-4树  | 查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用 |                         算法复杂                         |
| 哈希表   | 如果关键字已知则存取极快，插入快                           | 删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分 |
| 堆       | 插入删除快，对最大数据项的存取很快                         |                    对其他数据项存取慢                    |
| 图       | 对现实世界建模                                             |                     有些算法慢且复杂                     |





# 其他：

## 100亿数据找最大的一万个数，找第k大的数

1. **找最大的一万个数**：

   **使用最小堆**（Min-Heap）。这种数据结构可以在O(logm)的时间内插入和删除元素，其中 m 是堆中的元素数量。

   步骤：

   - 创建一个容量为 10,000 的最小堆。
   - 遍历数据集中的每个数字：
     - 如果堆不满（即数量小于10,000），则向堆中插入该数字。
     - 如果堆已满并且当前数字大于堆顶的数字（堆顶是目前堆中的最小数字），则删除堆顶的数字，并将当前数字插入堆中。
   - 当所有数字都已遍历完，堆中的数字就是最大的10,000个数字。

   这种方法的时间复杂度近似为 O(nlogm)，其中 n 是数据集的大小，m 是要找的数字的数量（在这里 m = 10,000）。

   

   **使用分治**，我们可以将原始的数据分成若干小组，然后分别在每个小组中找到最大的一万个数。最后，从这些小组的结果中选出整体的最大一万个数。

   步骤：

   1. 将100亿个数分成若干小组。例如，每组有1000万个数。
   2. 对于每一组，使用任意方法（如排序或最小堆）找到该组中最大的一万个数。
   3. 将所有小组中选出的数合并成一个列表，这个列表有的元素数量会是 10000 * 小组的数量。
   4. 最后，再从这个合并后的列表中选出最大的一万个数。

2. **找第 k 大的数**：

   快速选择的基本思想是：如果基准元素在排序数组中的位置是 k，那么基准元素就是第 k 大的数。

   1. 快速选择（QuickSelect）算法就是基于分治思想的。

      步骤：

      1. 从列表中随机选择一个元素作为基准。
      2. 将列表分成两部分：一部分包含比基准小的元素，另一部分包含比基准大的元素。
      3. 判断 k 是在基准的左边还是右边：
         - 如果 k 等于右边部分的大小加1，那么基准就是我们要找的第 k 大的数。
         - 如果 k 小于右边部分的大小，说明第 k 大的数在右边，对右边的数据递归执行快速选择。
         - 否则，第 k 大的数在左边，对左边的数据递归执行快速选择，并对 k 进行相应调整。
      4. 递归进行，直到找到第 k 大的数。

      可以在平均情况下以 O(n) 的时间复杂度找到第 k 大的数。在最差的情况下，其时间复杂度是 O(n^2)，但可以通过随机化选择基准元素来避免这种情况。

   在分治思想的应用中，关键是如何将原问题分解成一个或多个更小的子问题，然后如何合并这些子问题的答案来得到原问题的答案。



## Linux命令相关

### 查找一个字符串是否在文件中命令

用grep命令，`grep "要查找的字符串" 文件名`,如果字符串存在于文件中，`grep` 命令将会输出包含该字符串的行。如果不存在于文件中，则不会输出任何内容。

### 查找本机一个端口号的状态

`netstat -tuln | grep 端口号`，在上述命令中，`-tuln` 选项用于显示 TCP 和 UDP 的监听端口，而 `grep` 命令用于过滤出指定的端口号。

### 查看CPU利用率

`top`命令

### 查看网络状态

`ifconfig`

单纯执行`netstat`是查看所有socket

只看TCP连接的网络信息`netstat -t`

### 网络测试

`ping`

### 判断远程服务的端口有没有开启

`telnet 远程主机地址 远程端口号`，使用 `telnet` 命令可以尝试与远程主机的指定端口建立连接。

如果连接成功，说明该端口是开启的；如果连接失败或超时，则说明该端口是关闭的。

### DNS查询

比如`host www.baidu.com`

### Linu命令常用

Linux删除文件的命令？  

Linux创建文件和文件夹的命令？  

Linux如何查看当前运行的进程状态？  

Linux如何指定查看某一个进程的信息？ 

Linux查看进程的CPU和内存占用率  

Linux中cp和scp命令分别是用来做什么的？ 

1. Linux删除文件的命令是 **`rm`**。例如，删除一个名为 `example.txt` 的文件，你可以使用命令 `rm example.txt`。
2. 在Linux中，创建文件的命令通常是 **`touch`**。例如，创建一个名为 `example.txt` 的文件，你可以使用命令 `touch example.txt`。创建文件夹的命令是 `mkdir`。例如，创建一个名为 `example` 的文件夹，你可以使用命令 `mkdir example`。
3. 在Linux中，查看当前运行的进程状态的命令通常是 `ps` **或 `top`**。`ps` 命令可以显示当前进程的快照，而 `top` 命令可以显示实时的进程状态。
4. 若要查看某个特定进程的信息，你可以使用 `ps` 命令并附上进程ID（PID）。例如，要查看PID为123的进程，你可以使用命令 **`ps -p 123`。**
5. 要**查看进程的CPU和内存使用情况，可以使用 `top` 命令。**这个命令会显示一个实时更新的列表，列出系统中的进程，并显示它们的CPU和内存使用情况。如果你只想看到一个特定的进程，可以使用 `top -p [PID]`，其中 `[PID]` 是进程ID。
6. 在Linux中，**`cp` 是一个复制文件或文件夹的命令**，比如 `cp source destination`。`scp` 是一个安全的远程文件复制命令，它在本地和远程计算机之间复制文件，并使用SSH进行数据传输，比如 `scp source user@remote:destination`。



### 查看当前进程

```ba
ps -ef | grep java  # 显示出所有关于java的进程

```

**杀死进程**


```bash
kill -9 PID
```

`kill -9`代表的信号是`SIGKILL`，表示进程被终止，需要立即退出；表示强制杀死该进程，这个信号不能被捕获也不能被忽略。



### 查看进程的线程

找到相关进程，然后记录pid

```
pstree -p 5346(进程ID)
top -H 所有线程
top -H -p <pid>
```

**如果要计算数量，可以用`wc -l`，-l表示要计算行数**

内核相关命令

uname

```bash
uname -r  # 查看内核版本
uname -a  #查看系统信息，内核名称，主机名，内核版本，处理器架构，处理器位数啥的
Linux VM-16-12-centos 3.10.0-1160.45.1.el7.x86_64 #1 SMP Wed Oct 13 17:20:51 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
cat /proc/version #跟uname -a一样
```

查看CPU信息

```bash
cat /proc/cpuinfo
```

依次打印每一个核数的相关信息

查看系统位数

```bash
getconf LONG_BIT
```

查看Linux版本

```bash
cat /etc/os-release

NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"

```

查看内核版本

```bash
cat /proc/version

Linux version 3.10.0-1160.45.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Wed Oct 13 17:20:51 UTC 2021

$arch即可查看linux的内核版本
```

Centos如何查看日志

```c++
/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一
/var/log/secure 与安全相关的日志信息
/var/log/maillog 与邮件相关的日志信息
/var/log/cron 与定时任务相关的日志信息
/var/log/spooler 与UUCP和news设备相关的日志信息
/var/log/boot.log 守护进程启动和停止相关的日志消息
/var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件
```

1、tail

```
tail  -n  10   test.log   查询日志尾部最后10行的日志;
```

2、head

```
head -n  10  test.log   查询日志文件中的头10行日志;
head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;
```

3、cat

直接查看全部

4、sed

这个命令可以查找日志文件特定的一段 ,可以按照行号和时间范围查询

```
sed -n '5,10p' filename 这样你就可以只查看文件的第5行到第10行。
sed -n '/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p'  test.log
```











## Linux50个命令总结

1. `ls`：列出目录中的文件和子目录。
2. `cd`：改变当前工作目录。
3. `pwd`：显示当前工作目录的路径。
4. `mkdir`：创建一个新目录。
5. `rm`：删除文件或目录。
6. `cp`：复制文件和目录。
7. `mv`：移动文件和目录，或者重命名文件。
8. **`touch`：创建一个新文件或更新已有文件的时间戳。**
9. **`cat`：连接文件并打印到标准输出。**
10. `more`：逐页显示文件内容。
11. `less`：与 `more` 类似，但允许向前和向后浏览文件。
12. `head`：显示文件的前几行。
13. `tail`：显示文件的后几行。
14. **`grep`：在文件中搜索指定的模式。**
15. **`find`：在文件系统中搜索文件和目录。**
16. `chmod`：修改文件或目录的权限。
17. `chown`：修改文件或目录的所有者。
18. `chgrp`：修改文件或目录的所属组。
19. `tar`：打包和解包文件。
20. `gzip`：压缩文件。
21. `sudo`：以管理员权限运行命令
22. `ps`：查看当前进程状态
23. **`top`：查看进程的CPU和内存使用情况**，top -H可以找到CPU使用率最高的线程
24. `gunzip`：解压缩文件。
25. `wget`：从网络上下载文件。
26. `ssh`：通过安全外壳（SSH）登录远程主机。
27. `scp`：在本地主机和远程主机之间复制文件。
28. `ping`：测试与另一台主机的网络连接。
29. **`ifconfig`：显示和配置网络接口信息。**
30. **`netstat`：显示网络连接和网络统计信息。**
31. **`ps`：显示当前运行的进程。**
32. `kill`：终止正在运行的进程。
33. `sudo`：以超级用户权限执行命令。

⚠️开发中一定要学会查看文档，通过`man`命令来查看，比如：`man ls`



### cat命令（显示文件内容）

- 显示文件内容，如果没有文件或文件为`-`则读取标准输入。
- 将多个文件的内容进行连接并打印到标准输出。
- 显示文件内容中的不可见字符（控制字符、换行符、制表符等）。

```bash
cat file1 从第一个字节开始正向查看文件的内容
tac file1 从最后一行开始反向查看一个文件的内容
cat ./1.log ./2.log ./3.log		# 合并显示多个文件
cat -n file1 标示文件的行数
cat filename | head -n 3000 | tail -n +1000 显示1000行到3000行
cat filename | tail -n +3000 | head -n 1000 从第3000行开始，显示1000(即显示3000~3999行)
```

### chmod（变更权限）

用来变更文件或目录的权限

- `u`符号代表当前用户。
- `g`符号代表和当前用户在同一个组的用户，以下简称组用户。
- `o`符号代表其他用户。
- `a`符号代表所有用户。
- `r`符号代表读权限以及八进制数`4`。
- `w`符号代表写权限以及八进制数`2`。
- `x`符号代表执行权限以及八进制数`1`。
- `X`符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限。
- `s`符号代表设置权限suid和sgid，使用权限组合`u+s`设定文件的用户的ID位，`g+s`设置组用户ID位。
- `t`符号代表只有目录或文件的所有者才可以删除目录下的文件。
- `+`符号代表添加目标用户相应的权限。
- `-`符号代表删除目标用户相应的权限。
- `=`符号代表添加目标用户相应的权限，删除未提到的权限。

```bash
# 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。
chmod u=rwx, g=rw, o=r ./test.log
# 等价的八进制数表示：
chmod 764 ./test.log
```

### chown （变更拥有者）

用来变更文件或目录的拥有者或所属群组

```bash
chown -R liu /usr/meng
# 将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu：
# -R表示递归处理
```

### top（CPU资源占用情况）

top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。

常用命令如下：

1. top默认：每隔5秒显式所有进程的资源占用情况
2. P：按%CPU使用率排行
3. M：按%MEM排行
4. T： 根据时间/累计时间进行排序。 
5. -d 秒数：每搁几秒显示所有进程的占用资源

### scp（不同Linux复制文件）

用于不同linux主机之间复制文件的

```shell
scp  local_file    remote_username@remote_ip:remote_file 
```

### find（找文件名）

找文件名

```shell
//带有正则表达式的
find . -name '[A-Z]*.txt' -print 
```

```shell
# 当前目录搜索所有文件，文件内容 包含 “140.206.111.111” 的内容
find .  -name "*" | xargs grep "140.206.111.111"
```

### sar（系统性能分析）

[参考](https://shockerli.net/post/linux-tool-sar/)

`sar`（System Activity Reporter 系统活动情况报告）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：**文件的读写情况、系统调用的使用情况、磁盘 I/O、CPU 效率、内存使用状况、进程活动及 IPC 有关的活动**等。我们可以使用`sar`命令来获得整个系统性能的报告。这有助于我们定位系统性能的瓶颈，并且有助于我们找出这些烦人的性能问题的解决方法。

- CPU 利用率

  ```bash
  sar -u [ <时间间隔> [ <次数> ] ]
  
  sar -u 1 3 
  Linux 2.6.32-642.13.1.el6.x86_64 (upfor106) 2018年04月25日 _x86_64_ (1 CPU)  
  10时33分08秒     CPU     %user     %nice   %system   %iowait    %steal     %idle
  10时33分09秒     all      0.00      0.00      0.00      0.00      0.00    100.00
  10时33分10秒     all      0.99      0.00      0.99      0.00      0.00     98.02
  10时33分11秒     all      0.00      0.00      0.00      0.00      0.00    100.00
  平均时间:        all      0.33      0.00      0.33      0.00      0.00     99.33
  
  CPU：all 表示统计信息为所有 CPU 的平均值。
  %user：显示在用户级别(application)运行使用 CPU 总时间的百分比
  %nice：显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比
  %system：在核心级别(kernel)运行所使用 CPU 总时间的百分比
  %iowait：显示用于等待I/O操作占用 CPU 总时间的百分比
  %steal：管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比
  %idle：显示 CPU 空闲时间占用 CPU 总时间的百分比
      1. 若 %iowait 的值过高，表示硬盘存在I/O瓶颈
      2. 若 %idle 的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量
      3. 若 %idle 的值持续低于1，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU
     
  ```

- 内存利用率

  ```bash
  sar -r [ <时间间隔> [ <次数> ] ]
  
  sar -r 1 3
  Linux 2.6.32-696.13.2.el6.x86_64 (upfor163) 2018年04月25日 _x86_64_ (2 CPU)
  10时53分00秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit
  10时53分01秒   2027760   2028732     50.01    145492   1243820   1163900     28.69
  10时53分02秒   2027620   2028872     50.02    145492   1243820   1163896     28.69
  10时53分03秒   2028100   2028392     50.00    145492   1243820   1163900     28.69
  平均时间:      2027827   2028665     50.01    145492   1243820   1163899     28.69
  
  kbmemfree：这个值和 free 命令中的 free 值基本一致，所以它不包括 buffer 和 cache 的空间
  kbmemused：这个值和 free 命令中的 used 值基本一致,所以它包括 buffer 和 cache 的空间
  %memused：这个值是 kbmemused 和内存总量(不包括 swap)的一个百分比
  kbbuffers 和 kbcached：这两个值就是 free 命令中的 buffer 和 cache
  kbcommit：保证当前系统所需要的内存，即为了确保不溢出而需要的内存(RAM + swap)
  %commit：这个值是 kbcommit 与内存总量(包括 swap)的一个百分比
  ```

- I/O 和传输速率信息状况

  ``` bash
  sar -b [ <时间间隔> [ <次数> ] ]
  sar -b 1 3
  
  Linux 2.6.32-696.13.2.el6.x86_64 (upfor163) 2018年04月25日 _x86_64_ (2 CPU)
  
  10时58分15秒       tps      rtps      wtps   bread/s   bwrtn/s
  10时58分16秒      7.00      0.00      7.00      0.00     64.00
  10时58分17秒      4.04      0.00      4.04      0.00     80.81
  10时58分18秒      0.00      0.00      0.00      0.00      0.00
  平均时间:         3.67      0.00      3.67      0.00     48.00
  
  
  
  tps：每秒钟物理设备的 I/O 传输总量
  rtps：每秒钟从物理设备读入的数据总量
  wtps：每秒钟向物理设备写入的数据总量
  bread/s：每秒钟从物理设备读入的数据量，单位为：块/s
  bwrtn/s：每秒钟向物理设备写入的数据量，单位为：块/s
  ```

- 网络统计信息

  ```bash
  sar -n <关键词> [ <时间间隔> [ <次数> ] ]
  
  sar -n DEV 1 5
  平均时间:     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
  平均时间:        lo      2.21      2.21      0.18      0.18      0.00      0.00      0.00
  平均时间:      eth0      4.62      3.82      0.37      1.90      0.00      0.00      0.00
  
  
  ```

### tar（打包，压缩）

首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。

所以tar就是将一大堆文件打包成一个文件，然后再压缩。

```bash
tar -zcvf /tmp/bin-backup.tar.gz /home/vivek/bin/
将 /home/vivek/bin/ 目录打包，并使用 gzip 算法压缩。保存为 /tmp/bin-backup.tar.gz 文件。
```

### df（磁盘空间占用）

用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。默认是KB为单位：使用`-h`选项以KB以上的单位来显示，可读性高：

```bash
[root@LinServ-1 ~]# df -h
文件系统              容量  已用 可用 已用% 挂载点
/dev/sda2             140G   27G  106G  21% /
/dev/sda1             996M   61M  884M   7% /boot
tmpfs                1009M     0 1009M   0% /dev/shm
/dev/sdb1             2.7T  209G  2.4T   8% /data1
```

### free（显示未使用的内存数目）

可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。在Linux系统监控的工具中，free命令是最经常使用的命令之一。

free -m(以MB为单位显示内存使用情况) -k(以KB为单位显示内存使用情况) -g(以GB为单位显示内存使用情况)

```bash
free -m
             total       used       free     shared    buffers     cached
Mem:          2016       1973         42          0        163       1497
-/+ buffers/cache:        312       1703
Swap:         4094          0       4094
```

### netstat（网络连接情况）

Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。

- **列出所有端口 (包括监听和未监听的)**

  ```shell
  netstat -a     #列出所有端口
  netstat -at    #列出所有tcp端口
  netstat -au    #列出所有udp端口                             
  ```

- **列出所有处于监听状态的 Sockets**

  ```shell
  netstat -l        #只显示监听端口
  netstat -lt       #只列出所有监听 tcp 端口
  netstat -lu       #只列出所有监听 udp 端口
  netstat -lx       #只列出所有监听 UNIX 端口
  ```


- **直接使用netstat**

  ```bash
  Active Internet connections (w/o servers)
  Proto Recv-Q Send-Q Local Address Foreign Address State
  tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED
  tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED
  tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED
  tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED
  tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE
  
  Active UNIX domain sockets (w/o servers)
  Proto RefCnt Flags Type State I-Node Path
  unix 1 [ ] STREAM CONNECTED 16178 @000000dd
  unix 1 [ ] STREAM CONNECTED 16176 @000000dc
  unix 9 [ ] DGRAM 5292 /dev/log
  unix 1 [ ] STREAM CONNECTED 16182 @000000df
  ```

  输出结果可以分为两个部分：

  1. Active Internet connections，称为有源TCP连接，其中"Recv-Q"和"Send-Q"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。
  2. Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。
     Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。

- 


### traceroute（追踪网络包的路由途径）

追踪网络数据包的路由途径，预设数据包大小是40Bytes。

```bash
traceroute www.58.com -m(设置跳数)
traceroute to www.58.com (211.151.111.30), 30 hops max, 40 byte packets
 1  unknown (192.168.2.1)  3.453 ms  3.801 ms  3.937 ms
 2  221.6.45.33 (221.6.45.33)  7.768 ms  7.816 ms  7.840 ms
 3  221.6.0.233 (221.6.0.233)  13.784 ms  13.827 ms 221.6.9.81 (221.6.9.81)  9.758 ms
 4  221.6.2.169 (221.6.2.169)  11.777 ms 122.96.66.13 (122.96.66.13)  34.952 ms 221.6.2.53 (221.6.2.53)  41.372 ms
 5  219.158.96.149 (219.158.96.149)  39.167 ms  39.210 ms  39.238 ms
 6  123.126.0.194 (123.126.0.194)  37.270 ms 123.126.0.66 (123.126.0.66)  37.163 ms  37.441 ms
 7  124.65.57.26 (124.65.57.26)  42.787 ms  42.799 ms  42.809 ms
 8  61.148.146.210 (61.148.146.210)  30.176 ms 61.148.154.98 (61.148.154.98)  32.613 ms  32.675 ms
 9  202.106.42.102 (202.106.42.102)  44.563 ms  44.600 ms  44.627 ms
10  210.77.139.150 (210.77.139.150)  53.302 ms  53.233 ms  53.032 ms
11  211.151.104.6 (211.151.104.6)  39.585 ms  39.502 ms  39.598 ms
12  211.151.111.30 (211.151.111.30)  35.161 ms  35.938 ms  36.005 ms
```

### route（显示网络路由表）

显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。

可以查看（route），增加（route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0），删除（route del -net 224.0.0.0 netmask 240.0.0.0）

```bash
[root@localhost ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
112.124.12.0    *               255.255.252.0   U     0      0        0 eth1
10.160.0.0      *               255.255.240.0   U     0      0        0 eth0
192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0
172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0
10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0
default         112.124.15.247  0.0.0.0         UG    0      0        0 eth1

route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    #增加一条到达224.0.0.0的路由。
route add -net 224.0.0.0 netmask 240.0.0.0 reject     #增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。
route del -net 224.0.0.0 netmask 240.0.0.0
route del -net 224.0.0.0 netmask 240.0.0.0 reject
route del default gw 192.168.120.240
route add default gw 192.168.120.240
```

### ip（ifconfig显示网络设备信息)

linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。

```bash
ip link show                     # 显示网络接口信息
ip link set eth0 up             # 开启网卡
ip link set eth0 down            # 关闭网卡
ip link set eth0 promisc on      # 开启网卡的混合模式
ip link set eth0 promisc offi    # 关闭网卡的混个模式
ip link set eth0 txqueuelen 1200 # 设置网卡队列长度
ip link set eth0 mtu 1400        # 设置网卡最大传输单元
ip addr show     # 显示网卡IP信息
ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1
ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址
```



### awk(d对文本和数据处理)

**awk** 是一种脚本编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。AWK命令是由三个人的名字首字母命名的--Aho、Weinberger和Kernighan。他们来自AT&T贝尔实验室，也在Unix Shell脚本中贡献了许多其他命令行提示。

它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。

**AWK命令的基本语法**

```shell
awk [options] [program] [file]
```

awk工作流程是这样的：读入有\n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，`$0`则表示所有域,`$1`表示第一个域,`$n`表示第n个域。默认域分隔符是"空白键" 或 "[tab]键"，举个例子：

```bash
[root@www ~]# last -n 5 <==仅取出前五行
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
```

如果只是显示最近登录的5个帐号

```
#last -n 5 | awk  '{print $1}'
root
root
root
dmtsai
root
```

所以`$1`表示登录用户，`$3`表示登录用户ip,以此类推。

比如下列代码：

```shell
awk '{printf "第一列：%s 第二列：%s\n",$1,$2}' #在控制台输入两个信息，然后输出
melon water
第一列：melon 第二列：water
```













## Linux各个目录作用

| 目录        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| /bin        | 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。 |
| /home       | 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 |
| /usr        | 用于存放系统应用程序，比较重要的目录 /usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。 /usr/x11r6 存放x window的目录 /usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库 |
| /opt        | 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。 |
| /proc       | 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 |
| /root       | 超级用户（系统管理员）的主目录（特权阶级^o^）                |
| /sbin       | 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。 |
| /dev        | 用于存放设备文件。                                           |
| /mnt        | 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。 |
| /boot       | 存放用于系统引导时使用的各种文件                             |
| /lib        | 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 |
| /tmp        | 用于存放各种临时文件，是公用的临时文件存储点。               |
| /var        | 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 |
| /lost+found | 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 |











# QPS和TPS

QPS（Queries Per Second）和 TPS（Transactions Per Second）是用来衡量系统处理能力的指标。

QPS 表示**每秒钟处理的请求数量**，通常用于**衡量系统的网络吞吐量**。TPS 则表示**每秒钟完成的事务数量**，通常用于**衡量系统的事务处理能力**。

`QPS = 总请求次数/时间`







# CMake图

## CMake构建流程

1. **`mkdir build`**:

   命令创建一个名为`build`的目录。在单独的目录中进行构建。

2. **`cmake ..`**:

   命令运行CMake工具，它读取`CMakeLists.txt`文件并生成构建系统所需的文件。这里的`..`指的是当前目录的上一级目录，通常是项目的主目录，其中包含`CMakeLists.txt`。

   当你执行这个命令时，CMake会在`build`目录中生成Makefile（或其他适当的构建系统文件，取决于你的平台和CMake的配置）。

3. **`make`**:

   命令使用前面生成的Makefile来构建项目。具体地，`make`命令将**编译和链接源代码，生成可执行文件**、库或其他构建目标。

![1690187478151](../C-add-add-master/C-add-add-master/Typora%E7%94%A8%E5%88%B0%E5%9B%BE%E7%89%87/1690187478151.jpg)

![1690187453876](../C-add-add-master/C-add-add-master/Typora%E7%94%A8%E5%88%B0%E5%9B%BE%E7%89%87/1690187453876.jpg)

![1690187436123](../C-add-add-master/C-add-add-master/Typora%E7%94%A8%E5%88%B0%E5%9B%BE%E7%89%87/1690187436123.jpg)

![1690187414105](../C-add-add-master/C-add-add-master/Typora%E7%94%A8%E5%88%B0%E5%9B%BE%E7%89%87/1690187414105.jpg)

## CMake命令

> CMake介绍：CMake是一个跨平台的编译工具。能够输出各种各样的Makefile文件

cmake_minimum_required 命令

min 指定了编译当前的cmake需要的最old的版本号，如果cmake版本号小于指定的版本号时，运行cmake 就报错。

**set命令**

设置一个变量的值。

**message 命令**

用于记录log消息的，常用的有：

- FATAL_ERROR： cmake errer, 遇到该错误，cmake 直接停止处理。
- WARNING： 警告信息， 但是cmake会继续执行下去的。
- STATUS： 用于记录一些cmake 运行过程中的有用的信息。

**project 命令**

使用语法为：`project(项目名字, [VERSION 版本号] [DESCRIPTION 描述字符串] )`

add _executable 

普通的可执行文件

**add_library**

用于添加一个库文件的target, 包含静态库、动态库等

**target_include_directories** 

该命令用于指令要包含的路径名。 当使用 gcc 编译器编译目标时，就会使用`-I`选项指定该命令添加的路径， 使用`-I directory/include`.

**add_subdirectory 命令**

用于增加一个构建的子目录。 注意执行的数据流： cmake 命令会执行完子目录中的CmakeLists.txt文件之后，再执行后面的命令。







# Shell

## awk命令

awk用于在linux/unix下对文本和数据进行处理。它处理的数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出等。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。

awk工作流程是这样的：读入有\n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，`$0`则表示所有域,`$1`表示第一个域,`$n`表示第n个域。默认域分隔符是"空白键" 或 "[tab]键"，举个例子：

```bash
[root@www ~]# last -n 5 <==仅取出前五行
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
```

如果只是显示最近登录的5个帐号

```
#last -n 5 | awk  '{print $1}'
root
root
root
dmtsai
root
```

所以`$1`表示登录用户，`$3`表示登录用户ip,以此类推。

比如下列代码：

```shell
awk '{printf "第一列：%s 第二列：%s\n",$1,$2}' #在控制台输入两个信息，然后输出
melon water
第一列：melon 第二列：water
```

1

## 一些语法

1. `$n`表示接收的命令参数，`$1`表示第一个参数。。。

2. x表示空

3. export会设置环境变量

4. |（管道运算符），例如command 1 | command 2

   表示把第一个命令的command1执行的结果座位command2的输入传给command2

5. ipcalc -p ip地址 掩码，输出PREFIX=

   这个命令是显示给定的掩码或ip地址的前缀

6. shell中的print是ksh的内置命令，print不能使用%s,%d等格式转换符，但是可以自动换行

   而printf可以使用格式转换符但是不能自动换行。

7. -a 与

   -o 或

   ！非

8. -eq     //equal  等于

   -ne     //no equal 不等于

   -gt      //great than 大于

   -lt       // low than  小于

   ge      // great and equal 大于等于，注意没有"-"

    le      //low and equal 小于等于，注意没有“-”

9. shell 中利用 -n 来判定字符串非空

   例子：

   ```shell
   if [ -n str1 ]
   //当串的长度大于0时为真(串非空) 
   ```

10. shell中的特殊变量

    `$0`, `$#`, `$*`, `$@`, `$?`, `$$`和命令行参数

    | 变量     | 含义                                                         |
    | -------- | ------------------------------------------------------------ |
    | `$0`     | 当前脚本的文件名                                             |
    | `$n`     | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 |
    | `$#`     | 传递给脚本或函数的参数个数。                                 |
    | `$*`     | 传递给脚本或函数的所有参数。                                 |
    | `$@`     | 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。 |
    | `$?`     | 上个命令的退出状态，或函数的返回值。                         |
    | `$$`     | 当前Shell进程本身的PID即进程ID。就是正在运行的脚本的进程ID   |
    | `$!`     | shell最后运行的后台Process的PID，可调用上一个进程的进程ID    |
    | `$var`   | 使用一个定义过的变量var                                      |
    | `${var}` | 变量，界定范围                                               |
    | `$()`    | 与``(反引号)类似，里面执行完再返回值，所有shell通用          |
    | `$[]`    | 可进行算术运算和逻辑运算，不支持浮点和字符串                 |
    | `$(()) ` | 可进行算术运算和逻辑运算，不支持浮点和字符串。里面的变量可以省略$ |

11. Shell 脚本中的exit状态解释 

     如果退出状态为0，则命令执行成功。`exit 0` 

     如果命令失败，则退出状态为非零。`exit 1`

12. shit命令

    shit一般和循环一起使用。对于命令行参数，其个数必须是确定的，或者当 Shell 程序不知道其个数时，可以把所有参数一起赋值给变量$*然后循环读取参数。循环的话命令参数可能在下一次循环中又使用了，因此当我们有多个参数输入的时候，又只想每一个参数只使用一次，使用shit参数。

    ```shell
    until [ $# -eq 0 ]
    do
    echo "第一个参数为: $1 参数个数为: $#"
    shift
    done
    ```

    执行以上程序x_shift.sh：
    $./x_shift.sh 1 2 3 4，结果如下：

    第一个参数为: 1 参数个数为: 4

    第一个参数为: 2 参数个数为: 3

    第一个参数为: 3 参数个数为: 2

    第一个参数为: 4 参数个数为: 1

13. tee命令

    在输出信息的同时把信息记录到文件中

    `ls | tee ls.txt` 将会在终端上显示ls命令的执行结果，并把执行结果输出到ls.txt文件中，将会覆盖原文件的内容，若无`ls.txt`文件，将会自动创建该文件

    `ls | tee -a ls.txt` 保留ls.txt文件中原来的内容，并把ls命令的执行结果追加到ls.txt文件的最后，不覆盖原来的内容

14. WC命令

    wc命令是用来统计文件的行数、字节数等。其用法如下：

    > wc [-lcmw] [file...]
    >
    > -l 统计行（line）数
    >
    > -w 统计字（word）数
    >
    > -c 统计字节（character）数

## 正则表达式

| 正则表达式 |                             描述                             |                             示例                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    `^`     |       指定了匹配正则表达式的文本必须起始于字符串的首部       |                `^tux`能够匹配以`tux`起始的行                 |
|    `$`     |     指定了匹配正则表达式的文本必须结束于目标字符串的尾部     |                `tux$`能够匹配以`tux`结尾的行                 |
|  `A`字符   |                   正则表达式必须匹配该字符                   |                        A能够匹配字符A                        |
|    `.`     |                       匹配任意一个字符                       | `Hack.`能够匹配`Hackl`和`Hacki`，但是不能匹配`Hackl2`或`Hackil`，它只能匹配单个字符 |
|    `[]`    | 匹配中括号内的任意一个字符。中括号内可以是一个字符组或字符范围 |   `coo[kl]`能够匹配`cook`或`cool`，`[0-9]`匹配任意单个数字   |
|   `[^]`    | 匹配不在中括号内的任意一个字符。中括号内可以是一个字符组或字符范围 | `9[^01]`能够匹配`92`和`93`，但是不匹配`91`和`90`；`A[^0-9]`匹配`A`以及随后除数字外的任意单个字符 |

**例子**

能够匹配任意单词的正则表达式：

```shell
( +[a-zA-Z]+ +)
```

开头的`+`表示需要匹配一个或多个空格。字符组`[a-zA-Z]`用于匹配所有的大小写字母。随后的`+`表示至少要匹配一个字母，多者不限。最后的`+`表示需要匹配一个或多个空格来终结单词。

## grep常用用法

```
[root@www ~]# grep [-acinv] [--color=auto] '搜寻字符串' filename
选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
--color=auto ：可以将找到的关键词部分加上颜色的显示喔！
```





## Git命令 

查看本地全部分支 `git branch`

切换分支 `git checkout feature`

查看文件哪些被修改了 可以使用 `git status` 命令来查看哪些文件被修改过但还没有被提交，如果你想看修改的具体内容，可以使用 `git diff` 命令。

提交暂存区`git add . ` `git commit -m "Your commit message"`

提交变动,如果你想直接提交工作区的所有变动（修改，删除，重命名等），你可以直接使用 `git commit -a -m "Your commit message"`。 `-a` 或 `--all` 选项会自动把所有已经跟踪过的文件的变动（不包括新文件或删除的文件）暂存起来一并提交，省去了 `git add .` 这一步。注意这不包括新文件（需要用 `git add` 来跟踪新文件）。

Git命令行工具提供了一系列命令来管理和操作Git仓库。以下是一些常用的Git命令：

1. **设置与初始化**：
   - `git init`: 初始化一个新的Git仓库。
   - `git clone [url]`: 克隆（或下载）一个远程仓库到本地。
2. **基础操作**：
   - `git add [file/directory]`: 添加文件或目录到暂存区。
   - `git commit -m "[message]"`: 提交暂存区的更改到仓库。
   - `git status`: 显示工作区、暂存区和仓库的状态。
   - `git log`: 查看提交历史。
3. **分支与合并**：
   - `git branch`: 列出所有分支。
   - `git branch [branch_name]`: 创建一个新的分支。
   - `git checkout [branch_name]`: 切换到指定分支。
   - `git merge [branch_name]`: 合并指定分支到当前分支。
4. **远程仓库操作**：
   - `git remote add [name] [url]`: 添加一个新的远程仓库。
   - `git fetch [remote_name]`: 从远程仓库下载对象和引用。
   - `git push [remote_name] [branch_name]`: 将分支推送到远程仓库。
   - `git pull [remote_name] [branch_name]`: 获取并合并远程仓库的更改。
5. **撤销更改**：
   - `git reset --hard [commit_hash]`: 重置到指定的提交。
   - `git revert [commit_hash]`: 创建一个新的提交来撤销指定的提交。
   - `git checkout -- [file]`: 丢弃工作区的更改。
6. **高级功能**：
   - `git rebase [branch_name]`: 将一系列提交重新应用到另一个基础点上。
   - `git stash`: 临时保存工作区的更改。
   - `git tag`: 创建、列出、删除或验证一个标签对象，通常用于版本发布。
7. **配置与帮助**：
   - `git config`: 获取和设置配置变量。
   - `git help [command]`: 显示命令的帮助文档。

**git commit**:

- **这是一个本地操作。当你在工作目录中进行了一些修改并通过 `git add` 将它们添加到暂存区后，使用 `git commit` 将暂存区的更改提交到本地存储库。**提交时，你需要提供一个描述性的消息，描述此次更改的内容或原因。
- 每次提交都会生成一个唯一的提交 ID，这允许你回溯或引用特定的提交。

**git push**:

- **这是一个远程操作。使用 `git push`，你可以将本地仓库的更改推送到远程仓库。**通常，这意味着将你的代码推送到像 GitHub 或 GitLab 这样的远程服务上。
- 如果有其他开发者也在同一时间段推送了他们的更改，你可能需要首先拉取他们的更改 (`git pull`) 并解决任何潜在的合并冲突。

**为什么要设置一个暂存区**：

暂存区是 Git 的一个独特特性，它为开发者提供了一个灵活的中间层，允许他们有选择性地提交更改。以下是设置暂存区的主要原因：

1. **有选择性的提交**：不是所有的更改都需要成为一个提交。有时，你可能只想提交特定文件或更改，而不是工作目录中的所有更改。
2. **组织清晰的提交**：暂存区允许你创建明确、目的明确的提交。例如，如果你修复了两个不相关的问题，你可以为每个问题创建一个单独的提交，而不是将它们混合在一起。
3. **代码审查**：在提交之前，你可以使用 `git diff --staged` 检查哪些更改即将被提交。这可以帮助你确保只有预期的更改被提交，而不是意外的更改。
4. **更好的撤销机制**：如果你意识到你的更改存在问题，你可以轻松地使用 `git reset` 从暂存区中撤销它，而不影响工作目录中的其他更改。

# GIT

## 如何将本地项目上传到git？

```shell
git pull origin master(或者分支名)		 //push前最好切换到主分支使用pull来拉取下最新资源。避免冲突
git init		//初始化版本库
git add .		//添加到缓存区中
git commit -m 'first commit'	//提交到版本库，并注释
git push -u origin master(或者分支名)	//第一次推送时候要写
git push origin master(或者分支名)     //如果不是第一次，则直接使用该命令即可推送修改
```

## git常用命令

```shell
//新建分支
git branch 分支名
//切换分支
git checkout 分支名
//删除本地分支
git branch -d 分支名
//强制删除本地分支
git branch -D 分支名
//删除远程分支
git push origin --delete 分支名

//查看本地所有分支
git branch
//查看远程所有分支
git branch -r
//查看远程和本地所有分支—一般用这个
git branch -a

//重命名本地分支
git branch -m <oldbranch> <newbranch>
```

## push和pull

**push：**本地分支合并到远程分支

**pull：**将远程分支合并到本地分支

## git fetch&git pull详解

[参考链接和评论](https://blog.csdn.net/weixin_41975655/article/details/82887273)

`git fetch`的意思是将远程主机的最新内容拉到本地，用户再检查无误后再决定是否合并到工作本地分支中

`git pull`是将远程主机中的最新内容拉取下来后直接合并，即：git pull = git fetch+git merge，这样可能会产生冲突，需要手动解决。

## git冲突原因和解决冲突

**产生原因：**多个开发者同时使用或者操作git中的同一个文件，最后在依次提交commit和推送push的时候，第一个操作的是可以正常提交的，而之后的开发者想要执行pull和fetch操作的时候，就会报冲突异常conflict。

1. 两个分支中修改了同一个文件（不管什么地方）
2. 两个分支中修改了同一个文件的名称

**冲突消除的方式：**

1. git pull命令。拉取远程分支上的代码并合并到本地分支，目的是消除冲突；
2. git stash命令。把工作区的修改提交到栈区，目的是保存工作区的修改；

## git撤销commit但是未git push的情况（**如在 Git 恢复先前的提交？**）

```shell
//找到上次git commit的id
git log
//执行撤销操作，同时将代码恢复到该commit_id之前的代码提交状态
git reset --hard  commit_id
//执行撤销但是保留更改
git reset  commit_id
```

## git rebase和git merge

合并前有两个分支：

```shell
A <- B <- C    [master]
^
 \
  D <- E       [branch]
```



在 git merge master 之后：

```
A <- B <- C
^         ^
 \         \
  D <- E <- F
```

在 git rebase master 之后：

```
A <- B <- C <- D <- E
```

rebase变基会破坏分支

# GDB

## gdb使用流程

- 启动gdb  -g表示调试
- list查看代码，默认查看10行
- run(或者写成r)，没有断点就运行到结束，有断点就运行到断点处
- start：程序从`main`函数的起始位置停下，开始逐步调试。
- break(b)，设置断点
- info break：查看断点信息
- delete：删除断点
- continue、step、next命令
  1. continue：继续执行程序，直到遇到下一个断点或者结束
  2. next：单步执行，遇到函数时会跳过函数，不进入函数体内部
  3. step：单步执行程序，但遇到函数会进入到函数内部
- until：结束一个循环体循环
- print：显示变量或者表达式的值

## 普通调试

- step和next的区别？

​		next会直接执行到下一句 ,step会进入函数体内部执行

- list

​		查看源码

- set

  设置变量值

- backtrace 

  查看函数调用的栈帧关系

- framework

  切换函数栈帧

- info

  查看函数内部局部变量

## 多线程调试

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203151449773.png" alt="这里写图片描述" style="zoom: 80%;float:left" />

- info threads

  查看所有线程，默认分支是主线程

- thread id

  切换线程

- bt

  查看每个线程的栈帧然后设置断点

- thread apply （n或all） 命令

  使用thread apply来让一个或是多个线程执行指定的命令。例如让所有的线程打印调用栈信息。

- set scheduler-locking on

  锁定只有当前的线程能够执行



## 多线程调试2

在 Linux 下，你可以使用许多工具来调试多线程的程序，其中最常用的是 GDB 和 Valgrind。这两种工具都非常强大，可以帮助你找出并解决各种问题。

1. GDB: GDB 是一个开源的调试器，支持 C 和 C++ 等语言。GDB 提供了多线程调试的功能，让你可以查看、停止和控制程序中的每一个线程。
   - 使用 "info threads" 命令可以显示当前程序中所有线程的信息。
   - 使用 "thread num" 命令可以切换到指定的线程，其中 "num" 是线程的编号。
   - 使用 "break filename:linenum" 命令可以在指定的文件和行设置断点。
   - 使用 "run" 命令可以开始运行程序，当遇到断点时程序会停止，并显示当前的调用堆栈和变量值。





## GDB工作原理

1. **编译程序**: 要使用GDB调试程序，首先需要使用编译器（如GCC）编译源代码，通常需要在编译过程中包含调试信息（例如，使用`-g`选项），以便GDB能够理解源代码和机器代码之间的映射关系。

2. **启动GDB**: 在终端中运行GDB，然后通过命令行将待调试的程序作为参数传递给GDB。例如，使用以下命令启动GDB并调试一个名为`my_program`的程序：

   ```
   Copy code
   gdb my_program
   ```

3. **设置断点**: GDB允许您在程序中设置断点，以在特定位置停止程序的执行。您可以使用`break`命令设置断点，指定要在哪个源代码行或函数中停止。例如：

   ```
   kotlinCopy code
   break main
   ```

4. **运行程序**: 使用`run`命令开始执行程序，直到遇到设置的断点或程序结束。例如：

   ```
   arduinoCopy code
   run
   ```

5. **调试控制**: 一旦程序停止，您可以使用各种GDB命令来检查程序状态。一些常用的命令包括：

   - `step`：逐行执行程序，进入函数调用。
   - `next`：逐行执行程序，跳过函数调用。
   - `continue`：继续执行程序，直到下一个断点。
   - `print`：用于查看变量的值。
   - `backtrace`：显示函数调用堆栈。

6. **观察程序状态**: 使用GDB，您可以查看程序的变量、寄存器状态、内存内容等，以帮助诊断问题。

7. **修改程序状态**: 在某些情况下，您可以使用GDB来修改程序的状态，例如，更改变量的值，然后继续执行程序。

8. **终止调试**: 调试完成后，您可以使用`quit`命令退出GDB。





# 智力题

### 有8个球，其中一个球比其他重一些，天平称重几次可以找到

第一次：把8个球分为三组，每组分别为3个，3个，2个。然后把两个3个球的组放在天平两端进行称重。如果天平平衡，那么较重的球就在剩下的2个球中；如果不平衡，较重的球就在较重的那一端的3个球中。

第二次：在两个球的情况下，直接进行称重就可以找出较重的那个。在三个球的情况下，选取其中的两个球进行称重，如果平衡，那么较重的球就是未称的那个，否则较重的球就是天平较重的那一端的球。







# 手写线程池

```c++
#include <list>
#include <stdexcept>
#include <thread>
#include <mutex>
#include <condition_variable>

class ThreadPool {
public:
    ThreadPool(int thread_number = 8, int max_requests = 10000)
        : m_thread_number(thread_number), m_max_requests(max_requests), m_stop(false) {
        if (thread_number <= 0 || max_requests <= 0)
            throw std::runtime_error("invalid thread_number or max_requests");

        for (int i = 0; i < m_thread_number; ++i)
            m_threads.emplace_back(worker, this);
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(m_queuelocker);
            m_stop = true;
        }
        m_queuestat.notify_all();
        for(std::thread &worker: m_threads)
            worker.join();
    }

    bool append(std::function<void()> task) {
        {
            std::unique_lock<std::mutex> lock(m_queuelocker);
            if (m_workqueue.size() >= m_max_requests)
                return false;
            m_workqueue.push_back(std::move(task));
        }
        m_queuestat.notify_one();
        return true;
    }

    static void worker(ThreadPool *pool) {
        pool->run();
    }

    void run() {
        while (!m_stop) {
            std::function<void()> task;
            {
                std::unique_lock<std::mutex> lock(m_queuelocker);
                m_queuestat.wait(lock, [this]{ return m_stop || !m_workqueue.empty(); });
                if (m_stop && m_workqueue.empty())
                    return;
                task = std::move(m_workqueue.front());
                m_workqueue.pop_front();
            }
            if (task)
                task();
        }
    }

private:
    int m_thread_number;
    int m_max_requests;
    std::vector<std::thread> m_threads;
    std::list<std::function<void()>> m_workqueue;
    std::mutex m_queuelocker;
    std::condition_variable m_queuestat;
    bool m_stop;
};
```

当你写`m_workqueue.push_back(std::move(task));`时，你实际上是在说：“我不再需要这个任务，你可以将其资源直接移动到工作队列中，无需复制。”这样，当你的任务对象较大或持有大量资源时，你可以避免不必要的复制，从而提高性能。

```c++
#include <iostream>
#include <chrono>
#include <string>

int main() {
    // 创建一个拥有4个线程的线程池
    ThreadPool pool(4);

    // 创建一些任务并添加到线程池
    for (int i = 0; i < 10; ++i) {
        pool.append([i]() {
            std::cout << "Hello from task " << i << " on thread " << std::this_thread::get_id() << std::endl;
            // 模拟耗时操作
            std::this_thread::sleep_for(std::chrono::seconds(1));
        });
    }

    // 等待所有任务完成。这只是为了让主线程暂停，让工作线程有机会完成他们的任务。
    std::this_thread::sleep_for(std::chrono::seconds(12));

    return 0;
}

```







## Socket编程API以及Socket编程返回值

1. **socket()**
   创建一个新的套接字。

   ```C++
   int socket(int domain, int type, int protocol);
   ```

2. **bind()**
   将套接字绑定到特定的地址和端口。

   ```C++
   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
   ```

3. **listen()**
   让套接字进入监听模式，等待连接请求。

   ```C++
   int listen(int sockfd, int backlog);
   ```

4. **accept()**
   接受来自客户端的连接请求。

   ```C++
   int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
   ```

5. **connect()**
   尝试与服务器端的套接字建立连接。

   ```C++
   int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
   ```

6. **send()**, **recv()**
   用于发送和接收数据。

   ```C++
   ssize_t send(int sockfd, const void *buf, size_t len, int flags);
   ssize_t recv(int sockfd, void *buf, size_t len, int flags);
   ```

7. **sendto()**, **recvfrom()**
   用于无连接的数据传输（例如UDP）。

   ```C++
   ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
   
   ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
   ```

8. **close()**
   用于关闭套接字。

   ```c++
   int close(int fd);
   ```

9. **getaddrinfo()**, **freeaddrinfo()**, **gai_strerror()**

   这些函数用于DNS查找，将域名转换为套接字地址结构。

   ```C++
   int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);
   
   void freeaddrinfo(struct addrinfo *res);
   
   const char *gai_strerror(int errcode);
   ```

   **setsockopt()**, **getsockopt()**
   设置或获取套接字选项。

   ```c++
   cCopy codeint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
   
   int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
   ```

### 返回值:

大多数Socket API函数在成功时返回非负值，但在出错时返回-1。当这些函数返回-1时，可以使用`errno`来确定发生了什么错误，并使用`perror()`或`strerror(errno)`来获取描述性的错误消息。

例如：

```c++
if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
    perror("bind");
    // 或者: printf("bind: %s\n", strerror(errno));
    exit(1);
}
```

`accept()`, `recv()`, `send()`, `recvfrom()`, 和 `sendto()` 这些函数返回的是其他特定的值，如传输的字节数，或者在错误时返回-1。

当处理Sockets和网络错误时，了解可能的`errno`值是很有帮助的，如`ECONNREFUSED`, `ETIMEDOUT`, `EHOSTUNREACH`等。

总的来说，这只是Socket编程API的一个简单概述，实际应用中还有许多细节和额外的功能需要深入了解。





## 单核cpu能否运行多线程

**对于单核CPU来说，它不能真正地同时执行多个线程。实际上，它是通过时间片轮转（time slicing）或其他调度策略来快速切换不同线程的执行，给人一种并行执行的错觉。**

操作系统的调度器会控制线程的执行，并决定哪个线程应该在何时运行。当一个线程的时间片用完或者它被阻塞（例如，等待I/O操作完成）时，操作系统会保存它的状态（称为上下文切换），然后选择另一个线程运行。

这种方式的优点是可以提高CPU的利用率，因为当一些线程在等待I/O操作时，其他的线程可以继续执行。而且，由于线程的切换非常快，用户通常感觉不到切换的存在，就像多个线程或任务在同时运行一样。但是，它也会带来一定的开销，比如上下文切换的时间和资源。

另外，虽然单核CPU可以运行多线程，但是多核CPU会提供更好的并行性能，因为它们可以真正地同时执行多个线程。





## 游戏战力排行榜榜单用什么数据结构存储

可以同时使用优先队列和哈希表，优先队列(堆)用于维护前 K 个最强的玩家，哈希表用于快速查找任意玩家的排名。







## 模版写在.h不写在.cpp

1. **编译时实例化**：C++的模板不同于常规的函数或类。模板是在编译时实例化的，这意味着当你使用一个模板（例如`std::vector<int>`）时，编译器实际上为你生成了一个与该特定类型相关的新代码版本（在这个例子中，它是与`int`类型相关的`std::vector`版本）。为了进行此操作，编译器需要完整地看到模板的定义。
2. **分离的编译模型**：在传统的C++编译模型中，每个`.cpp`文件被单独编译成目标文件。编译器在编译一个`.cpp`文件时通常不会查看其他`.cpp`文件。因此，如果模板定义位于某个`.cpp`文件中，其他`.cpp`文件中的模板实例化将无法访问到该定义，导致链接错误。
   **总结：因为模版是在编译时候实例化的，如果你写在.cpp文件中，.cpp是单独编译的，这样其他的文件就看不到这个文件的模版的定义，就不能实例化**

## bind绑定

在C++中，**`bind`是一种函数模板，它返回一个函数对象**，这个对象能将其参数与给定的值或函数对象绑定在一起。`std::bind`可以创建一个可以调用的对象，这个对象在被调用时会将预先绑定的参数传递给预先绑定的函数。

```c++
#include <iostream>
#include <functional> // for std::bind

void print_number(int number) {
    std::cout << number << std::endl;
}

int main() {
    auto bound_print_number = std::bind(print_number, 5);
    bound_print_number(); // 输出5
}

```

在这个例子中，我们首先定义了一个函数`print_number`，它接受一个整数参数并将其打印出来。然后我们使用`std::bind`来创建一个新的可调用对象`bound_print_number`，这个对象在被调用时会自动将5作为参数传递给`print_number`函数。

我们也可以使用`std::placeholders`占位符来表示将来在调用时提供的参数。例如：

```c++
#include <iostream>
#include <functional> // for std::bind and std::placeholders

void print_sum(int a, int b) {
    std::cout << a + b << std::endl;
}

int main() {
    auto bound_print_sum = std::bind(print_sum, std::placeholders::_1, 5);
    bound_print_sum(3); // 输出8
}
```

在这个例子中，我们使用`std::placeholders::_1`来表示在调用`bound_print_sum`时提供的第一个参数。所以，当我们调用`bound_print_sum(3)`时，它实际上调用的是`print_sum(3, 5)`，并输出8。





## 回调函数：

当发⽣某种事件时，系统或其他函数将会⾃动调⽤你定义的⼀段函数；

回调函数就相当于⼀个中断处理函数，由系统在符合你设定的条件时⾃动调⽤。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为⼀个参数，以便于系统调⽤；

回调函数就是⼀个通过函数指针调⽤的函数。如果你把函数的指针（地址）作为参数传递给另⼀个函数，当这个指针被⽤为调⽤它所指向的函数时，我们就说这是回调函数；

因为可以把调⽤者与被调⽤者分开。调⽤者不关⼼谁是被调⽤者，所有它需知道的，只是存在⼀个具有某种特定原型、某些限制条件（如返回值为int）的被调⽤函数。









## bind和function配套使用

`std::function`是C++11引入的一个类型，可以被用来存储任何可以调用的目标，包括函数、Lambda表达式、函数指针或者有`operator()`的类的实例。`std::function`经常和`std::bind`一起使用。

```c++
#include <iostream>
#include <functional>

void print_number(int number) {
    std::cout << number << std::endl;
}

int main() {
    std::function<void(int)> func = print_number;
    func(5);  // 输出：5

    auto bound_print_number = std::bind(print_number, 7);
    std::function<void()> func_bound = bound_print_number;
    func_bound();  // 输出：7
}
```

在这个例子中，我们首先创建了一个`std::function`对象`func`，并将其初始化为`print_number`函数。然后我们调用`func(5)`，这将打印出5。

然后我们使用`std::bind`创建了一个可调用对象`bound_print_number`，并将参数7绑定到`print_number`函数上。接着我们创建了一个`std::function`对象`func_bound`，并将其初始化为`bound_print_number`。最后，我们调用`func_bound()`，这将打印出7。

这就是`std::function`和`std::bind`一起使用的方式。**你可以使用`std::function`来存储`std::bind`返回的可调用对象，然后在需要的时候调用它。**



## 句柄和指针的区别

句柄和指针其实是两个截然不同的概念。Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。

## 贪心和动态规划

**贪心**

- 贪心算法是一种在问题求解时，**总是做出在当前看来是最好的选择。**也就是说，不从全局最优上加以考虑，它所做出的仅是在那个时刻下的局部最优解。
- **贪心算法并不保证会达到全局最优。**在有些问题中，贪心策略的局部最优解能导致问题的全局最优解，例如在最小生成树问题中，但在一些问题中，贪心算法不能得到全局最优解，比如在背包问题中。所以，贪心算法的适用情况需要具体问题具体分析。
- 对于贪心算法的时间复杂度，这要看具体问题的情况。在一些问题中，**贪心算法可以在线性时间内运行，即时间复杂度为O(n)。**但在其他问题中，比如最小生成树问题中，如果使用优先队列来获取下一个最小的边，那么时间复杂度可能为O(E log E)，其中E为图的边的数量。
- 总的来说，贪心算法有一定的局限性，但如果应用得当，它可以高效地解决一些问题，并给出接近最优的解答。

**动态规划**

- 动态规划（Dynamic Programming，简称DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
- 动态规划通常用于优化递归问题，例如斐波那契数列问题，如果用递归的方法来求解，会重复计算很多相同的子问题，而动态规划则通过记忆已解决的子问题的答案来避免重复计算，从而提高了效率。
- 动态规划的核心思想是记忆与迭代，通常依赖于所谓的状态转移方程。首先定义一个数组或者其他数据结构来存放子问题的解，然后基于这些已解决的子问题来解决更大的问题。
- 举一个经典的例子，斐波那契数列的定义是F(n) = F(n-1) + F(n-2)对所有n>1，而F(0)=0，F(1)=1。如果用递归的方法来求解F(n)，会导致大量重复计算。但如果使用动态规划，我们可以从底向上的顺序计算并记忆F(2), F(3), ..., F(n)，每次只需要使用前两个已经计算出的值，避免了重复计算。
- 动态规划的复杂度取决于你如何定义子问题和状态转移方程，但通常都会比纯粹的递归更高效。比如在斐波那契数列的例子中，动态规划的时间复杂度为O(n)，而递归的时间复杂度为O(2^n)。
- 总的来说，动态规划是一种非常强大的工具，可以应用于很多优化问题，包括序列对齐、最长公共子序列、最短路径问题等等。

## 调用函数时怎么知道函数地址的？

**当你在代码中调用一个函数时，编译器生成的代码会引用这个函数的符号（例如，函数名）。然后，链接器负责把这个符号解析为具体的函数地址。**



## HelloWorld程序开始到打印到屏幕上的全过程

⽤户告诉操作系统执⾏ HelloWorld 程序（通过键盘输⼊等）；

操作系统：找到 HelloWorld 程序的相关信息，检查其类型是否是可执⾏⽂件；并通过程序⾸部信息，确定代码和数据在可执⾏⽂件中的位置并计算出对应的磁盘块地址；

操作系统：创建⼀个新进程，将 HelloWorld 可执⾏⽂件映射到该进程结构，表示由该进程执⾏ HelloWorld程序；

操作系统：为 HelloWorld 程序设置 cpu 上下⽂环境，并跳到程序开始处；执⾏ HelloWorld 程序的第⼀条指令，发⽣缺⻚异常；

操作系统：分配⼀⻚物理内存，并将代码从磁盘读⼊内存，然后继续执⾏ HelloWorld 程序;

HelloWorld 程序执⾏ puts 函数（系统调⽤），在显示器上写⼀字符串;

操作系统：找到要将字符串送往的显示设备，通常设备是由⼀个进程控制的，所以，操作系统将要写的字符串送给该进程;

操作系统：控制设备的进程告诉设备的窗⼝系统，它要显示该字符串，窗⼝系统确定这是⼀个合法的操作，然后将字符串转换成像素，将像素写⼊设备的存储映像区;视频硬件将像素转换成显示器可接收和⼀组控制数据信号;显示器解释信号，激发液晶屏;

OK，我们在屏幕上看到了 HelloWorld;

## printf实现原理

在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压⼊堆栈的⽅式来给函数传参数的（堆栈是⼀种先进后出的数据结构）。

最先压⼊的参数最后出来，在计算机的内存中，数据有 2 块，⼀块是堆，⼀块是栈（函数参数及局部变量在这⾥），⽽栈是从内存的⾼地址向低地址⽣⻓的，控制⽣⻓的就是堆栈指针了，最先压⼊的参数是在最上⾯，就是说

在所有参数的最后⾯，最后压⼊的参数在最下⾯，结构上看起来是第⼀个，所以最后压⼊的参数总是能够被函数找到。

因为它就在堆栈指针的上⽅。printf的第⼀个被找到的参数就是那个字符指针，就是被双引号括起来的那⼀部分，

函数通过判断字符串⾥控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏量了。
