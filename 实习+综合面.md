



## 软开相关

### 你觉得一个规范的研发流程应该是怎么样的？

确定需求，完成需求文档 -> 确定需求中具体需要实现的功能和实现的难点 -> 确定项目的架构 -> 确定前后端之间的通信协议，后端与后端之间的通信协议 -> 确定功能中需要的数据结构和算法 -> 估计线上环境和访问压力，确定部署方式 -> 完成代码的编写 -> 完成代码的测试 -> 完成代码的部署和上线











# 主管面

## 个人经历方面





### 印象中最难忘/深刻的事情

印象中最难忘的事情是，研二时期因为课题组的项目，需要到苏州金龙那边现场去测试车辆，然后当时是一个联合测试的环节，负责各个模块的工程师都在现场，现场是大家都在车上轮流测试自己的功能，从底层往上去测试，然后基本上是一个人在测试，其他人就都在旁边看着，进行测试的时候压力还是比较大的，因为一个环节出问题了，后面的测试都没法进行。然后当时我是负责车辆底盘的测试，因为之前我用 QT 写过一个测试界面，但是在现场出了点问题，测试界面没法控制车辆的驱动，然后就直接在车上开始排查问题，这时候是比较紧张的，因为当时所有人都在看着，好在用了十来分钟最终定位到问题然后解决了。经过这件事，我之后也算是有了一个比较大的心脏，在遇到问题的时候基本能够保持冷静。



### 为什么要转行

因为之前课题组有一个智能网联车辆编队控制的项目是跟计算机院合作的，他们负责通讯部分的搭建，我们负责控制代码的编写，然后调试都是计算院的同学负责，我们在旁边协助和学习。就是从这个项目开始，我接触到了 linux 环境下的 c++ 编程，对此产生了兴趣，后面也自学了数据结构、操作系统、计算机网络、数据库等一些基础知识，做了一些软件相关的项目。

- **车辆相关软开**

而且现在不是有个口号吗，叫 “软件定义汽车” ，车辆行业的软件开发也是需要一定的车辆基础的。





### 录用你的话你会怎么开展工作

1. 先向导师了解部门的职责业务，还有一些需要学习的前置知识
2. 根据了解到的情况制定一份近期的工作计划，让导师或者同时看下是否合理，如果合理的话就按照工作计划开展工作，让自己尽快融入到部门中去。





















 











旷世科技：

专注于提供基于人工智能的解决方案。它是中国四大人工智能巨头之一，以其面部识别技术而闻名，该技术在中国国内的许多应用中被广泛使用，例如在手机支付、身份验证和城市安全监控等领域。

旷视是一家聚焦物联网场景的人工智能公司
基于业界领先的AI科研与工程实力，旷视打造出软硬一体化的AIoT产品体系
面向消费物联网、城市物联网和供应链物联网的核心场景提供解决方案

旷视**人脸识别技术**基于深度学习、海量数据以及自研MegEngine开源框架

**智能视觉传感器（**AI智能测温技术、屏下指纹识别技术）

**机器人导航与定位**（SLAM建图与定位技术、机械臂抓取技术、三维感知技术）



**职位描述：**

1、负责自动驾驶系统中基础服务组件的开发；

2、负责各类传感器的接入及数据流的高效率管理；

3、负责自动驾驶系统级的性能调试和优化。



职位要求：

1、2024届本科及以上学历，计算机相关专业；

2、熟练掌握C/C++语言和计算机基础知识；

3、理解计算机体系结构和操作系统原理；对调度策略，内存管理等有自己的认识。

加分项：

1、有嵌入式电子技术类，计算机类竞赛获奖者；

2、有摄像头图像处理经验者；

3、有机器人或者自动驾驶相关开发经验者；

4、有参与大型软件开发经验者；

5、熟悉ARM架构和linux操作系统，掌握任意一门脚本语言。





**深开鸿**

- 王成录：开鸿安全数字底座，打造物联网传感器安全基石
- 深开鸿基于开源鸿蒙，围绕KaihongOS和超级设备管理平台打造全行业统一的安全数字底座。KaihongOS可以搭载到所有设备上，让所有的设备都讲同一种语言，实现数据之间天然共享、安全可靠、高效使用，这是匹配未来万物智联发展需求的核心。另外，通过一个统一的超级设备管理平台实现设备智能管理，将所有的硬件、数据等资源封装上传至平台界面交互。
- 鸿蒙操作系统，红外传感器，摄像头，通信，夜视仪、显示器方向都在做。
- 深开鸿基于KaihongOS构建的分布式边缘计算平台，为算力网络打造数据安全、精准可靠、场景完备、实时响应的开鸿安全数字底座。分布式边缘计算平台基于云原生边缘计算架构，实现云计算向边缘侧和端侧下移，在边、端侧实时处理，本地闭环。通过构建统一标准、统一架构、统一数据的算力边端设备，实现设备间无缝协同、自由组合，并支持算力计算任务按需流转、智能分配，从而更好地满足多样化的AI计算需求，提高整体算力网络服务效率。

- \1. 负责KaihongOS系统中有关KaihongBus子系统技术框架能力(Framework层)开发；
- /WiFi子系统的技术框架能力开发(包括WPA等)；
- /蓝牙(BLE/BR)子系统技术框架能力/协议栈能力开发；
- /电话子系统的技术框架能力构建(蜂窝数据/4G/5G/通话/Sms/...)；
- /网络管理子系统的技术框架能力构建(以太/WiFi/蜂窝/...)；
- / IPC(Inter-process communication)技术框架能力构建；
- /RPC(Remote Procedure Call)技术框架能力构建；



得物

IM、直播IM、长连接网关等基础服务开发工作； 2.负责公司相关中间件需求、SDK、提效工具等开发，推进中间件性能提升及业务接入。



## **期望薪资**

我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。























### 如何排解压力

如果说遇到压力大的时候，会选择听听歌，和朋友出去吃吃饭聊聊天来缓解压力，尽量的控制情绪不影响工作。

















### 在完成某项工作时，认为自己方式比领导要求的更好

原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作，并私下找领导分析下我的想法有哪些考虑是不周到的，这样也可以去提高自己。还有一种情况，假如领导要求的方式违背原则，我会及时提出自己的意见，让大家一起讨论，最后看看项目组之间的反馈，来定夺。



### 非科班生在工作中的挑战

**主要强调学习能力**

1. 在技术方面和对编程的热情方面，我丝毫不比科班同学差，因为大学里教的内容基本都是陈旧的，大家准备面试都是靠自学，反而因为我是非科班，我更加的努力，也特别珍惜来之不易的机会。
2. 如果要说科班同学有什么优势的话，我感觉他们的学习编程的氛围会好好一些，也就是遇到问题大家能一起交流，因为我们课题组和计算机院是有项目合作的，在项目过程中也认识了许多计算机院的同学，也会和他们一起讨论问题。 
3. 大学里教的计算机知识都很陈旧了，大家都是靠自学，如果说非科班在工作中遇到的挑战，我相信科班在工作中也是遇到一样的挑战，工作之后自学能力更加重要，互联网变化是飞快的，只有自学能力强的同学才能跟上步伐。















### 为什么选择华为而不是互联网

> 从实体经济去看

1. 一方面是我觉得纯互联网的经济是没有实体产业支撑的，但是像华为这样的互联网公司是有手机、智能穿戴等一些实体产业支撑的，有了实体产业支撑以后，整个企业的布局会更宽广一些，后面的发展上限也会更高。
2. 另一方面因为华为有实体产业支撑，所以对于一些想法是能够应用到产品上最终生产出来的，我个人还是比较喜爱这个过程的，因为比较有成就感。

> 对于国企

1. 国企的平台更大一点，可以接触更多的人，在私企里面，如果离开了自己的平台，在外面大概没有人认识了。
2. 并且国企背靠国家，发展前景不会比互联网差。
3. 国企的管理制度比私企更加完善，不过分强调以结果为导向，私企内卷式的工作氛围，很容易让自己为了工作疲于奔命，而影响了自己的生活和理想。



> 对于工业互联网、军工企业

1. 首先工业互联网是以后国家发展的重要方向，工业互联网强调的是工业，以实体经济作为落脚点，发展更为稳定，具有比较好的前景。尤其近几年在疫情的影响下，互联网受到不小的影响，反而以实体经济为落脚点的工业互联网在稳步发展，所以我认为工业互联网更加有利于个人的发展。
2. 然后我本人是车辆工程专业的，车辆工程本身就是一个交叉学科的专业，平常对工业界和互联网的东西都有一定的接触，我能够更快的适应工业互联网这个领域，找到自己的发展方向。





## 华为

### 职业规划

对于个人的职业规划的话，我希望能够在3-5年内能够在自己所在的职位上做出一定的成绩。

1. **在短期内规划**，主要是通过公司培训和自我学习马上进入工作状态，尽快熟悉工作职责和流程，不断优化自己的工作模式，尽可能多地参与实际项目开发，尤其是具有挑战性的项目。通过项目实践，深入了解岗位在实际开发中的应用，脚踏实地的用好每一块技术栈，积累项目经验，并不断提高自己的技术开发解决问题的能力；
2. 同时注重培养自己的的团队合作和沟通能力，在团队中，与同事有效地合作，沟通需求和问题，并共同解决问题，让自己融入项目组，成为项目组不可或缺的一部分。
3. **第2到第3年的两年内**关注行业趋势和技术发展的最新动态，会进一步去丰富自己的专业知识，进一步提高解决工程问题的能力，希望能够有能力去带领一个项目组，让整个项目组能够更好地适应整个行业的发展方向。
4. **再之后的远期规划**，我个人认为应该根据行业环境的变化、工作内容的变化、以及个人能力的变化去进行动态调整。





### 看待华为的以结果为导向

从正面的角度来看，以结果为导向的考核方式，可以在一定程度上激发员工的做事积极性，避免员工因为未完成任务而找各种借口，能够提高员工的做事积极性。但是因为一般来讲每个部门，每个员工负责的工作难度都不一样，过分强调结果而不考虑过程，会导致有的员工尽力工作却考核不合格，而有的员工没怎么出力却考核优秀。所以我觉这个以结果为导向是有一定合理性的，但是不能过分强调结果。



### 如何看待996加班

说实话作为一名刚刚步入社会的研究生，我还没有过多的考虑996存在的问题。我认为996是在自己有了一定的经济基础和社会地位之后才需要考虑的问题。

我目前可以说是处于事业的起步阶段，可以把更多的时间和精力投入到工作中去，把一个项目做完做好也会让自己获得成就感，能力提升很多。而且我在研究生期间也经常996，在课题项目进入关键节点的时候，加班到十点十一点点都是常态。所以对于996加班，我个人来说是不排斥的。







#### 如何看待加班：

加班这种现象其实是无法避免的，比如在项目的关键节点，一些突发事件，新产品新技术的更新迭代对时间要求也比较紧张。有一些不合理的加班现象要尽量去避免，比如部门之间的合作沟通出现问题导致无效的加班，项目流程没有合理规划造成的加班。

其实不仅仅是在公司里会加班，平时学校里很多时候也是加班。像导师安排科研项目、今年华为软件比赛也要高强度的加班，因为需要在有限的时间内高效保质的完成项目代码，推进项目进度，本科期间部门内偶尔会有几个月任务特别重，参加了国家级比赛，同时跟队友一起讨论项目的解决思路，但我觉得这些加班都是有意义的，能够带来自身能力的提升或者是服务同学。也遇到过不合理的加班，主要是科研项目的合作沟通造成的加班，有时候为了等别人的结果有一段时间无所事事，结果出来以后又需要在非常短的时间内去完成。



### 如何看待团队协作：

我认为团队协作是非常重要的。
合作方式就类似于我们比赛组建的团队，团队规模比较小，所以在沟通协作方面花费的成本较低，做事效率会比较高。此外团队成员专业性比较强一些，对于目标也具有强一致性，自驱力也更强。这种合作方式我也经历过心态转变，**本科第一次**比赛的时候什么都不太懂，我在学长的指导下学习工作，同时给他们一些反馈。**第二阶段**，作为团队的主力成员，主动提出一些可能可行的方案一起讨论。**第三阶段**是本科参加国家级比赛，也担任过带队队长，**把控项目的整体方向和进度，根据队员的各方面特长去分配任务**。但是到了**研究生**之后我慢慢意识到并不是所有人的专业能力都非常强，完美的团队很难找到而且如果团队有一个非常强势的领导成员，的积极性和主动性会有所降低。

我现在项目团队大部分时候还是主力成员角色，我觉得团队内更应该是平等的状态，**我们每人都积极参与进来然后出一个方案**，同时各自了解每个人的优点和劣势，一起讨论方案的可行性，只有竞赛或者科研项目关键节点停滞不前的时候，我也会主动承担责任，指出方向并表明会为结果负责。

#### 如何处理工作和竞赛中的团队协作

1. **明确目标和期望**：
   - 在团队合作开始之前，确保每个成员都清楚团队的总体目标和各自的期望。这有助于确保所有人都朝着同一个方向努力。
2. **分配角色和责任**：
   - 根据每个成员的技能和兴趣分配适当的角色和责任。这样可以确保团队的每个成员都在自己擅长和感兴趣的领域发挥最大的作用。
3. **有效沟通**：
   - 建立有效的沟通机制，比如定期会议、项目管理工具或共享文档，以保持团队成员之间的沟通畅通。及时沟通有助于解决问题并保持团队的进度。
4. **相互尊重和信任**：
   - 在团队中建立相互尊重和信任的文化。鼓励开放和诚实的交流，同时尊重不同的意见和观点。
5. **鼓励团队合作**：
   - 鼓励团队成员之间的协作和相互支持。团队成员应该被鼓励在遇到困难时寻求彼此的帮助。
6. **定期回顾和反馈**：
   - 定期回顾团队的进度和工作质量，并提供相互之间的反馈。这有助于团队成员了解自己的表现以及如何改进。
7. **灵活应对变化**：
   - 在工作和竞赛过程中，经常会出现意外的情况和挑战。保持灵活性并准备好适应变化是团队成功的关键。



#### 竞赛中角色，如何去沟通

组队核心成员，负责机器人调度算法的设计，

今年的华为软件比赛，就是机器人任务规划最优调度，控制机器人移动以实现无碰撞的最优移动路径的问题，写一个程序操控 4 个机器人执行前进、后退、旋转、购买、出售等动作来完成物品递送任务，同时赚取差价获得利润。在运行结束时，选手拥有的资金数即为最终分数，所获得的资金越高越好。

在这里我主要负责四个机器人在九个工作站的货物任务规划算法，采取贪心的策略规划机器人的路径。然后我同门主要负责协同任务规划算法的讨论及其机器人控制算法，也就是防碰撞算法（针对两个机器人正面撞击的特殊情况）,分工明确，有问题积极反馈讨论研究。

比如让每个机器人设置一条固定的线路，让各个机器人分工协作。
每个机器人负责某种物品的购买和出售。比如：让0号机器人负责原料1的购买和出售，让1号机器人负责原料2的购买和出售，让2号机器人负责材料3的购买和出售（1，2，3号物品原材料生成出来地速度快，所以用三个机器人负责每种物品地买卖），让3号机器人负责物品4，5，6的购买和出售。这样形成一条流水线，让物品不断地加工出来，再出售出去。
**贪心更新一个思路：**
按买卖物品任务按优先级分发给每个机器人执行，具体来说，我们可以把每个需要材料加工成产品的过程看作一个任务，比如4号工作台，它需要机器人运送材料1和材料2，那么把材料1和材料2运送到4号工作台就可以看作一个任务，所以我们就可以把每个需要材料加工的工作台看作一个任务点，给其分配一个优先级（你可以根据该工作台距离生成材料1和材料2的工作台的距离去定，采用贪心策略，距离越远优先级越低等）。把任务放入任务队列，把优先级高的分配给当前闲置机器人去执行。



我负责的任务规划采用了贪心算法，考虑每一帧时间计算最长三次买卖任务，买卖买卖买卖，如果买了卖不出去就亏钱，遍历一遍地图得到任务池，任务池中每一个代表一条任务链表示当前机器人可以选择的有效任务，

任务池排序规则
对于每一条任务有一定的优先级，比如买卖1和买卖4带来的收益不同，且同样是4卖给7，7原材料的缺失情况不同带来收益也是不同，所以对不同任务进行排序是必须。分别将任务分为三个大级，买卖1、2、3；买卖4、5、6；买卖7。针对同一级优先级任务先按照缺失原材料个数进行排序，比如第10、11号工作台都是4类型工作台，10缺类型1原材料而11没有原材料，故1（买）->10（卖）优先级比1（买）->11（卖）高。然后再按照单位距离收益进行排序，比如1（买）->4（卖）->4（买）->7（卖）和4（买）->7（卖）根据单位距离收益进行排序。













### 华为文化：

华为的核心价值观是

“以客户为中心，以奋斗者为本 ，长期艰苦奋斗 ，坚持自我批判”

狼性文化代表着三种精神：（狼性的话：提高自己的竞争力，也相当于是提高公司的水平，提高个人的水平）

- 敏感性：对市场敏感，对技术敏感 ，对客户需求的敏感
- 团队精神性：“群体作战”的团队精神，现代化组织的工作方式，因为个体很难在有效时间内完成复杂的任务。 
- 不屈不挠性： 正面面对挑战，不放弃，下定决心也要做成这件事。

1. **客户为中心**：华为非常重视客户需求，致力于为客户提供优质的产品和服务。公司的许多决策和创新都是以客户需求为出发点。
2. **奋斗者为本**：华为的文化强调对那些愿意投入时间和精力，不断追求卓越的“奋斗者”的认可和奖励。公司鼓励员工拥有强烈的事业心和责任感。
3. **团队协作**：虽然华为也强调个人的能力和成就，但团队合作被视为实现目标的重要途径。公司鼓励跨部门合作，共同解决问题。
4. **简单务实**：华为倡导简单务实的工作方式，反对空谈和形式主义。这体现在公司的管理方式和决策过程中，注重实际效果和效率。
5. **持续学习**：华为重视员工的个人成长和发展。公司提供各种学习资源和机会，鼓励员工不断学习新知识、新技能，以适应不断变化的市场和技术环境。
6. **绩效导向**：华为有一套明确的绩效评估体系，员工的薪酬和晋升与其绩效密切相关。这促使员工专注于产出和业绩。
7. **忠诚和奉献**：华为期望员工对公司有强烈的忠诚感和奉献精神。这种文化在华为的历史上有着深厚的根基，很多员工将公司视为自己奋斗的平台。
8. **开放和包容**：随着华为全球化步伐的加快，公司也在努力营造更加开放和包容的工作环境。这包括尊重不同文化背景的员工和合作伙伴，以及接受多样化的思维方式和工作方法。
9. **创新推动**：创新是华为文化的核心部分。公司鼓励创新思维，不断在技术和管理上寻求突破，以保持在激烈的市场竞争中的领先地位。

华为的企业文化强调硬件与软件的结合，即既重视技术创新，又重视人才培养和团队协作。这种文化造就了华为在全球通信设备市场的领先地位。



#### 如何看待华为

如何看待华为**(以技术为主，上进，奋斗，人才培养，团队合作**)

- 最开始对华为的印象就是爱国，我们国家的企业，也是很厉害的通信公司，然后是这几年m国的制裁，一个国家制裁一个企业，而华为能够在这样的情况下挺过这段时光，轻舟已过万重山，这几个字轻描淡写却让人感到振奋有力，这样一个企业天然就有一种力量吸引着热血青年的加入。
- 深入了解之后认识到华为的文化，以奋斗者为本，对每一个有技术肯努力的员工，有很好的福利，也有更大的平台，让员工在奋斗的时候没有后顾之忧，我认为企业能做到这点是十分难能可贵的。
- 华为的以客户为中心我也十分认同，因为我们的产品是提供给客户的，那一定是要客户满意，客户至上，只有这样，企业在业界才能有很好的口碑，长足发展。





#### 遥遥领先

华为的“遥遥领先”主要体现在**5G技术、人工智能、物联网技术和自主研发**。使得华为在市场上具备了较强的竞争力，也为中国科技产业的发展做出了重要贡献。

首先，华为在5G技术领域取得了重大突破。作为全球领先的通信设备制造商，华为的5G技术不仅在速度和稳定性方面表现优异，还具备了低延迟、高可靠性的特点，5G技术在智能制造、车联网、远程医疗等领域的应用更加广泛。

其次，华为在人工智能领域也取得了重大进展。华为的人工智能技术主要应用于云计算、大数据分析、智能家居等领域，通过自主研发的核心算法和架构，使得其产品和服务在市场上具备了较强的竞争力。 此外，华为在物联网领域也具备了较强的实力。华为的物联网设备具备了高效、稳定、安全的特点，可以广泛应用于智慧城市、智能制造、智慧交通等领域。

而**华为Mate60系列**的发布就是其**自研能力的重要表现**，华为Mate60系列自发布以来就一机难求，虽然**麒麟9000s性能上**和顶级旗舰SOC还有一定差距，但已经追上两年前的芯片性能，算是比较难得的成绩了！



### 华为员工的工作模式：

是高效、强调责任感和有极强的执行力。

1. **目标驱动**：非常注重目标和结果。员工通常会根据公司和部门的目标制定个人工作计划，并严格执行以确保达成目标。
2. **强调团队合作**：鼓励个人卓越，但团队合作同样重要。项目往往需要跨部门合作，员工需要具备良好的团队协作能力。
3. **灵活的工作时间**：有时会要求员工根据工作需要灵活调整工作时间，这可能包括加班和周末工作，尤其是在项目关键阶段。
4. **高强度工作文化**：工作节奏通常较快，工作强度较高。这种文化鼓励员工保持高效率和高标准。
5. **持续学习和自我提升**：鼓励员工持续学习和自我发展，公司提供各种培训资源和机会以帮助员工提升技能和知识。
6. **绩效导向**：华为的薪酬和晋升体系非常注重绩效。员工的业绩评估通常与工作成果直接相关。
7. **强调创新和质量**：华为非常重视产品和服务的创新和质量。员工被鼓励在日常工作中寻求创新，并始终保持对质量的高标准。
8. **国际化视野**：随着华为在全球范围内的扩张，员工有机会接触国际市场和客户，这要求员工具备全球化的思维和适应能力。







### 抗压能力：

**我认为我的抗压能力还可以。我会以结果导向，任务划分几个模块一步一步落实。困难是学习生活中不可避免的，越是困难越是我成长的时候，因为我觉得人与人之间的差距是在困难中表现出来的。**

在之前的实习、科研项目工作中，需要在关键节点下高效完成工作，遇到困难不放弃，积极调解沟通，这对我的抗压能力是一个很好的考验。

例如，在汇川实习的时候，要求在短时间内交付出机器人的控制软件的仿真界面的任务。首先我通过与团队组长同事开会讨论，弄清楚任务的细节，做好项目的每一模块的数据对接，优先安排最关键的任务，遇到困难和问题及时跟团队组长和同事沟通讨论，确保我们专注于共同的目标，一步一步的完成项目的每一个小模块。我还利用休息时间思考项目的优化思路，这帮助我保持清晰的头脑和积极的态度。最终，我不仅按时完成了项目，而且收到了团队组长的认可。这个短时间内完成任务的经历不仅增强了我的抗压能力，也让我学会了在高压环境中更有效地管理时间和资源。





#### 如何看待比较累的工作

投入工作当中是为了实现个人的价值和成就感。将工作视为自己发展的机会，通过不断付出努力和克服困难，获得更多的经验和技能，才能取得出色的表现和成功，个人成长也更快。即使工作辛苦，这样也能从中找到满足感和自豪感。

体面的工作通常会带来更好的收入和福利待遇，这能够支持个人和家庭的经济需求，提供更好的生活条件。虽然工作辛苦，但薪水和福利的回报可以为个人和家庭提供更稳定的生活保障，并有可能实现更多的梦想和目标。

但是，也需要注意平衡个人的身心健康。如果工作太过劳累，超出个人的承受能力，可能会导致身心健康问题。在这种情况下，可以考虑适当调整工作的强度和时间安排，寻求合理的工作与休闲平衡，保持良好的工作状态和生活品质。

总的来说，尽管辛苦，个人的态度和价值观很重要。通过正确的心态和努力，可以从中获得满足感、成长和收入。但也要注意平衡工作与生活，保持身心健康。在追求事业的同时，也要留出时间关注自己的家庭、朋友和兴趣爱好，找到工作与生活的平衡点。





### 性格：

(乐观，积极，踏实)

1.**脚踏实地，注重细节，不眼高手低**。刚工作入手处没有那么高端，从细微入手，不要挑活，不要看不起任何工作，别挑三拣四。
2.**增加自己的逆商、抗压能力**。结果导向，任务每几个小时划分。困难是学习生活中不可避免的，越是困难越是你成长的时候。人与人之间的差距是在困难中表现出来的。
3.**形成自己的思维习惯和工作习惯**。工作中大量是课本、专业上没有学过的，要有自己的工作思维和方法来应对问题。



#### 评价自己，别人评价你

自己：乐观，积极，踏实，核心竞争能力强

1. **团队协作能力强**：系统工程师需要不断和各个部门沟通交流需求，这个能力能够很好地协调各个部门之间的工作。
2. **抗压能力强**：对于高强度的工作能够按部就班就完成，不会因为工作的强度或者其他人的压力而影响到自己。
3. **责任心强**：答应了会做的事我就一定会去做，做事保证有始有终。
4. **学习能力强**：

在生活中：时间观念强、责任心强、对事情有始有终，抗压能力强



#### 自己的优缺点

**优点：**

1. 对于工业互联网来说，我觉得我有两个优势
2. 一是我是车辆工程专业的，车辆工程本身就是一个交叉学科的专业，在校期间既接触过应用层软件的编写，也对底层的通信有一定的了解，这种交叉学科的经历我觉得是比较契合工业互联网领域的，因为工业互联网也是比较注重底层的。
3. 二是我本身的学习能力还算可以，在校期间各门课的综合成绩排名专业前5%，并且从零开始学的数学建模也拿到过一些奖项，也是比较符合技术迭代更新比较快的工业互联网。

**缺点：**

1. 工作上过于谨慎，有瞻前顾后的思想，惟恐事情做的不到位。而实际上思想包袱背的越重，工作反而越难开展。这需要我解放思想，放下包袱，本着只要立足点站稳，基本点站牢的原则，大胆、细致地开展本职工作。
2. 进取精神还需要进一步增强。有时仅满足于常规性的工作和领导交办的工作任务，创造性开展工作的热情有待进一步激活和提升。
3. 存在报喜不报忧的情况。向上级领导汇报工作时说成绩、说亮点多了一些。讲问题、讲缺点少了一些，希望得到上级认可和表扬的心态也重了一些，敢于自我揭短、亮丑的勇气还不够。
4. 缺乏责任担当意识。有时会出现矛盾上交现象，一遇到问题就讲客观讲条件。遇到工作上不好解决的问题，就说难度太大，没有从主观上深挖工作干不好的根本原因。
5. 自己比较看重个人面子。对不属于自己的工作，常常会事不关已高高挂起，该提醒的时候碍于情面，没有及时提醒该发表意见的时候也很少做声。总觉得自己说了不同意见会让别人尴尬，也担心自己丢面子。



#### 坚毅度

在面对困难和挑战时保持决心和毅力。例如，在我实习过中，我负责一个项目的其中模块任务的交付，期间遇到了预料之外的技术。尽管压力多点大，但我坚持每天审视进展，调整策略，并积极与团队沟通，在正确的轨道上前进努力。最终，不仅按时完成了项目，还获得了组长的认同。这个经历不仅增强了我的技术和管理能力，也加深了我对团队协作和坚持到底的认识。我了解到华为非常重视这种奋斗精神和坚持不懈的态度，我相信我的这些经验和价值观将使我能够很好地适应华为的工作环境。





#### 最有成就感的事情

1. **生活上**

   - 坚持锻炼吧，这个习惯从大一开始，到现在已经坚持了快7年了。从最开始的为了减肥去每天去操场跑圈，到后来就是纯粹的享受这个过程了，每天都至少坚持一个小时的锻炼时间，风雨无阻。即使在疫情封校期间也会在宿舍楼下跳绳。

2. **学习上**

   - 国家奖学金，学科竞赛国家级二等奖：从零开始学习到最后拿到省级一等奖。

   







### 合作问题有冲突（分歧）

- 我觉得在合作过程中遇到冲突是很正常的，关键是要多互相讨论，不逃避冲突，求同存异，解决了冲突也会让自己成长。
- 在面对冲突时，可以组织小会议，跟对方及时沟通，鼓励对方主动提出自己的想法和建议，真诚地听取他们的意见。
- 然后理解他的观点后，找到导致冲突的根本原因，保持理性的态度来处理问题，再表达自己的观点和感受，避免去指责对方，寻找双方观点的共同点，考虑团队整体利益，并以合作的态度去寻找解决双方认同的方案，合理的分工任务。
- 这样我们的合作冲突得到了解决，团队合作也再次变得高效起来，项目也会按时交付，同时也会提升了我的沟通和解决问题的能力。



#### 团队合作出现问题什么定位

目标不一致，分工不合理可以导致出问题。团队成员可能因为个人利益和价值观的差异而导致对团队目标的理解和追求不一致，可能导致资源浪费和团队效率低下。为了解决这个问题，团队领导者可以明确和沟通团队的整体目标，并根据成员的个人目标和价值观制定相应的激励措施。此外，团队成员可以通过讨论和妥协来达成共识，以实现整体目标。





















### 反问环节

应届生培养、给自己有什么建议



实习中怎么完成的项目













#### 部门AI昇腾CANN软件栈

昇腾AI处理器及CANN软件栈。

昇腾AI芯片的计算核心,主要负责执行矩阵, 向量, 标量计算密集的算子任务,采用自研达芬奇架构; ARM CPU核心; 继承了8个A55. 其中一部分部署AI CPU, 负责执行不适合泡在AI Core上的算子(承担非矩阵类的复杂任务); 一部分用来部署为专用与控制芯片整体运行的CPU。 这两类任务占用的CPU核数可以根据系统实际运行的情况进行动态分配。

软件栈可以分为4层，最底下的是处理器的计算资源。比如前面提到的AI核心、CPU，还有负责数字视觉的计算模块等等；再往上是一些标准的加速库，负责给硬件输出算子层面的任务，此外还有任务调度器和一些预处理的模块；然后再往上就是框架层，顾名思义它就是用来调度和管理深度学习框架，并且生成离线模型用的。

值得注意的是昇腾AI处理器不仅支持主流的深度学习框架，还支持华为自研的名叫MindSpore的深度学习框架。那么通过MindSpore的深度学习框架产生的神经网络模型，可以直接运行在昇腾AI芯片上，而无需进行硬件的适配和转换，这就极大的提升了开发效率。这个软件栈的最后一层就是应用层，它的抽象程度最高，封装集成了很多专用领域的计算引擎，比如针对计算机视觉，还有针对语言文字处理的算法封装等等。用户也可以直接拿过来进行调用。那么除了这几个大的逻辑层次之外呢，昇腾的软件栈还提供了一个完整的开发工具链MindStudio ，包括编译、调试、性能分析、模型转换等等。



1. 芯片系统控制CPU；
2. AI计算引擎(包括AI Core和AI CPU);
3. 多层级的片上系统缓存(Cacha)或者缓冲区(Buffer);
4. 数字视觉预处理模块(Digitial Vision Pre-Processing, DVPP);
5. AI Core; 集成了2个AI Core. 昇腾AI芯片的计算核心，主要负责执行矩阵， 向量， 标量计算密集的算子任务，采用自研达芬奇架构；
6. ARM CPU核心； 继承了8个A55. 其中一部分部署AI CPU, 负责执行不适合泡在AI Core上的算子(承担非矩阵类的复杂任务)； 一部分用来部署为专用与控制芯片整体运行的CPU。 这两类任务占用的CPU核数可以根据系统实际运行的情况进行动态分配。 此外，还有部署了一个专用CPU的任务调度器，以用来实现计算任务在AI Core上的高校分配与调度； 改CPU专门服务于AI Core与AI CPU,不会承担任何其他的事务与工作；
7. DVPP: 数字视觉预处理子系统，用来完成图像视频的编解码。用于将从网络或者终端所获取的视觉数据，进行预处理已实现格式与精度的转换等要求，之后提供AI计算引擎。
8. Cache & Buffer: SOC片内有层次化的memory结构， AI core内部有两级的menory buffer, SOC片上还有8MB L2的buffer, 专门用来AI Core， AI CPU, 提供高带宽，低延迟的memory结构， 芯片内部还继承了LPDDR4x控制器，为芯片提供更大容量的DDR内存。
9. 对外接口： 支持PCIE3.0, RFMII, USB3.0等高速接口，以及GPIO, UART, I2C, SPI等低速接口。







​       项目最大并发是多少，和xx开源项目比有什么优势















## 项目相关

### 遇到最大的困难

当时去深圳汇川实习的时候，团队组长说要做一个机器人控制软件的可视化仿真图形界面，实时展示机械臂的运动轨迹状态和关节运动情况，验证轨迹规划的合理性。然后当时要求短时间内完成，当时组长说让用 opengl 写一个的，但是 opengl  我都没有学过，只懂一点 c++，于是最后选择了在 QT 用opengl (继承QGLWidget) 来做这个可视化仿真界面，然后当时花了一晚上了解了一下 opengl的相关库的基础知识及窗口创建在QT语法应用，第二天开始按照opengl的库函数、实例化窗口方法来写轨迹规划的可视化仿真代码，遍历理论轨迹的数据点，将每个点的坐标值（X，Y，Z）通过glVertex3f   **/ˈvɜː.teks/**函数绘制线段，从而在OpenGL窗口中显示了理论轨迹的运动路径。虽然最后的可视化仿真看着比较简陋，最后总算做出来了。从中我学会了，在面对时间紧迫的任务时，不能慌张，应该迅速将任务分解，分模块完成。



### 项目中的难点

1. 项目中我主要的工作可以分为两部分
2. 一部分是服务器网络框架、日志系统、存储引擎等一些基本系统的搭建，这部分的难点主要就是技术的理解和选型，以及将一些开源的框架调整后应用到我的项目中去。
3. 另一部分是为了提高服务器性能所做的一些优化，比如缓存机制、内存池等一些额外系统的搭建。这部分的难点主要是找出服务器的性能瓶颈，然后结合自己的想法去突破这个瓶颈，提高服务器的性能。



### 项目中遇到的困难、是如何解决的

1. 一方面是对不同的技术理解不够深刻，难以选出最合适的技术框架。这部分的话我主要是反复阅读作者在GitHub提供的一些技术文档，同时也去搜索一些技术对比的文章去看，如果没有任何相关的资料我会尝试去联系作者。
2. 另一方面是编程期间遇到的困难，在代码编写的过程中由于工程能力不足，程序总会出现一些bug。这部分的话我首先是通过日志去定位bug，然后推断bug出现的原因并尝试修复，如果是自己目前水平无法修复的bug，我会先到网上去查找有没有同类型问题的解决方法，然后向同学或者直接到StackOverflow等一些国外知名论坛上求助。















### 

## 谈薪

**18-20k，岗位薪资架构**，年终、绩效
**薪资=基本薪资+月度绩效**

**五险一金的基数和比例、社保公积金基数，比例，福利（节假日）**

**员工培养环节、实习试用期，有没有考核、会不会卡转正，薪资涨幅**

**年假情况、公司工作时间、加班情况、是否加班、加班有木有加班费**

**是否提供员工宿舍、租房补贴、吃饭补贴、公司是否有食堂**

**医疗保险是一档社保还是二裆**

**违约金，违约时间**

**是否出差**







年包30w以上（平时双休能保证吗，加班调休吗）

基本薪资吗，还是有绩效放在这里面

30%绩效

社保公积金1w基数，12%

试用期八折

一年后年假5天

餐补、交通补贴

成都老城区，房价25k

军工项目，可能会有出差



**标准月薪1W（基本工资50％、岗位工资20%、绩效工资30%）**
**年终奖根据上一年的整体工作表现、公司效益（20Kx14薪）**
**社保基数1w，公积金1W基数，12%，每个月1200**
**8：30-12：00、13：30-18：00（看部门项目组加班情况）**
**一两个月出差一次（1-2个星期）出差：去北京培训学习之类的）**
**问一下分到哪个部门，做什么的**









针对公司的一些问题

**理想对于应届生的培养是怎么样的?**

有半年到一年的训练营，导师一对一全流程跟踪培养，试用期薪资不打折

**2理想是怎么做到在一众电动汽车品牌中脱颖而出，上半年唯一一个实现盈利的，有什么诀窍?**

一一面试官从一个企到10期间要做什么，理想又是怎么做的，同行其他企业是怎么做的，从产品竞争力到企业组织都阐述了很多

**3聊了下蔚来开始做手机，有点手忙脚乱的感觉，手机已经一片红海，很成熟的市场了;**

**4问了下去年理想对于应届生的一些不好的传闻，**面试官说去年理想是第一次校招，不够成熟，很多决策有问题，今不是很大，但是能保证不会出现去年那样毁意向的情况，不知真假;

**5问了下在车企的技术团队中，软件开发是不是比较边缘**，面试官说恰恰相反，现在基本软件定义汽车，这个部门中是软件技术人员;

理想汽车

为什么选择理想？

选择 理想的话我个人是考虑了比较多的因素的：

1. 首先是**工作地**，因为 理想总部就在北京，北京比较繁华，发展机遇会多很多，个人觉得年轻应该多去外面打拼一下。
2. 然后是**平台**，在车企领域的话算是龙头，同时理想的造车水平排名是比较靠前的，据我的印象2023年9月，理想汽车共计交付新车36,060辆，同比增长212.7%，创单月交付量新高，同时根据和一面面试官的交流，我应聘的是云服务研发，做存储，函数计算，边缘计算，不局限于C++语言，业务比较多，我也比较感兴趣，所以我觉得在理想工作会有更大的机会去实现自己的价值。
3. 最后是**理想的一个企业文化**，“创造移动的家，创造幸福的家”是理想汽车的使命，理想本身就是一个比较注重技术**（增程电动技术、800V高压纯电平台、多屏全车语音交互技术、智能驾驶）**的公司，每年的专利申请数都是名列前茅的，这样的技术氛围我认为对技术研发人员是比较友好的。







对理想的了解

**1、公司介绍：（四大优势）**

理想汽车已是中国领先的新能源智能汽车制造商，设计、研发、制造和销售豪华智能电动汽车，坚持自建智能制造基地，并自建供应链体系，保障核心零部件供应。

2022年6月21日，理想汽车推出旗舰车型：[理想L9](https://www.zhihu.com/search?q=理想L9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})，一款[家庭智能](https://www.zhihu.com/search?q=家庭智能&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})旗舰SUV。运动型多用途汽车。

**2023年9月，理想汽车共计交付新车36,060辆，同比增长212.7%，创单月交付量新高，用户使用口碑评价还是挺高的。**

到2025年，理想汽车将形成“1款超级旗舰理想MEGA+5款增程电动车型+5款高压纯电车型”的产品布局，面向20万以上的市场，更广泛满足家庭用户需求。



理想汽车是中国领先的[新能源汽车](https://www.zhihu.com/search?q=新能源汽车&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})制造商，公司设计、研发、制造和销售豪华智能电动车。通过产品、技术和[业务模式](https://www.zhihu.com/search?q=业务模式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})的创新，为家庭用户提供更安全、更舒适、更便捷的产品和服务。首款量产车型理想ONE于2018年10月18日发布，是首个单车突破十万辆的造车[新势力](https://www.zhihu.com/search?q=新势力&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})产品，也是售价30万元以上单一车型月销量过万的真正“爆款”。

①核心技术

- 全自研[旗舰级](https://www.zhihu.com/search?q=旗舰级&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})增程电动系统

理想汽车开创城市用电、长途发电、露营放电的全新电动模式，增程电动系统配合[电池组](https://www.zhihu.com/search?q=电池组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})和双电机的[技术方案](https://www.zhihu.com/search?q=技术方案&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})，实现全纯电驱动，能源补给灵活，让用户拥有里程自由和户外用电自由。

- 为家庭打造的智能空间

理想L9开创三维空间交互体验，创新五屏交互模式、4D沉浸式影音系统、六音区语音自由对话，让每一位家人都能拥有沉浸的视听和娱乐体验。

- 全栈自研理想AD Max[智能驾驶系统](https://www.zhihu.com/search?q=智能驾驶系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})

理想汽车推动智能驾驶软硬件标配，理想L9搭载[激光雷达](https://www.zhihu.com/search?q=激光雷达&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})、高性能摄像头和强大的智能驾驶算力平台，提升全家人在旅途上的安全性。

②设计能力

“理想”一源于我们对用户需求的用心思考，源于我们对于[技术研发](https://www.zhihu.com/search?q=技术研发&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})的扎实投入；造型设计团队成员来自10个不同的国家，我们坚守“只做极致的产品”的设计信念，遵循“Less but Better”的[造型设计](https://www.zhihu.com/search?q=造型设计&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})理念。理想L9的造型[设计语言](https://www.zhihu.com/search?q=设计语言&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})命名为“The Future Avantgarde”（未来先锋设计），打造能留下时代记忆的设计。

Halo Design（星环）是[理想品牌](https://www.zhihu.com/search?q=理想品牌&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})的家族设计语言，理想L9首创无瑕星环，全新的星环头灯长度超过2米，中间没有任何断点，不只是具有指示功能的行车灯光，更是光彩夺目且无以伦比的艺术品。

③自建工厂

理想汽车拥有自己的生产资质，并于2016年在[江苏常州](https://www.zhihu.com/search?q=江苏常州&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})自建工厂，涵盖冲压、 焊装、涂装、总装、检测线、物流、IT等完整的整车生产工艺。 工厂占地面积1,085亩（72万平方米）， [建筑面积](https://www.zhihu.com/search?q=建筑面积&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})34万平方米。我们采用节能环保工艺，打造了绿色低碳的常州制造基地，实现了远低于国家标准的废水废气污染排放。

④直营模式

理想汽车搭建了线上线下一体化的直营销售和[服务系统](https://www.zhihu.com/search?q=服务系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665112489})，向用户直接提供更透明、更便捷、更高效的服务。理想汽车用户服务满意度超过98%。截至2022年5月31日，理想汽车在全国已有233家零售中心，覆盖108个城市；售后维修中心及授权钣喷中心253家，覆盖214个城市。

对OPPO的了解最初印象来源于的小学时候听到一个广告语，**充电五分钟，通话两小时**。当时就觉得这个公司好强，后面逐渐了解到OPPO在快充闪充这一块的技术的确是行业领先的。

再后面的印象就是OPPO的售后是做得很不错的，因为我在广州佛山都居住过，OPPO给我的最大印象就是大街小巷都是OPPO的官方店授权店，身边用OPPO的朋友也表示手机有什么问题都不需要专门拿到官方店去修，随便一个招牌带OPPO的都能帮忙解决。

再然后就是最近的一些了解的，因为近几年的手机行业也是逐渐内卷的，以往只需要堆料就能有比较大销量的情况也是不存在了。但是从OPPO最近发布的一些手机来看，OPPO确实有自己的技术思考在里面，比如新发布的旗舰机Find x5，OPPO在里面加入了自研的影像芯片，提供一个芯片级的图像优化，来提高手机摄影的效果。让我感觉OPPO是一个在技术上追求极致的公司。



对云服务研发的岗位了解？

做存储，函数计算，边缘计算一些底层的知识，部门技术栈不局限于C++，有嵌入式开发，车云业务之类的。

1.参与异地多活云边端单元化架构，统合公有云、边缘云和私有云等计算、存储和网络资源，形成理想融合云，通过算力供给和增值，为上层业务运行提供无差别一致的高效、运行环境。



你怎么理解理想的企业文化的？

**“掌控自己的命运，挑战成长的极限”**是理想汽车的组织使命。

**“超越用户的需求，打造最卓越的产品和服务”**是理想汽车的核心价值观。

用户参与改善产品和服务，和我们一起创造更多想法和灵感。

车载娱乐、任务大师、调音大师，
您的想法就是众多用车玩法的灵感来源。

- **用户导向**
  1. **从用户的角度设计产品、提供服务，避免做貌似用户喜欢的产品**
  2. 深入市场一线，洞察用户需求
  3. 简单专注，聚焦于满足目标用户的核心需求
  4. 一切以用户价值为依归
- **追求极致**
  1. **一面是是追求技术上的极致，另一方面是追求工作上的极致**
  2. 热爱产品，致力于打造伟大产品，崇尚强有力的产品表现
  3. 秉持工匠精神，对产品持续不断的推敲、打磨、优化
  4. 对待问题刨根问底，把工作做到极致
  5. 追求卓越品质
- **结果导向**
  1. 达成结果才是有价值的，达成结果必须遵循共同的价值观
  2. 以终为始，以结果来驱动行为，对结果负责
  3. 不找借口，突破客观条件限制，整合资源，达成结果
  4. 关注团队结果，团队成功才有个人价值



OPPO

专业是车辆工程，为什么选择这样一个偏软件的岗位？

我刚才自我介绍时也提到了，因为项目的原因接触到了软件开发，然后对软件开发产生了比较大的兴趣，并且自己也自学了许多软件开发的基础知识，让自己更加适合这样一个岗位。

对于专业来说的，我觉得不应该让专业去限制自己的就业，因为就一些互联网公司来看，他们内部的开发人员也不会都是计算机专业出身的。只要自身的技术达到公司的要求，我认为就可以去争取。





为什么选择OPPO？

选择 OPPO 的话我个人是考虑了比较多的因素的：

1. 首先是**工作地**，因为 OPPO 总部就在深圳，我本身的就是广东人，因为上学在南京呆了已经快7年了，个人来讲还是比较想回广东工作的。
2. 然后是**平台**，在手机领域的话OPPO的排名是比较靠前的，据我的印象每一年的手机销量基本都是前5，同时根据和一面和二面的面试官的交流，虽然OPPO的主要业务的手机产业，但是实际上OPPO在很多方面的业务上都有布局，比如智能家居智能穿戴，还有最近很火的车载OS方面。所以我觉得在OPPO工作会有更大机会去实现自己的价值。
3. 最后是**OPPO的一个企业文化**，OPPO本身就是一个比较注重技术的公司，每年的专利申请数都是名列前茅的，这样的技术氛围我认为对技术研发人员是比较友好的。



对OPPO的了解

对OPPO的了解最初印象来源于的小学时候听到一个广告语，**充电五分钟，通话两小时**。当时就觉得这个公司好强，后面逐渐了解到OPPO在快充闪充这一块的技术的确是行业领先的。

再后面的印象就是OPPO的售后是做得很不错的，因为我在广州佛山都居住过，OPPO给我的最大印象就是大街小巷都是OPPO的官方店授权店，身边用OPPO的朋友也表示手机有什么问题都不需要专门拿到官方店去修，随便一个招牌带OPPO的都能帮忙解决。

再然后就是最近的一些了解的，因为近几年的手机行业也是逐渐内卷的，以往只需要堆料就能有比较大销量的情况也是不存在了。但是从OPPO最近发布的一些手机来看，OPPO确实有自己的技术思考在里面，比如新发布的旗舰机Find x5，OPPO在里面加入了自研的影像芯片，提供一个芯片级的图像优化，来提高手机摄影的效果。让我感觉OPPO是一个在技术上追求极致的公司。



对系统工程师的岗位了解？

1. 对安卓系统相关功能进行优化，比如提高系统的稳定性，改善第三方应用的兼容性等。
2. 一些通信协议的开发
3. 操作系统生态链的开发与优化，比如车机系统、智能家居的系统
4. MCU的RTOS系统开发



你怎么理解OPPO的企业文化的？

OPPO公司的企业文化主要有四个关键词：**本分、用户导向、追求极致、结果导向**。排在第一位的就是本分，公司非常看重人品。

- **本分**
  1. **一方面是出现问题时，先从自身去找原因，而不是将问题甩给别人。**
  2. **另一方面，是只要属于自身职责之内的事情，就要把他做好，不管有没有硬性要求。**
  3. 隔离外在的压力和诱惑，保持平常心态，回归事物的本源，把握住我们应该做的合理方向
  4. 本分是要求自己而不是要求别人，当出现问题时，首先求责于己
  5. 本分规范了与人合作的态度 —— 我不赚人便宜
  6. 本分高于诚信，即使没有承诺，本来应该做的事情也要做到
- **用户导向**
  1. **从用户的角度设计产品、提供服务，避免做貌似用户喜欢的产品**
  2. 深入市场一线，洞察用户需求
  3. 简单专注，聚焦于满足目标用户的核心需求
  4. 一切以用户价值为依归
- **追求极致**
  1. **一面是是追求技术上的极致，另一方面是追求工作上的极致**
  2. 热爱产品，致力于打造伟大产品，崇尚强有力的产品表现
  3. 秉持工匠精神，对产品持续不断的推敲、打磨、优化
  4. 对待问题刨根问底，把工作做到极致
  5. 追求卓越品质
- **结果导向**
  1. 达成结果才是有价值的，达成结果必须遵循共同的价值观
  2. 以终为始，以结果来驱动行为，对结果负责
  3. 不找借口，突破客观条件限制，整合资源，达成结果
  4. 关注团队结果，团队成功才有个人价值





地平线



对中间件软件开发的理解？

1. **中间件的定义**：中间件是介于应用软件和系统软件之间的一类软件，它使用系统软件所提供的基础服务，衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。
2. **自动驾驶中间件**：自动驾驶需要接收不同的传感器信号，然后进行感知、规划和控制，并由转向、油门和制动这些硬件系统来完成整个过程。所以自动驾驶的中间件会涉及到ECU管理、传感器管理、车辆模型管理、通信管理、任务管理、数据管理、安全管理、诊断管理、OTA管理、可视化管理等一些功能模块的开发。



对自动驾驶行业的思考或者未来发展趋势

由于目前国家政策没有完全放开，L4的量产还是比较困难的，所以近几年的自动驾驶公司，比如理想、华为、momenta等都把大部分精力放到L2级别的自动驾驶中去。

在民用方面的自动驾驶的话，更多对L2级别的自动驾驶进行落地，比如近几年比较火的行泊一体。但是只要政策放开的话，L2必将过度到L4去。

然后对于L4级别的自动驾驶，目前更多的是用在物流场景中，比如美团和京东在搞的无人配送，还有港口码头的无人运输等，这些更多的是toB的业务，也是自动驾驶未来一个比较明确的发展方向。

然后无论是L2还是L4，这些自动驾驶算法都需要硬件作为算力支撑，近几年美国在这方面也一直给中国制裁，前几天我还看到个新闻就是英伟达和AMD都限制对中国的芯片供应，所以我认为自动驾驶的发展方向不能局限于算法的设计落地，更多地需要考虑国产芯片的发展，不然容易被外国掐脖子。



对地平线的了解？怎么关注到地平线的？

是一家软硬件结合的公司，即做自己的自动驾驶芯片，也有在芯片的基础上去做一些计算平台。国内做计算平台的公司我我大概了解几个，华为、地平线、寒武纪、英伟达，地平线在这些公司里面也是比较靠前的。

关注的话，是我有一个同学去年在你们公司实习过，然后推荐给我的，说地平线也是自动驾驶相关的公司，比较契合我的专业，然后他在实习过程也感觉地平线的氛围比较不错。



你在横向比较公司中会比较看重哪些呢？

1. **平台**：根据我的了解地平线在智能驾驶计算平台这个领域中，可以算是独角兽了。在这个领域中的竞争者我了解的大概有华为MDC、寒武纪、英伟达等，所以我认为地平线的平台足够大，会有更多的机会能够让我实现自己的价值。
2. **行业**：今年是互联网寒冬，这一点从校招的情况就可以看出来了。然后我个人觉得近几年的热门行业主要是自动驾驶和芯片半导体，然后地平线本身就是一个软硬件都在做的公司，所以我觉得本身的发展前景还是很好的。
3. **工作氛围**：重视技术，每周都会组织技术交流会。并且分配的导师都是比较负责的。



自动驾驶分级



1. **Level 0（无自动化）**
   - 由人类驾驶者全权操作汽车，在行驶过程中可以得到警告和保护系统的辅助。
   - 车辆完全由驾驶员掌控，驾驶员拥有绝对控制权，且车上不存在任何的自动驾驶技术。
2. **Level 1（辅助驾驶）**
   - 通过驾驶环境对方向盘和加减速中的一项操作提供驾驶支援，对其他的驾驶动作都由人类驾驶员进行操作。
   - 驾驶员依然需要去驾驶车辆，只不过出现了像ACC自适应巡航等安全系统，对驾驶员的驾驶起到一个辅助的作用，手不得离开方向盘，眼不得离开周围路况。
3. **Level 2（部分自动化）**
   - 通过驾驶环境对方向盘和加减速中的多项操作提供驾驶支援，其他的驾驶动作都由人类驾驶员进行操作。
   - 自动驾驶技术就可短暂接管一些驾驶任务，眼和手可短暂获得休息，但是仍需做好随时接管驾驶任务的准备，时刻准备着，因为还不足以应对变化的交通路况。
4. **Level 3（有条件自动化）**
   - 由无人驾驶系统完成所有的驾驶操作。根据系统请求，人类驾驶者提供适当的应答。
   - 来到L3这个级别，在某种意义上就可以算作自动驾驶，也可以把这个级别称为真正自动驾驶的开端。驾驶员可以将手离开方向盘，脚离开踏板，车辆几乎可以独立完成全部的驾驶操作。理论上可以刷刷微博玩玩手机啥的，但驾驶员还是要有意识的去随时接管驾驶任务。
5. **Level 4（高度自动化）**
   - 由无人驾驶系统完成所有的驾驶操作。根据系统请求，人类驾驶者不一定需要对所有的系统请求作出应答，限定道路和环境条件等。
   - 第4等级可以说是真正意义上的自动驾驶，不需要驾驶员随时接管，也不需要驾驶员的干预，你只需要坐在驾驶席上做自己想做的事，剩下的一切交给技术就好了。
6. **Level 5（完全自动化）**
   - 由无人驾驶系统完成所有的驾驶操作。人类驾驶者在可能的情况下接管。在所有的道路和环境条件下驾驶。





用中文解答

C++做一下，acm模式，根据输入cin，代码每行注释一下，给出思路

代码题输出，准备好IDE测试

简述问的问题，并且回答一下

中文

详细点

代码每行注释一下，说一下思路









## 控制系统方案

**逆运动学求解、轨迹规划、运动控制**

该原型机臂架采用**六自由度机构驱动喷嘴运动**，液压执行机构由**电液比例多路阀控制**，由**操纵工用遥控器**通过 **PLC 控制器型电液比例多路阀**发出操控信号量，实现开环控制。本项目增设臂架运动参数检测系统，通过上位机进行运动闭环控制建模、轨迹规划以及控制系统设计，实现自动控制。

#### 液压系统

机械臂七个自由度运动，即整体臂架的回转、大臂的仰俯、小臂的仰俯、伸缩臂的伸缩，喷头垂直于伸缩臂中心轴的 360°回转、及喷头水平 240°回转、以及 喷嘴 8°的刷动，都是**液压驱动**，其中整体臂架的回转由液压马达和减速机组成的液压回转装置驱动，大、小臂的仰俯动作以及伸缩臂的伸缩，均由液压缸驱动，而喷头的垂直、水平旋转则分别由 360°、240°螺旋油缸驱动，上述 **6 轴自由度的运动均由电液比例流量-方向**符合控制阀进行控制，而喷嘴的刷动则不需人工干预，由**液压马达通过凸轮机构产生循环摇摆运动**。

#### 电控系统

湿喷台车的电气系统采用 **CAN-BUS 总线**技术、基于嵌入式系统的工程机械控制器为核心、是实现机电液一体化控制的新型控制系统，主要负责对**液压控制阀、整机、发动机和液压泵的控制**。

#### **机械臂运动控制逻辑：**

通过机械臂采样获取**隧道轮廓信息**，利用原控制器发射末端喷嘴运动方向控制指令，上位机会生成该方向上的运动轨迹，然后通过逆运动学计算关节角度，再发送给中间运动控制器控制机械臂的运动.

- 人工操作遥控器**发出机械臂各关节运动指令**
- 遥控器发射端调制并发射信号
- 遥控器接收端接收并解调信号
- **=上位机进行轨迹规划和逆运动学解算得到各关节控制量**
- **中间控制器发送控制指令**
- PLC控制器A/D、D/A转换信号
- **电液比例阀**执行动作
- 各油缸马达运动
- 机械臂各关节运动
- 完成喷嘴末端运动路径人工操作
  

传感器选型

- 检测机械臂各关节位姿信息，用于控制器输出信号运算
- 角度传感器——测量臂杆的旋转角度及俯仰角度，**旋转编码器5个**；
- 直线位移**拉伸传感器1个**——测量臂杆的伸缩长度。
- **数据传输方式 ----- CAN 信号传输**
- **加装六个传感器：大臂旋转编码器、大臂俯仰旋转编码器、小臂俯仰编码器、小臂伸缩拉线传感器、喷嘴俯仰传感器、喷嘴正逆转传感器。**







### 喷浆操控模式

- **手动模式：**通过遥控器手柄操作六个关节，**每个关节是独立运动**的，施工人员一般每次只控制一个关节的运动，以便直接观察运动的趋势。
- **半自动模式：**该模式下**直接操作机械臂末端喷头的运动**，其运动参数包含**三个移动自由度和三个转动自由度**，半自动模式下只控制三个移动自由度和两个转动自由度。**半自动模式需要借助遥控器发射运动信号**。通过**上位机软件选择半自动模式**，原遥控器的指令就会发生变化。
- **全自动模式：**首先进行**坐标系的标定**，然后完成隧道轮廓点的采样生成**隧道拟合轮廓曲线**，再设置**自动喷浆参数**，最后仿真并验证生成的**理论轨迹**是否合理。如果轨迹是合理的，则将**轨迹发送至下位机**执行，如果不合理则重新设置参数生成新的轨迹。





## 六自由度机械臂运动学模型

喷浆机械臂具有 6 个自由度，前面 4 个自由度控制末端喷头的位置，但是引入了冗余自由度，通过结合喷浆机械臂的运动轨迹以及其控制原则给出了合理的约束，采用**二连杆机械臂模型**求解了 **6 自由度**的喷浆机械臂的逆运动学，求解过程简洁高效，不需要依赖大量的矩阵运算，能够快速给出解，因此可以用于实时控制。





- 针对**逆运动学**求解提出约束关节的解析法求解存在冗余的喷浆机械臂，根据末端执行器的位姿求解各关节的变化量。



### 机械臂运动学模型

利用 **DH 建模法**构建喷浆机械臂的坐标系，写出 DH 参数，在坐标系中添加了喷头坐标系e，用来描述目标位姿与受喷面的角度关系和距离。两个移动关节被合并到一起成为一个关节用坐标系 4 。

#### 正运动学求解

- 机械臂的正运动学可通过 D-H 法建立，建立各个关节的坐标系，通过**齐次坐标转换**得到该机械臂的运动学方程，经过矩阵变换即可计算出末端执行器的位姿。
- D-H 法是机械臂运动学参数化方法，它使用四个参数来描述相邻连杆之间的转动和平移关系，即连杆长度a、绕 Z 轴旋转的角度α、在 Z 轴上的平移量d以及相邻连杆的夹角。



#### 逆运动学求解

##### 几何法

- **正向运动学公式**：0-6T 从坐标系0到坐标系6的变换矩阵。
- **决定末端位置的是前面 4 个关节**，但是由于存在冗余自由度，这里有 3 个已知参数，可以建立 3 个方程，但是有四个未知数，直接根据公式求解的方式是无法解出的。通过喷浆轨迹分析**结合几何法**来求解**前面四个关节角度**，并利用**正向运动学公式通过分离变量**的方式求解关节 5 和关节 6。
- 关节 2 和关节 3 被描述成**平面二连杆模型**。
- 通过在这个模型下的(![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps1.png))求解出关节角度值。
- 通过末端喷头在X-Y平面内的值就可以**求出关节角1**
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps2.png)
- 分离变量角度1，**求出关节角度5，6**，
- 确定末端喷头位置的四个关节变量和末端喷头的位置可以建立函数关系
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps3.png)
- 确定末端喷头的位置只需要3个关节角，这里有4个关节角，引入了冗余自由度，下面通过分析**喷浆机械臂的运动轨迹来添加约束使得方程能够被求解**。但是这里先给出没有添加约束条件的关节角2和关节角3的计算公式：
- **根据几何法求解关节2、关节3角度值**
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps4.png)
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps5.png)



##### 解析法

- 使用约束关节法进行喷浆机械臂逆运动学求解，通过**已知末端执行器坐标系位姿矩阵T**，求解出![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps7.png)的值。
- 由于喷浆机械臂的![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps8.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps9.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps10.png)存在冗余关节，如果直接用解析法求解，会出现多解或无穷解。求解![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps11.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps12.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps13.png)时，通过末端执行器所处三维空间坐标为![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps14.png)，对特定关节进行约束，达到准确求解的目的。
- 利用约束关节的解析法和工作空间的划分获得最少运动关节数的最优解。



1. **定义机械臂结构：**
   - 确定机械臂的结构，包括每个关节的类型、长度，以及坐标系的选择。
2. **建立坐标系：**
   - 在每个关节处建立坐标系，通常选择DH（Denavit-Hartenberg）参数描述。
3. **描述末端执行器的位姿：**
   - 根据机械臂的坐标系，描述末端执行器在全局坐标系中的位姿，通常使用平移矢量和旋转矩阵或四元数。
4. **编写运动学方程：**
   - 利用机械臂的运动学模型，编写表示末端执行器位姿与关节角度之间关系的方程组。这可以使用转换矩阵和运动学方程来完成。
5. **解方程组：**
   - 将得到的方程组进行求解，得到关节角度的解。这可能涉及到代数运算和解方程的数学技巧。
6. **验证解的可行性：**
   - 验证计算得到的关节角度是否在机械臂的可行范围内。





### 机器人正逆运动学

**正运动学（Forward Kinematics, FK）**指的是给定关节（驱动器）的位置，计算机器人的手臂（或末端执行器）的位置和方向。

**逆运动学（Inverse Kinematics, IK）**是指给定机器人末端执行器的位置和方向，计算实现该位置和方向所需的关节角度。

#### 正运动学的步骤：

1. 定义机器人的几何参数，如关节轴线、关节位置等。
2. 建立每个关节的坐标系。
3. 使用D-H（Denavit-Hartenberg）参数方法，计算每个关节相对于前一个关节的变换矩阵。
4. 连乘各个关节的变换矩阵，得到机器人末端执行器相对于基座的变换矩阵。
5. 从最终的变换矩阵中提取末端执行器的位置和姿态。

#### 逆运动学解析法步骤：

1. **提取末端位置和姿态信息**：从期望的末端执行器的位置和姿态信息出发。
2. **解析位置**：基于机器人的几何结构，解析计算出末端执行器位置所对应的关节角度。这一步可能涉及到三角函数、向量和几何学的计算。
3. **解析姿态**：基于机器人的结构和先前计算出的位置关节角度，解析计算出末端执行器姿态对应的关节角度。
4. **检查解的有效性**：不是所有的数学解都是物理上可行的。需要检查解是否在机器人关节的运动范围内。
5. **选择解**：如果存在多个解，需要根据某种标准（如最小运动原则、最接近当前位置等）选择最佳解。



步骤：

1. **建立坐标系**：在机器人的每一个关节和末端执行器上建立坐标系。常见的坐标系有世界坐标系、基座坐标系、各关节坐标系和工具坐标系。
2. **分析机构几何关系**：根据机器人的结构，分析各个关节、连杆之间的几何关系。这包括长度、角度以及它们之间的相互关系。
3. **建立方程**：使用几何学的知识，建立关于关节变量的方程。这些方程通常包括三角函数、向量运算等数学操作。
4. **求解方程**：使用数学工具求解上一步建立的方程，得到关节变量的值。这可能需要使用代数方法、迭代方法等。
5. **验证解**：求解得到的关节变量需要在机器人的工作范围内，并且要满足机器人运动学的约束条件。需要对求解得到的解进行验证，确保其合理性和准确性。
6. **反解求取**：如果机器人逆运动学存在多解，需要根据实际应用场景或者其他辅助条件来选择最合适的解。

优点

1. **计算效率高**：对于结构简单的机器人，几何法求解逆运动学问题的速度很快。
2. **直观易懂**：几何法依赖于机器人结构的直观几何关系，相对容易理解。

缺点

1. **不适用于复杂机构**：对于结构复杂的机器人，几何法求解起来非常困难，甚至无法应用。
2. **可能存在多解或无解的情况**：几何法求解的解可能不唯一，或者在某些情况下可能没有解。



## 自我介绍：

面试官你好，我叫彭凯，目前在中南大学读研三，专业排名前10%，我的研究方向主要是机器人控制软件，我有一段实习经历，在深圳汇川技术，主要负责喷涂机器人的上位机软件客户端开发工作，利用C++和Qt做了个控制软件界面。**上下位机之间的通信采用CAN通讯协议，主要用来传输传感器的数据、遥控器手柄信号，上位机实现了编码发送信息函数和解码接收信息函数，**上位机先计算出**带有位置和速度的轨迹**，然后开启时钟，将关节位置和速度发送给下位机，下位机进行控制，然后再根据**当前时间取得新的插值点**，再发送位置和速度给下位机。增加OpenGL可视化界面，实现对机械臂三维模型的运动控制和显示。

上位机软件逆解6个关节角度的运动控制信息通过CAN通信给控制器。控制器将传感器检测到的6个关节角度，遥控器数据编码通过CAN线发送给上位机。



在Linux环境下搭建的高性能网络服务器，可以支持相对数量的客户端并发访问并及时响应。这个项目是我看书以及结合网络上开源代码完成的，服务器的⽹络模型是主从reactor加线程池的模式，IO处理使用了IO多路复⽤技术，异步日志系统采用双缓冲技术，使用有限状态机和正则表达式解析HTTP请求报文，实现了GET和POST的解析，还可以通过对GET和POST请求的解析，增加了下载文件和上传文件的功能，在这个项目中我做了一些优化，考虑到高并发热点页面频繁访问的问题，加入了缓存机制，最后还做了对⽹络框架的测试，使⽤webbench创建1000个进程对服务器进行60s并发请求，测试结果表明，对于短连接的QPS为1.8万，对于长连接的QPS为5.2万。通过这个项目，我对TCP和网络编程有了一定的理解。

还有一个项目是在Linux环境下利用C++11实现的简易RPC网络通信框架，实现了服务的发布、注册、远程过程调用等功能，在这个项目中我使用zookeeper的watch/wɑtʃ/观察机制和znode节点实现服务的的分布式部署，利用protobuf进行数据的序列化和反序列化，利用主从Reactor模型（muduo）进行高性能网络发送，利用生产者消费者模型编写异步日志模块。



做了一个C++的小型关系型数据库，底层实现一个面向磁盘的缓存池，可扩展哈希表做页面映射，B+树索引作为存储引擎，有悲观锁和乐观锁两种模式，实现数据查询，执行器用到了火山模型，还用到二阶段锁支持了三种事务隔离级别的并发控制，实现死锁检测、解除死锁的后台线程。











发送接口函数是将要发送的CAN消息（关节传感器数据）编码添加到发送队列中，定时将其发送到总线上，以避免消息的丢失或冲突。

接收接口函数是将接收到的数据放入接收队列中，作为一个缓存区来存储接收到的CAN数据帧，接收队列采用循环队列的数据结构实现，使用先进先出的原则进行数据帧的存储和管理。CAN总线可能接收到多个节点的数据帧，因此使用接收队列可以帮助系统缓存并按顺序处理这些数据帧，避免数据的丢失或冲突。

主从reactor==多Reactor模型：核心思想是，主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I/O事件交给sub-reactor负责分发。其中 sub-reactor的数量，可以根据CPU的核数来灵活设置。主要就是为了分担单Reactor模型下Reactor模型的压力（一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方）。











## 喷浆：

### 项目多线程组件

- 在喷浆机械臂项目中，一个**线程收集传感器数据**，在另一个**线程逆运动学计算**，在第三个**线程进行实时的轨迹规划**，同时**主线程用于处理用户界面的响应**。

- 在实现多线程时，要注意**线程安全和资源竞争**的问题。特别是在**更新UI或访问共享数据**时，需要使用**信号和槽**或其他线程同步机制来保证安全。Q**t 的信号和槽机制是线程安全的**，这意味着你可以在**不同的线程之间发送信号**，Qt 会负责跨线程的通信。

- 多线程是一个常见的需求，用来处理**实时传感器数据采集、机械臂控制、用户界面响应**等多个并行任务。Qt 实现多线程功能：


1. **QThread**： `QThread`是 Qt 提供的用于多线程编程的基础类。通过继承`QThread`并重写其`run()`方法，**在新线程中执行任务**。这适用于**长时间运行或需要频繁更新的任务**。

   ```c++
   class WorkerThread : public QThread {
       Q_OBJECT
       void run() override {
           // 你的长时间运行的任务或循环
           emit resultReady(someResult);
       }
   signals:
       void resultReady(const QString &s);
   };
   ```

2. **QtConcurrent**： `QtConcurrent`模块运行函数或方法**作为并发任务**。它非常适合用于没有必要直接使用线程的并发操作。

   ```c++
   #include <QtConcurrent>
   void myFunction() {
       // 需要并发执行的代码
   }
   // 在某处调用
   QFuture<void> future = QtConcurrent::run(myFunction);
   ```

3. **QObject::moveToThread()**： 你可以创建一个`QThread`对象，并将`QObject`及其子类的实例移动到这个线程中。使用`moveToThread()`方法**可以将对象的所有槽函数的执行移动到新线程**。

   ```c++
   QThread *thread = new QThread;
   Worker *worker = new Worker;
   worker->moveToThread(thread);
   connect(thread, &QThread::started, worker, &Worker::process);
   connect(worker, &Worker::finished, thread, &QThread::quit);
   connect(worker, &Worker::finished, worker, &Worker::deleteLater);
   connect(thread, &QThread::finished, thread, &QThread::deleteLater);
   thread->start();
   ```

4. **QThreadPool**： `QThreadPool`管理一组线程，可以重用这些**线程来运行任务**。这适用于执行大量的短期任务。任务是通过继承`QRunnable`并实现其`run()`方法来定义的。

   ```c++
   class MyTask : public QRunnable {
       void run() override {
           // 任务代码
       }
   };
   // 添加任务到线程池
   QThreadPool::globalInstance()->start(new MyTask);
   ```



#### 项目Qt组件

1. **GUI模块**:
   - `QWidget`: 这是Qt中所有**用户界面对象的基类**。你提到通过继承`QWidget`并重新实现虚拟事件处理程序来创建自定义窗口小部件。
   - `QOpenGLWidget`: 如果你在GUI中集成了OpenGL，那么可能会用到这个类，它提供了一个用于**渲染OpenGL图形的窗口部件**。
   - 信号与槽机制: 通过`QObject::connect()`实现信号和槽的连接。
2. **OpenGL模块**:
   - 可能使用了`QOpenGLContext`, `QOpenGLBuffer`, `QOpenGLShaderProgram`等类来实现OpenGL的渲染和操作。
3. **通讯模块**:
   - 如`QTcpSocket`, `QUdpSocket`等，或者如果你是通过串口通信，可能用到了`QSerialPort`。
   - **对于CAN通信，Qt没有直接的支持，使用了硬件厂商提供的SDK**。
4. **Eigen库**：用于矩阵运算。
5. QThread线程库：









### Qt信号和槽：

Qt 的信号和槽（Signals and Slots）机制在多线程环境中体现得非常明显，因为它提供了一种安全的方式来进行跨线程的通信。

在**单线程应用程序**中，信号和槽用于**对象**之间的通信。在**多线程应用程序**中，信号和槽同样可以用来在**不同的线程**之间传递信息，Qt 框架会自动处理线程间的同步问题。

当你在一个**线程中发射（emit）信号**，并且该**信号连接到了另一线程中对象的槽**时，Qt 会自动将**信号消息排队到接收对象的事件循环**中，确保**槽函数在接收对象所属的线程中被调用**。这种方式称为队列连接（Queued Connection）。

以下是几个关键点，它们概述了信号和槽在多线程中的体现：

1. **线程安全的通信**：
   - 信号和槽机制是线程安全的，可以用于将数据从一个线程传递到另一个线程，无需担心竞态条件或锁问题。
2. **队列连接（Queued Connection）**：
   - 当信号和槽跨线程工作时，默认情况下，Qt 使用队列连接。这意味着当一个线程向另一个线程发射信号时，该信号会被放入事件队列中。接收线程会在处理完当前事件后，按顺序处理队列中的信号。
3. **直接连接（Direct Connection）**：
   - 如果你选择直接连接，槽将在信号被发射的那个线程上直接执行，而不管接收对象属于哪个线程。这种方式需要开发者自己确保线程安全。
4. **自动切换连接类型**：
   - 当连接发生在同一个线程内时，Qt 使用直接连接。当涉及到不同线程时，Qt 自动转换为队列连接。
5. **事件循环**：
   - 每个线程可以有自己的事件循环，允许槽函数在适当的上下文中执行。
6. **信号连接的灵活性**：
   - 你可以在运行时连接或断开信号和槽，这使得动态多线程编程变得简单。

下面是一个简单的跨线程信号和槽的例子：

```c++
class Producer : public QObject {
    Q_OBJECT
public:
    void produce() {
        emit produced("This is a message from another thread");
    }
signals:
    void produced(const QString &message);
};
class Consumer : public QObject {
    Q_OBJECT
public slots:
    void consume(const QString &message) {
        qDebug() << "Message received in consumer thread:" << message;
    }
};
// 在主函数中
Producer *producer = new Producer();
Consumer *consumer = new Consumer();
QThread *thread = new QThread();
consumer->moveToThread(thread);
// 连接信号和槽
connect(producer, &Producer::produced, consumer, &Consumer::consume);
thread->start();
producer->produce(); // 这将导致在consumer线程中调用 consume 槽
```

在这个例子中，当`produce()`方法被调用时，它将在`producer`对象所在的线程中发射`produced`信号。然后，由于`Consumer`对象被移动到了另一个线程，接收到的信号将被排队到该线程的事件循环中，`consume`槽函数将在那里被调用。





#### 信号槽优势与不足

- 优点： 

- ①类型安全。需要关联的信号槽的签名必须是等同的。即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，编译器会报错。

- ②松散耦合。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是那个对象的那个信号槽接收它发出的信号，它只需在适当的时间发送适当的信号即可，而不需要关心是否被接受和那个对象接受了。Qt就保证了适当的槽得到了调用，即使关联的对象在运行时被删除。程序也不会奔溃。

- ③灵活性。一个信号可以关联多个槽，或多个信号关联同一个槽。


​          

- 不足：速度较慢。与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍。

- 原因：

- ①需要定位接收信号的对象。

- ②安全地遍历所有关联槽。

- ③编组、解组传递参数。

- ④多线程的时候，信号需要排队等待。（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。）









1. - 
























##### 信号和槽的理解

信号和槽机制底层是通过**函数间的相互调用**实现的。**信号函数和槽函数通常位于某个类**

1. **信号 (Signal)**：

   - 是`QObject`类的一个公有成员函数，但你不能直接调用它，也不能实现它。只能使用`emit`关键字发射它。

   - 信号函数用 signals 关键字修饰，槽函数用 public slots、protected slots 或者 private slots 修饰。

   - 当某些事情发生时，例如用户点击了一个按钮，该按钮可以发出一个信号。

   - **信号没有默认的实现，它只是一个函数声明**。实际的功能是由与之连接的槽来实现的。

     

2. **槽 (Slot)**：

   - Qt5 中，槽函数既可以是**普通的全局函数、也可以是类的成员函数、静态成员函数、友元函数、虚函数**，还可以用 lambda 表达式表示。
   - 和信号函数不同，槽函数必须手动定义（实现）。槽函数可以在程序中直接调用，但主要用来响应某个信号。自定义一个槽函数时，需要注意以下几点：
     - 槽函数的返回值必须和信号函数相同，由于信号函数的返回值一定是 void，所以槽函数的返回值也必须为 void；
     - 对于带参的信号函数，槽函数可以选择接收所有参数，则参数的类型、顺序、个数都必须与信号函数相同；也可以选择接收前几个参数，这些参数的类型、顺序都必须与信号函数相同；还可以选择不接受任何参数。
     - 槽函数的参数个数只能比信号函数少，不能比信号函数多；
     - 槽函数的参数不能有默认值。
   - 与普通的C++成员函数相似，但它也是`QObject`类的一个成员函数。
   - **槽可以与一个信号或多个信号连接**，以实现某种功能。
   - 当**关联的信号被发射时，该槽会被自动调用**。
   - 除了与信号连接外，槽也可以像普通的C++函数那样被调用。

3. **连接 (Connect)**：

   - 通过`QObject::connect()`函数可以将特定的信号与特定的槽连接起来。
   - 当发射该信号时，与之连接的所有槽都将被调用。

4. **特点**：

   - **类型安全**：信号和槽的参数类型是确定的，所以在编译时可以进行检查，避免了传统回调可能出现的类型不匹配问题。
   - **松耦合**：发送信号的对象无需知道接收该信号的对象，这意味着代码的耦合度减少，更加模块化。

   

   5.“按钮被按下”这个信号可以用 clicked() 函数表示，“窗口关闭”这个槽可以用 close() 函数表示，信号和槽机制实现“点击按钮会关闭窗口”的功能，其实就是 clicked() 函数调用 close() 函数的效果。

   

   将某个信号函数和某个槽函数关联起来，需要借助 QObject 类提供的 connect() 函数。

   

信号和槽函数代码实现：

**自定义信号函数：**

以定义好的 MySignal 信号为例，修改 MyWidget 类为：

```c++
class MyWidget:public QWidget{
    //Q_OBJECT 是一个宏，添加它才能正常使用 Qt 的信号和槽机制
    Q_OBJECT
//自定义信号函数
signals:
    void MySignal(QString mess);
public:
    void emitSignal(){
        emit MySignal(message);
    }
private:
    QString message;
};
```

我们为 MyWidget 类新增了一个 emitSignal() 方法和一个 message 属性，emitSignal() 方法中的`emit MySignal(message);`语句就表示发射 MySignal 信号。当程序中执行 emitSingal() 函数时，就会发出 MySignal 信号，message 属性的值也会随信号一同发出，对应的槽函数可以接收到 message 的值。

> 对于每一个自定义的信号函数，程序中都应该提供发射该信号的方法（函数），而且这样的方法（函数）可以有多个。



**自定义响应 MySignal 信号的槽函数：**

```c++
class MyWidget:public QWidget{
    //Q_OBJECT 是一个宏，添加它才能正常使用 Qt 的信号和槽机制
    Q_OBJECT
signals:
    void MySignal(QString mess1,QString mess2);
public:
    void emitSignal(){
        emit MySignal(message1,message2);
    }
    //类的成员函数
    void recSlot1(QString mess){
        qDebug() << "执行 recSlot1() 成员函数，输出" << mess;
    }
//指明定义的是槽函数
public slots:
    void recSlot2(QString mess1,QString mess2){
        qDebug() << "执行 recSlot2() 槽函数，输出"<< mess1 << " " << mess2;
    }
public:
    QString message1;
    QString message2;
};
//全局函数
void recSlot3(){
    qDebug() << "执行 recSlot3() 全局函数";
}
```

程序中，重点关注 recSlot1()、recSlot2()、recSlot3() 这 3 个函数：

- recSlot1() 是 MyWidget 类内部的 public 成员函数，可以当做槽函数使用；
- recSlot2() 位于 MyWidget 类的内部，修饰它的关键字是 `public slots`。slots 和 emit 一样，是 Qt 扩展的一个关键字，专门用来修饰槽函数。也就是说，recSlot2() 是 MyWidget 类中的槽函数。
- recSlot3() 是全局函数，可以当做槽函数使用。

>  public 修饰的成员函数可以当做槽函数，为什么还要提供 slots 关键字？Qt4 中的槽函数只能是 slots 修饰的类成员函数，Qt5 中取消了这一限制，但考虑到要兼容旧的 Qt 版本，Qt5 保留了旧版本中 connect() 函数的语法格式，也保留了 slots 关键字。

**自定义信号和槽的完整实例:**

```c++
//main.cpp
#include <QApplication>
#include <QWidget>
#include <QDebug>
class MyWidget:public QWidget{
    //Q_OBJECT 是一个宏，添加它才能正常使用 Qt 的信号和槽机制
    Q_OBJECT
//信号函数
signals:
    void MySignal(QString mess1,QString mess2);
public:
    //发射信号的函数
    void emitSignal(){
        emit MySignal(message1,message2);
    }
    //普通类成员函数
    void recSlot1(QString mess){
        qDebug() << "执行 recSlot1() 成员函数，输出" << mess;
    }
//槽函数
public slots:
    void recSlot2(QString mess1,QString mess2){
        qDebug() << "执行 recSlot2() 槽函数，输出"<< mess1 << " " << mess2;
    }
public:
    QString message1;
    QString message2;
};
//全局函数
void recSlot3(){
    qDebug() << "执行 recSlot3() 全局函数";
}
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    //创建主窗口
    MyWidget mywidget;
    mywidget.message1 = "C语言中文网";
    mywidget.message2 = "http://c.biancheng.net";
    //类的成员函数作为槽函数
    QObject::connect(&mywidget,&MyWidget::MySignal,&mywidget,&MyWidget::recSlot1);
    //信号函数和槽函数相连接
    QObject::connect(&mywidget,&MyWidget::MySignal,&mywidget,&MyWidget::recSlot2);
    //全局函数作为槽函数
    QObject::connect(&mywidget,&MyWidget::MySignal,&recSlot3);
    mywidget.show();
    //发射 Signal 信号
    mywidget.emitSignal();
    return a.exec();
}
//MyWidget类的定义应该放到 .h 文件中，本例中将其写到 main.cpp 中，程序最后需要添加 #include "当前源文件名.moc" 语句，否则无法通过编译。
#include "main.moc"
```

执行程序，会弹出一个 myWidget 空白窗口，同时输出以下信息：

执行 recSlot1() 成员函数，输出 "C语言中文网"
执行 recSlot2() 槽函数，输出 "C语言中文网"  "http://c.biancheng.net"
执行 recSlot3() 全局函数



connect()函数连接信号和槽

connect() 是 QObject 类中的一个静态成员函数，专门用来关联指定的信号函数和槽函数。

Qt4 中的槽函数只能是 slots 修饰的类成员函数，Qt5 中取消了这一限制

**Qt5 版本4：**

connect() 函数最常用的语法格式是：

QObject::connect(const QObject ***sender**, const char ***signal**, const QObject ***receiver**, const char ***method**, Qt::ConnectionType type = Qt::AutoConnection)

各个参数的含义分别是：

- sender：指定信号的**发送者**；
- signal：**指定信号函数**，信号函数必须用 SIGNAL() 宏括起来；
- reveiver：指定**信号的接收者**；
- method：指定**接收信号的槽函数**，槽函数必须用 SLOT() 宏括起来；
- type 用于指定关联方式，默认的关联方式为 Qt::AutoConnection，通常不需要手动设定。

仍以实现“按下按钮后窗口关闭”为例，先创建一个窗口和一个按钮，如下所示：

```
QWidget widget;//定义一个按钮，它位于 widget 窗口中QPushButton But("按钮控件",&widget);
```

信号发送者是 But 按钮对象，要发送的信号是“按钮被点击”，可以用 QPushButton 类提供的 clicked() 信号函数表示；信号的接收者是 widget 主窗口对象，“窗口关闭”作为信号对应的槽，可以用 QWidget 类提供的 close() 函数表示。用 connect() 函数将 But 按钮的 

clicked() 信号函数和 widget 窗口的 close() 槽函数关联起来，实现代码如下：

```
connect(&But, SIGNAL(clicked()), &widget, SLOT(close()));
```

如此就实现了“按下按钮会关闭窗口”的功能。

**Qt5 版本：**

connect() 函数引入了新的用法，常用的语法格式是：

QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection)

和旧版本相比，**新版的 connect() 函数改进了指定信号函数和槽函数的方式**，**不再使用 SIGNAL() 和 SLOT() 宏**。

例如，**用新版 connect() 函数关联 But 按钮的 clicked() 信号函数和 widget 窗口的 close() 槽函数**，实现代码为：

```
connect(&But, &QPushButton::clicked, &widget, &QWidget::close);
```

可以看到，新版 connect() 函数指定信号函数和槽函数的语法格式是`&+函数所在类+函数名`。



一个信号函数关联多个槽函数、多个信号函数关联同一个槽函数

一个 connect() 函数只能关联一个信号函数和一个槽函数，程序中可以包含多个 connect() 函数，能实现以下几种效果：

- 关联多个信号函数和多个槽函数；
- **一个信号函数可以关联多个槽函数**，当信号发出时，与之关联的槽函数会一个接一个地执行，但它们执行的顺序是随机的，无法人为指定哪个先执行、哪个后执行；
- **多个信号函数可以关联同一个槽函数**，无论哪个信号发出，槽函数都会执行。


connect() 函数的 method 参数还可以指定一个信号函数，也就是说，信号之间也可以相互关联，这样当信号发出时，会随之发出另一个信号。



#####  Qt信号槽调用流程

- Qt的信号和槽机制是一种类型安全的回调函数机制，并且可以跨线程进行通信。以下是信号和槽调用流程的简化描述：

  1. **定义信号和槽**:
     - 信号在类的私有部分使用`signals:`关键字定义。
     - 槽可以是公有、私有或受保护的成员函数，使用`slots:`关键字定义。
  2. **连接信号和槽**:
     - 使用`QObject::connect()`函数将信号和槽连接起来。当发射信号时，与之连接的槽将被调用。
  3. **发射信号**:
     - 使用`emit`关键字发射信号。例如: `emit mySignal(myParam);`。
  4. **信号处理**:
     - 当信号被发射时，Qt's meta-object system 捕获这个信号并查找与之连接的所有槽。
     - 对于`Qt::DirectConnection`类型的连接，与信号连接的槽将立即被调用，就像直接调用函数一样。
     - 对于`Qt::QueuedConnection`类型的连接（例如，当信号和槽在不同的线程中时），**信号参数被放入事件循环队列中**，接收线程在其事件循环中取出并调用槽。
  5. **参数传递**:
     - 当信号和槽连接时，可以传递参数。信号和槽的参数必须具有兼容的类型或可转换的类型。信号可以有更多的参数而槽可以有更少的参数。
  6. **断开连接**:
     - 使用`QObject::disconnect()`函数断开信号和槽的连接。

  为了支持信号和槽，Qt使用了一种称为“元对象编译器”(MOC)的特殊预处理步骤。MOC读取包含`Q_OBJECT`宏的类的头文件，并生成附加的C++代码。这些附加的代码包括用于支持信号和槽、Qt属性系统、运行时类型信息以及其他Qt特性的函数和数据。

**信号槽的实现：元对象编译器MOC**

元对象编译器MOC负责解析signals、slot、emit等标准C++不存在的关键字，以及处理Q_OBJECT、Q_PROPERTY、Q_INVOKABLE等相关的宏，生成moc_xxx.cpp的C++文件（使用黑魔法来变现语法糖）。比如信号函数只要声明、不需要自己写实现，就是在这个moc_xxx.cpp文件中自动生成的。

**moc的本质就是反射器**。











上下位机通讯模块

在喷浆机械臂的系统中，上位机（PC或控制器界面）与下位机（机械臂控制系统）之间的CAN通讯通常涉及以下组件：

1. **硬件接口**：上位机需要有一个硬件接口（如USB-CAN适配器或内置的CAN卡）来实现物理层的连接。
2. **驱动程序**：厂家提供的SDK包。操作系统需要识别硬件接口，这通常通过安装适当的驱动程序来实现。
3. **通讯库**：上位机的软件开发中，需要使用特定的库来实现CAN协议的数据发送和接收。

**实现通讯模块**

下面是上位机与下位机通讯模块实现的一般步骤：

**步骤1: 硬件选择与配置**

确保上位机有适合的CAN接口硬件。对于下位机，通常是CAN模块或微控制器内置的CAN接口。

**步骤2: 驱动与库的安装**

- **在上位机上安装CAN接口的驱动程序。**
- **如果是Windows，可能需要一个特定厂商的CAN接口库。**
- 如果是Linux，可以使用SocketCAN。
- 对于Qt应用程序，可以使用`Qt SerialBus`模块，它支持SocketCAN和某些特定的CAN适配器。

**步骤3: 编写CAN到上位机软件**

- 在Qt中，添加`Qt SerialBus`模块到项目中。
- 使用`QCanBus`类来创建CAN设备，并配置比特率和其他必要参数。
- 使用`QCanBusFrame`来构造CAN消息，设置标识符和数据。
- 发送和接收CAN帧，处理接收到的数据。

**步骤4: 编写CAN到下位机软件**

- 配置下位机的CAN接口，设置相应的过滤器和中断（如果有的话）。
- 编写接收中断处理函数，以处理上位机发送的数据。
- 编写发送函数，将下位机的数据如传感器读数发送到上位机。

**步骤5: 编码解码实现**

- 定义数据的封装（编码）和解封装（解码）格式。
- 上位机软件需要包含将数据封装为CAN帧的逻辑。
- 下位机软件需要能够解析来自上位机的CAN帧，并按照定义的格式提取数据。

**示例：Qt 上位机CAN通讯代码**

```c++
#include <QCanBus>
#include <QCanBusFrame>

// 创建CAN设备
QString canInterfaceName = "can0"; // 例子中使用SocketCAN
QCanBusDevice *device = QCanBus::instance()->createDevice("socketcan", canInterfaceName);
device->connectDevice();

// 构建CAN帧
QCanBusFrame frame;
frame.setFrameId(0x123); // CAN标识符
QByteArray payload;
// ... 填充负载数据 ...
frame.setPayload(payload);

// 发送CAN帧
device->writeFrame(frame);

// 接收CAN帧
connect(device, &QCanBusDevice::framesReceived, this, [&]() {
    while (device->framesAvailable()) {
        const QCanBusFrame frame = device->readFrame();
        // ... 处理接收到的帧 ...
    }
});
```

在实现CAN通讯时，需要注意数据的同步性和实时性，确保上位机和下位机能够及时处理数据，并且能够正确地处理错误和异常情况。

对于下位机，如果使用的是通用微控制器，你将需要使用对应的硬件抽象层（HAL）或直接通过寄存器来操作CAN控制器。





在Qt中实现逆运动学：

用Qt创建GUI来接收用户输入的目标位置和姿态信息，展示计算结果，并调用后端逻辑（C++类）来执行运动学计算。

设置一个Qt界面调用逆运动学计算函数：

1. **设计GUI**：使用Qt Designer或代码来创建一个用户界面，该界面包含输入末端执行器位置和姿态的输入框，和一个按钮来触发计算。
2. **编写逆运动学算法类**：创建一个C++类来实现上述逆运动学的算法。
3. **连接GUI和逆运动学算法**：在Qt的槽函数中连接按钮信号和算法类的逆运动学函数。
4. **展示结果**：计算完成后，将结果更新到界面上。

以下是一个示例代码框架，假设你已经有了一个逆运动学的解算函数 `calculateIK`：

```c++
// 1. 创建算法类
class KinematicsSolver {
public:
    QVector<double> calculateIK(const QVector3D& targetPosition, const QQuaternion& targetOrientation) {
        // 你的逆运动学计算逻辑
        QVector<double> jointAngles;
        // ... 计算关节角度 ...
        return jointAngles;
    }
};

// 2. 在你的主窗口类中创建槽函数
class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    MainWindow(QWidget *parent = nullptr) : QMainWindow(parent) {
        // 创建UI组件，设置布局等
        // ...
        connect(calculateButton, &QPushButton::clicked, this, &MainWindow::onCalculateClicked);
    }

public slots:
    void onCalculateClicked() {
        QVector3D targetPosition; // 假设这是从UI获取的
        QQuaternion targetOrientation; // 假设这是从UI获取的
        KinematicsSolver solver;
        QVector<double> jointAngles = solver.calculateIK(targetPosition, targetOrientation);
        // 更新UI展示结果
        // ...
    }
};
```





##### 信号槽的连接方式

（connect的第五个参数）

1. `Qt::AutoConnection自动连接`： 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。
2. `Qt::DirectConnection直接连接`：**单线程用**：槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。在多线程环境下比较危险，可能会造成奔溃。
3. `Qt::QueuedConnection队列连接`：**多线程用**：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
4. `Qt::BlockingQueuedConnection`：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。

##### 信号槽在单、多线程工作

在Qt中，信号和槽机制可以在单线程和多线程环境中工作。信号和槽之间的交互方式依赖于它们所在的线程。

1. **同一线程中的信号和槽**:

   - 当**发送信号的对象和接收槽的对象**都在同一个线程中时，信号槽调用实际上是一个直接的函数调用。这意味着，当你发射一个信号，连接到这个信号的槽会立即执行，就像直接调用那个函数一样。
   - 默认的连接类型是`Qt::DirectConnection`，这意味着在同一个线程中，除非另有说明，否则信号和槽的交互都是同步的。

2. **不同线程中的信号和槽**:

   - 当**发送信号的对象和接收槽的对象**位于不同的线程中时，Qt会自动将连接类型更改为`Qt::QueuedConnection`。这意味着信号的发送实际上是将**消息放入事件队列**中，而**接收线程的事件循环将在某个时刻处理这些消息并执行相应的槽**。
   - 这种异步方式确保了线程安全，因为槽是在其所属的线程的上下文中执行的，而不是在发出信号的线程中。





### Qt多线程之间的通信

1. **信号和槽**:
   - 当一个信号在一个线程中被发射，并且在另一个线程中有一个连接到它的槽，Qt 会自动将其放入接收线程的事件循环中进行处理，确保其线程安全。
   - 这种机制非常方便，因为你不需要明确地使用锁或其他同步原语。
2. **QMutex**:
   - `QMutex` 是互斥锁，它可以确保一次只有一个线程访问特定的代码段或资源。
   - 当多个线程需要访问**共享资源或代码段**时，使用 `QMutex` 可以避免竞态条件。
3. **QWaitCondition**:
   - 这是一个条件变量，它可以使**线程等待某个条件**成立，或者在条件成立时唤醒其他线程。
   - 通常与 `QMutex` 一起使用，以确保线程安全。
4. **QSemaphore**:
   - 信号量是一个计数器，它可以用来控制对资源的访问。例如，如果你有一个有限的资源池，你可以使用 `QSemaphore` 来确保一次只有 N 个线程可以访问资源。











## 硬件和软件

- 硬件包含了工控机、控制器、传感器。
- 软件包含了上位机控制软件和下位机控制程序。

#### **硬件：**

- **工控机**是研华嵌入式工控机ARK-3500，**运动控制器**是三一控制器 SYMC-92X。**编码器**是德国博思特 IXARC 系列。
- **工控机**主要负责**算法的运行并输出轨迹规划**的结果。
- **模块间的主要通信方式是 CAN 总线**，控制器支持 CAN 网络。
- 新增的**硬件模块计算控制指令**，然后发送给原控制器执行。
- **传感器的信号**由新加装的**运动控制器**接收。水平仪可以检测车身的倾斜状态。

![喷浆硬件图](%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86/%E5%9B%BE%E7%89%87/%E5%96%B7%E6%B5%86%E7%A1%AC%E4%BB%B6%E5%9B%BE.png)

#### 软件：

软件系统包含了上位机软件和下位机程序。

- 上位机软件主要负责**轨迹规划**。
- 下位机程序主要负责**运动控制**。

##### **上位机软件功能：**

- **逆运动学模块**：提供**正向运动学计算和逆向运动学解算**。
- **轨迹规划模块**：根据运动路径参数生成一条可执行的轨迹。
- **三维仿真和参数可视化模块**：根据生成的理论轨迹控制虚拟模型运动，也可以在机械臂**运动时根据传感器传回的关节参数实时更新虚拟模型**；同时会**实时显示每个关节当前的变化曲线**和机械臂末端喷头的运动轨迹。
- **坐标系标定模块**：确定隧道坐标系、车辆坐标系、机械手坐标系之间的关系。
- **传感器标定模块**：建立传感器的值和实际关节角度的关系。
- **隧道采样模块**：通过机械臂末端获取采样点，拟合隧道轮廓曲线。
- **通信模块**：建立上位机和下位机之间通信，接收传感器数据和发送目标关节角度。



**上位机软件操作：**

自动控制模式操作流程：

- 开启 CAN->传感器标定->坐标系标定->选择全自动模式->**设置喷浆参数和机械臂的初始关节角**(看面板右侧的关节角值设置)->选择参数设置完成->仿真->启动。

辅助末端模式操作流程：

- 开启CAN->传感器标定->坐标系标定->选择 XYZ 模式->操作遥控器。

















##### 下位机程序功能：

- **传感器数据处理模块**：将传感器传回的数据进行解码。
- **遥控器信号处理模块**：将遥控器的数据进行解码。
- **运动控制模块**：包含**手动、半自动、全自动**三种控制模式；
- 在手动模式下，接收遥控器信号直接转发给原车载控制器。
- 在半自动模式下，**接收遥控器信号并判断运动方向**，再将**方向信号发送给上位机，上位机计算好关节变量后**发送给下位机控制机械臂的运动。
- 全自动模式下，通过**上位机生成运动轨迹后下发给运动控制器**，然后控制机械臂的运动

下位机程序有两部分，一部分是**原车载控制器**的，一部分是**外挂控制器**的；都调成调试模式。

- 工控机监测**外挂控制器的变量信息**，主要包括**操作模式、关节传感器的值、接收的上位机的关节角值**、关节停止运动的变量、（在辅助末端操作模式下，监测各个方向的变量）；
- 另外设置一台笔记本电脑监测原车载控制器的变量，主要是**控制关节的几个变量**。









![软件](%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86/%E5%9B%BE%E7%89%87/%E8%BD%AF%E4%BB%B6.png)

![上位机软件界面](%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86/%E5%9B%BE%E7%89%87/%E4%B8%8A%E4%BD%8D%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%95%8C%E9%9D%A2.png)

上位机软件界面







## **控制软件开发**

逆运动学模块、轨迹规划模块、三维图形仿真模块、通信模块



### 上位机与下位机通信

- 上位机与下位机之间的通讯方式选择了 CAN 总线。工控机和运动控制之间采用 USB 转 CAN 模块。
- CAN 总线是多主机总线。CAN 协议的最大特点之一是取消了传统的站地址编码，而是对通信数据块进行了编码。它使用**平衡发送和差分接收数据收发器**来驱动总线。
- 工业计算机具有 RS232和USB通讯接口，运动控制器支持CAN网络通讯，两者之间没有直接通讯。



上位机（PC或控制器界面）与下位机（机械臂控制系统）之间的CAN通讯通常涉及以下组件：

1. **硬件接口**：上位机需要有一个硬件接口（如USB-CAN适配器或内置的CAN卡）来实现物理层的连接。
2. **驱动程序**：厂家提供的SDK包。操作系统需要识别硬件接口，这通常通过安装适当的驱动程序来实现。
3. **通讯库**：上位机的软件开发中，需要使用特定的库来实现CAN协议的数据发送和接收。

**实现通讯模块**

下面是上位机与下位机通讯模块实现的一般步骤：

**步骤1: 硬件选择与配置**

确保上位机有适合的CAN接口硬件。对于下位机，通常是CAN模块或微控制器内置的CAN接口。

**步骤2: 驱动与库的安装**

- **在上位机上安装CAN接口的驱动程序。**
- **如果是Windows，可能需要一个特定厂商的CAN接口库。**
- 如果是Linux，可以使用SocketCAN。
- 对于Qt应用程序，可以使用`Qt SerialBus`模块，它支持SocketCAN和某些特定的CAN适配器。

**步骤3: 编写CAN到上位机软件**

- 在Qt中，添加`Qt SerialBus`模块到项目中。
- 使用`QCanBus`类来创建CAN设备，并配置比特率和其他必要参数。
- 使用`QCanBusFrame`来构造CAN消息，设置标识符和数据。
- 发送和接收CAN帧，处理接收到的数据。

**步骤4: 编写CAN到下位机软件**

- 配置下位机的CAN接口，设置相应的过滤器和中断（如果有的话）。
- 编写接收中断处理函数，以处理上位机发送的数据。
- 编写发送函数，将下位机的数据如传感器读数发送到上位机。

**步骤5: 编码解码实现**

- 定义数据的封装（编码）和解封装（解码）格式。
- 上位机软件需要包含将数据封装为CAN帧的逻辑。
- 下位机软件需要能够解析来自上位机的CAN帧，并按照定义的格式提取数据。





#### CAN代码

编码通常发生在(传感器数据、遥控器数据)数据发送之前。发送者会根据CAN协议的要求**将数据封装成一个CAN帧**。

软件步骤：

1. 确定需要发送的**（传感器和遥控器）****数据和相应的标识符**。
2. 创建一个**CAN帧结构体并填入数据和控制字段**。
3. 计算并添加CRC。
4. 发送帧到CAN总线。



需要加载相应的**CAN驱动**，并根据你的**CAN设备配置参数**，例如波特率和通道。

##### can发送、接收线程、信号槽函数

```c++
// 初始化 sendMsg 类的一个实例
// 设置CAN通信的参数，初始化相关的数据处理和线程处理对象，并建立这些对象之间的信号和槽连接，
// 以便于处理CAN消息的发送和接收。
// 管理 CAN 通信的发送和接收，并在构造函数中进行了一系列初始化和信号槽的连接操作，
// 以确保 CAN 通信能够正常进行
sendMsg::sendMsg()
{
    // 注册CAN通信相关的自定义类型，以便在Qt的元对象系统中使用，特别是用于信号和槽机制。
    qRegisterMetaType<VCI_CAN_OBJ>("VCI_CAN_OBJ"); // 注册CAN结构体类型VCI_CAN_OBJ
    qRegisterMetaType<PVCI_CAN_OBJ>("PVCI_CAN_OBJ"); // 注册CAN结构体指针类型PVCI_CAN_OBJ
    qRegisterMetaType<CAN_SEND_FRAME_STRUCT>("CAN_SEND_FRAME_STRUCT");
    // 注册CAN发送帧结构体类型CAN_SEND_FRAME_STRUCT

    // 初始化CAN通信的设备参数
    deviceTye = 3; // 设置设备类型
    device = 0; // 设置设备编号
    chanel = 0; // 设置通道编号

    // 用于处理 CAN 消息的数据
    makedata = new makeData; // 创建数据处理对象
    // 发送 CAN 消息的线程对象 、接收 CAN 消息的线程对象
    sendThreadCAN1 = new MyCanThread;
    sendThreadCAN1->moveToThread(&sendThread);
    // 将 发送线程对象移至 新线程 ，以实现异步操作
    // 接收 CAN 消息的线程对象
    processMsg = new MyCanThread_recev;
    processMsg->moveToThread(&processThread);

    // 建立信号和槽之间的连接
    connect(sendThreadCAN1, SIGNAL(my_signal(PVCI_CAN_OBJ,int)), processMsg, SLOT(ReceiveCANThread(PVCI_CAN_OBJ,int)));
    // 当sendThreadCAN1发送线程 发出my_signal时，调用processMsg的ReceiveCANThread的槽函数
    connect(processMsg, SIGNAL(startSendThread()), this, SLOT(transmitSendInfo()));
    // 当processMsg接收线程 发出startSendThread信号时，调用本类的transmitSendInfo槽函数
}




// 设置关节的角度或位置
void sendMsg::setJoints(QVector<int> joints)
//一组整数，表示机械臂的每个关节的角度或位置
{
    this->joints = joints;
    // 更新这些关节值
}

// 设置脉冲宽度调制（PWM）参数
void sendMsg::setPWM(QVector<int> pwm)
// 一组整数，用于控制电机的脉冲宽度调制（PWM）参数
{
    this->pwm = pwm; // 将传入的pwm向量赋值给类的成员变量pwm
}
```



##### 经过CAN总线向下位机发送控制模式信息

```c++
// 向机械臂发送不同控制模式的CAN指令的函数。根据传入的控制模式参数，
// 它构建了不同的CAN数据帧，并通过CAN通信线程发送这些数据帧到机械臂控制器
void sendMsg::sendSelectMode(KinematicsMode mode)
{
    // 定义一个8字节的数组，用于存储要发送的数据
    // 设置CAN消息的标识符（ID为400，十六进制为0x190）
    // 定义一个QString，用于构建要发送的数据字符串
    unsigned char data_from_text[8];
    unsigned int start_id = 400;    
    QString start_char;            

    // 根据传入的模式参数，设置不同的消息内容
    // 自动化模式、XYZ模式、手动模式设置数据
    // 告诉下位机 机械臂的控制模式
    // 将QString中的字符串转换为16进制的数字，
    // 一个包含十六进制数的c风格字符串转换成一组整数，并将这些整数并存储在data_from_text 8字节的数组中
    // 比如通过CAN总线向机械臂发送控制模式指令。
    if(mode == KinematicsMode::Automation)
    {
        std::cout << "Automation" << std::endl; // 打印"Automation"到控制台
        start_char.append("37 01 01 01 01 01 01 38"); // 为自动化模式设置数据
    }
    if(mode == KinematicsMode::XYZ)
    {
        std::cout << "XYZ" << std::endl; // 打印"XYZ"到控制台
        start_char.append("37 02 02 02 02 02 02 38"); // 为XYZ模式设置数据
    }
    if(mode == KinematicsMode::manual)
    {
        std::cout << "manual" << std::endl; // 打印"manual"到控制台
        start_char.append("37 03 03 03 03 03 03 38"); // 为手动模式设置数据
    }

    // 告诉下位机 机械臂的控制模式
    // 将QString中的字符串转换为16进制的数字，
    // 一个包含十六进制数的c风格字符串转换成一组整数，并将这些整数并存储在data_from_text 8字节的数组中
    // 比如通过CAN总线向机械臂发送控制模式指令。
    for(int i = 0; i < 8; i++)
    {
        data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ', i, i).trimmed().toStdString().c_str());
    }

    int count = 2;
    // 发送两次CAN消息
    while(count > 0)
    {
        count--;
        // CAN通信通常需要发送二进制数据，十六进制字符串转换为整数数据发送给机械臂
        sendThreadCAN1->TransmitCANThread(start_id, (unsigned char *)data_from_text);
        // 通过CAN线程发送数据
    }
}
```

##### 传感器状态数据通过can发送线程发到指定的不同的CAN ID设备

```c++
// 构建包含校准数据的 CAN 消息，并将其发送到多个设备上，以执行传感器的校准过程。
// 不同的设备通过不同的 CAN ID 来区分，以接收并处理校准数据
void sendMsg::sensorCalibration(){
    makedata->savepos();
    // 调用makedata对象的savepos方法，保存当前传感器的位置或状态，作为校准前的一个参考点

    unsigned char data_from_text[8];
    // 定义CAN 一个8字节的数组，用于存储将要发送的数据
    // 定义了多个 CAN 消息的标识符（ID），每个标识符用于发送校准数据到不同的设备
    int start_id1 = 1537; // 定义一个CAN消息的标识符（ID为1537，十六进制为0x601）
    int start_id2 = 1538; // 定义另一个CAN消息的标识符（ID为1538）
    int start_id3 = 1539; // 定义另一个CAN消息的标识符（ID为1539）
    int start_id4 = 1540; // 定义另一个CAN消息的标识符（ID为1540）
    int start_id5 = 1541; // 定义另一个CAN消息的标识符（ID为1541）
    int start_id6 = 1542; // 定义另一个CAN消息的标识符（ID为1542）

    // 构建要发送的数据字符串 start_char，这些数据将用于传感器的校准。
    // 这些数据以十六进制格式表示，并被附加到 start_char 中
    QString start_char; // 定义一个QString，用于构建要发送的 数据字符串
    std::cout << "Automation" << std::endl; // 表明进入了自动化校准过程
    start_char.append("40 04 60 00 00 00 00 00"); // 设置用于校准的数据


    // 将十六进制数的字符串格式转换为机器可以直接处理的二进制数据字节数组
    for(int i = 0; i < 8; i++)
    {
        // 十六进制字符串转换为整数
       data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
    }

    // can发送线程 发送 数据到不同的CAN ID
    // 发送数据到ID为1537的设备
    sendThreadCAN1->TransmitCANThread(start_id1,(unsigned char *)data_from_text); // 发送数据到ID为1537的设备
    sendThreadCAN1->TransmitCANThread(start_id2,(unsigned char *)data_from_text); // 发送数据到ID为1538的设备
    sendThreadCAN1->TransmitCANThread(start_id3,(unsigned char *)data_from_text); // 发送数据到ID为1539的设备
    sendThreadCAN1->TransmitCANThread(start_id4,(unsigned char *)data_from_text); // 发送数据到ID为1540的设备
    sendThreadCAN1->TransmitCANThread(start_id5,(unsigned char *)data_from_text); // 发送数据到ID为1541的设备
    sendThreadCAN1->TransmitCANThread(start_id6,(unsigned char *)data_from_text); // 发送数据到ID为1542的设备
}

```

##### 向特定的CAN ID发送一个结束信号

```c++
// 发送一个结束标志信号。
// 向特定的CAN ID发送一个预定义的结束信号。用于机器人控制系统中，以指示某个操作序列的结束，或触发一些清理或重置流程
void sendMsg::sendEndFlag()
{
    QString start_char; 
    // 定义一个QString对象，用于构建要发送的 数据字符串
    // 定义CAN一个8字节的数组，用于存储要发送的数据
    // 设置CAN消息的标识符（ID为45）
    // 设置结束的数据==要发送的结束标志的十六进制表示
    // 十六进制数的字符串格式 转换为 机器可以直接处理的二进制数据字节数组
    // 将 data_from_text 数组中的数据发送到CAN总线上的ID为45的设备
    
    unsigned char data_from_text[8]; // 定义CAN一个8字节的数组，用于存储要发送的数据
    int start_id = 45; // 设置CAN消息的标识符（ID为45）

    start_char.append("37 16 16 16 16 16 16 38"); // 设置 结束的数据==要发送的结束标志的十六进制表示

    // 十六进制数的字符串格式 转换为 机器可以直接处理的二进制数据字节数组
    // 每个十六进制值转换为对应的 字节值
    for(int i = 0; i < 8; i++)
    {
        data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
    }

    int count = 3; // 设置发送次数
    while(count > 0) // 循环发送数据
    {
        count--; // 减少发送次数
        // 将 data_from_text 数组中的数据发送到CAN总线上的ID为45的设备
        sendThreadCAN1->TransmitCANThread(start_id, (unsigned char *)data_from_text);
    }
}
```



##### 启动、接收CAN线程

```c++
// 启动与CAN总线相关的各个线程，包括负责发送和接收数据的线程。
// 停止CAN通信线程，可能用于中断接收CAN总线上的数据。
// 函数发射一个信号，用于通知其他部分开始发送数据
// 返回 CAN通信线程 的当前开启状态，可能用于检查线程是否成功开启
// 返回CAN通信线程的连接状态，用于检查与CAN总线的连接是否正常
void sendMsg::start()
{
    sendThreadCAN1->OpenCANThread(); // 打开CAN通信线程
    sendThreadCAN1->start();         // 启动CAN通信线程
    sendThread.start();              // 启动用于发送数据的线程
    processThread.start();           // 启动用于接收数据的线程
}
// 停止CAN通信线程，可能用于中断接收CAN总线上的数据。
void sendMsg::stopSendAndRecv()
{
    sendThreadCAN1->stop();   // 停止接收CAN信息
}
// 关闭与CAN总线通信相关的所有线程，包括发送和处理数据的线程
void sendMsg::close()
{
    sendThread.quit();            // 退出 发送数据线程
    processThread.quit();         // 退出 接收数据线程
    sendThreadCAN1->stop();       // 停止 CAN通信线程
    sendThreadCAN1->CloseCANThread(); // 关闭 CAN通信线程
}

// 函数发射一个信号，用于通知其他部分开始发送数据
void sendMsg::transmitSendInfo()
{
    emit start_sendMessage();  // 发射 开始发送消息的信号
}

// 返回 CAN通信线程 的当前开启状态，可能用于检查线程是否成功开启
bool sendMsg::getOpenStatus()
{
    return sendThreadCAN1->getOpenStatus(); // 返回CAN通信线程的打开状态
}

// 返回CAN通信线程的连接状态，用于检查与CAN总线的连接是否正常
bool sendMsg::getConnectStatus()
{
    return sendThreadCAN1->getConnectStatus(); // 返回CAN通信线程的连接状态
}
```

##### 发送关节角、PWM数据，告知下位机开始接收数据

```c++
// 发送一个特定的数据帧，告知下位机开始接收数据。
// 遍历不同的关节，为每个关节生成并发送包含关节角度和PWM值的数据，这些数据通过CAN总线发送
// 发送PWM（脉冲宽度调制）数据到CAN（控制器局域网）总线
// 将PWM数据转换为特定格式并通过CAN总线发送
 // 如果上位机接收到下位机的信息，需要发送 下一组关节角数据，则开启线程，启动数据发送

// 定义一个字符串，用于存储ID
// 定义变量存储ID和CAN标识符设备ID
// 定义一个8字节的数组，用于存储要发送的数据
// 定义字符串列表，用于接收数据
// 定义一个QString对象，用于构建要发送的 数据字符串
// 设置开始传输的十六进制数据

 // 当没有发送完计算出的所有关节角组，一直等待发送
 // 先发送一帧数据给下位机，告诉下位机要开始接收数据，38 33 33 33 33 33 33 37
 // 发送数据到CAN总线

 // 定义PWM的ID  脉冲宽度调制
 // ID: 1~6，设置每个关节的ID
 // 增加PWM ID
 // 将关节数据转换为发送CAN帧格式数据 
 // 将PWM数据转换为发送CAN帧格式数据 
 // 16位字符串形式转化为二进制字节数组，发送关节角
 // can发送线程 发送关节角数据到CAN总线
 // 发送 PWM
 // 发送PWM数据到CAN总线 
void sendMsg::sendMessage()
{
    // 采用事件触发机制，而不是盲等
    // 如果上位机接收到下位机的信息，需要发送 下一组关节角数据，则开启线程，启动数据发送

    // 1.写明ID地址    2.制造数据
    // 下位机发送了启动信号,则改变send_flag = true;while send_flag =true {发送数据,改变send_flag=flase,等待下位机通知再次发送}
    // 停止发送按钮也可以直接改变send_flag=false
    QString transmit_str = QStringLiteral("ID:"); // 定义一个字符串，用于存储ID
    unsigned int id = 0, start_id=16; // 定义变量存储ID和CAN标识符设备ID

    unsigned char data_from_text[8]; // 定义一个8字节的数组，用于存储要发送的数据
    QStringList list1; // 定义字符串列表，用于接收数据
    QString start_char; // 定义一个QString对象，用于构建要发送的 数据字符串
    start_char.append("38 33 33 33 33 33 33 37"); // 设置开始传输的十六进制数据

    // 当没有发送完计算出的所有关节角组，一直等待发送
    // 先发送一帧数据给下位机，告诉下位机要开始接收数据，38 33 33 33 33 33 33 37
     for(int i = 0; i < 8; i++)
     {
         data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
     }
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text); // 发送数据到CAN总线

     unsigned int pwm_ID = 10; // 定义PWM的ID  脉冲宽度调制
     for (int i=0; i < 6; i++) {
        id = static_cast<unsigned int>(i + 1);        // ID: 1~6，设置每个关节的ID
        pwm_ID++; // 增加PWM ID
        sendData = makedata->rawData2sendData(joints[i]); // 将关节数据转换为发送数据
        sendData_pwm = makedata->rawData2sendData(pwm[i]); // 将PWM数据转换为发送数据

        // 16位字符串形式转化为二进制字节数组  发送关节角
        for(int j = 0; j < 8; j++)
        {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData.section(' ',j,j).trimmed().toStdString().c_str());
        }
        // can发送线程 发送关节角数据到CAN总线
        sendThreadCAN1->TransmitCANThread(id,(unsigned char *)data_from_text);


        // 发送 PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        // 发送PWM数据到CAN总线
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear(); // 清除发送数据
        sendData_pwm.clear(); // 清除PWM发送数据
    }

}
```

##### =======

##### CAN发送线程

```c++
#include "mycanthread.h"  // 引入自定义的CAN线程类头文件。
#include <QDebug>  // 引入Qt调试输出头文件。

// 初始化CAN线程类的对象，设置了各种成员变量的初始值，
// 并启动了一个定时器用于定时检测连接状态
MyCanThread::MyCanThread():QThread()
{
    stopped = false;  // 控制线程运行的标志，初始为false。
    devtype = 3;  // 设备类型，这里设置为USBCAN1。
    devind = 0;  // 设备索引，通常用于标识多个设备中的一个。
    res = 0;  // 存储结果。
    canind = 0;  // CAN通道索引，指定要操作的CAN通道。
    reftype = 0;  // 参考类型，用于特定的设备设置。
    // bool ok;  // 本地变量，未使用。
    clock = new QTimer;  // 创建计时器对象。
    clock->setInterval(80);  // 定时器对象，被用于定期触发线程内部的操作
    VCI_ERR_INFO vei;  // 存储CAN错误信息。
    VCI_CAN_OBJ preceive[100];  // 存储接收到的CAN消息
    VCI_CAN_OBJ psend;  // 发送CAN消息
    // CAN通信的波特率
    int baud = 0x10000000;  // 设置CAN通信的波特率。
    openSuccess = false;  // 标记CAN设备是否成功打开。
    ConnectError = true;  // 标记是否存在连接错误。
    send_flag = false;  // 标记是否处于发送状态。
    receData = "38 00 00 00 00 00 00 37";  // 设置默认接收数据格式。
    clock->start();  // 启动计时器。

    // 将计时器的timeout信号连接到testConnectStatus槽函数。
    // 计时器的timeout信号连接到testConnectStatus槽函数，
    // 这表示每隔80毫秒就会触发testConnectStatus函数，用于检测连接状态
    connect(clock, SIGNAL(timeout()), this, SLOT(testConnectStatus()));
}

// 线程的主执行函数。
void MyCanThread::run()
{
    while (!stopped)  // 当停止标志为false时，循环执行。
    {
        ReceiveCANThread();  // 调用接收CAN数据的函数。
    }
    stopped = false;  // 循环结束后重置停止标志。
}
// 指定 CAN 设备的类型、设备索引和 CAN 通道索引
MyCanThread::MyCanThread(DWORD devtype, DWORD devind, DWORD canind)
{
    this->devtype = devtype;
    this->devind = devind;
    this->canind = canind;
    this->openSuccess = false;
    this->ConnectError = true;
    this->stopped = false;
}

```

###### 测试CAN连接状态

```c++
// 发送一个简单的 CAN 数据帧来测试 CAN 连接的正常性
void MyCanThread::testConnectStatus()
{
    // 发送 CAN 数据帧
    // 包括帧的 ID、发送类型、远程帧标志、扩展帧标志、数据长度等
    VCI_CAN_OBJ psend;
    ULONG Tr;
    psend.ID = id;         // 帧 ID
    psend.SendType = 0;    // 0 时为正常发送，发送失败会自动重发，重发最长时间为1.5-3秒
    psend.RemoteFlag = 0;  // 是否是远程帧，0 时为数据帧，1 时为远程帧（数据段空）
    psend.ExternFlag = 0;  // 是否是扩展帧，0 时为标准帧（11位ID），1 时为扩展帧（29位ID）
    psend.DataLen = 8;     // 数据的有效字节长度，最大为8个字节
    VCI_ERR_INFO vei;

    // 使用 VCI_Transmit 函数发送数据帧，将数据发送到指定的 CAN 设备和通道
    Tr = VCI_Transmit(devtype, devind, canind, &psend, 1);

    if (Tr != 1) {
        ConnectError = true;
        qDebug() << "发送失败";
    } else {
        qDebug() << "连接正常";
    }

    VCI_CAN_STATUS vcs;
}

void MyCanThread::stop()
{
    stopped = true;
}

```

###### ReceiveCANThread接收线程

```c++
//在线程中接收 CAN 数据帧，并通过信号将接收到的数据传递给其他部分进行处理
void MyCanThread::ReceiveCANThread()
{
    VCI_ERR_INFO vei;//存储 CAN 错误信息
    VCI_CAN_OBJ preceive[1000];//存储接收到的 CAN 数据帧
    ULONG res = 2;//存储接收到的帧数

    // 2
    res = VCI_GetReceiveNum(devtype, devind, canind);

    if (res <= 0) {
        // 未接收到数据或操作失败
        if (VCI_ReadErrInfo(devtype, devind, canind, &vei) != STATUS_ERR) {
            // qDebug() << "未收到下位机数据";
        }
    } else {
        // 接收数据
        // 使用 VCI_Receive 函数从 CAN 设备中接收数据，并将结果存储在 preceive 数组中。
        // 接收时最多接收 100 个数据帧，等待时间为 200 毫秒
        res = VCI_Receive(devtype, devind, canind, preceive, 100, 200);

        if (res == 4294967295) {
            // 接收失败
            if (VCI_ReadErrInfo(devtype, devind, canind, &vei) != STATUS_ERR) {
                qDebug() << "Read Data failed" << "Error Data:" << QString::number(vei.ErrCode, 16);
            }
        } else {
            // 接收成功，发出信号
            // 通过 emit 语句发出 my_signal 信号，
            // 并传递接收到的数据帧数组 preceive 和数据帧数量 res
            emit my_signal(preceive, res);
        }
    }
    // 线程通过 msleep(25) 函数休眠 25 毫秒，等待下一次的数据接收
    msleep(25);
}
```



###### VCI_Transmit函数发送数据

```c++

//在线程中发送 CAN 数据帧，可以将指定的数据通过 CAN 通道发送给外部设备
void MyCanThread::TransmitCANThread(unsigned int id, unsigned char *ch)
{
    VCI_CAN_OBJ psend;//发送的CAN 数据帧
    ULONG Tr;
    // 设置 psend发送对象 中的帧 ID、发送类型、是否远程帧、
    // 是否扩展帧以及数据长度。这些信息是构成 CAN 数据帧的重要参数
    psend.ID = id;         // 帧 ID
    psend.SendType = 0;    // 0 时为正常发送
    psend.RemoteFlag = 0;  // 是否是远程帧
    psend.ExternFlag = 0;  // 是否是扩展帧
    psend.DataLen = 8;     // 数据的有效字节长度，最大为8个字节
    // 将要发送的数据存储在 psend.Data 数组中
    //  ch 是一个长度为 8 的无符号字符数组，表示要发送的数据
    for (int i = 0; i < 8; i++) {
        psend.Data[i] = ch[i];
    }

    // 发送数据
    // 使用 VCI_Transmit 函数发送数据帧。该函数会将 psend 中的数据帧发送到指定的 CAN 通道。
    Tr = VCI_Transmit(devtype, devind, canind, &psend, 1);

    if (Tr == 1) {
        qDebug() << "发送成功";
    }
}
```





##### CAN接收线程

```c++
#include "mycanthread_recev.h"
#include <QDebug>
// 初始化接收 CAN 数据的线程的各项参数和对象。在线程启动后，该线程将监听指定的 CAN 通道，
// 接收来自外部设备的数据，并进行数据解析和处理
// 接收CAN帧数据并解析它们，根据CAN帧的ID执行不同的解析操作，包括角度数据、方向数据和模式选择
MyCanThread_recev::MyCanThread_recev()
{
    stopped = false;
    // 包括设备类型、设备索引、CAN 通道索引、参考参数等。这些参数是用于配置 CAN 接收线程的参数
    devtype = 3;    // 设备类型，这里设置为USBCAN1
    devind = 0;     // 设备索引，通常为0
    res = 0;        // 保留参数，设为0
    canind = 0;     // CAN通道索引，通常为0
    reftype = 0;    // 参考参数，设为0
    send_flag = false; // 发送标志，初始为false
    receData = "38 00 00 00 00 00 00 37";  // 预设接收的数据格式
    makedata = new makeData;  // 创建makeData对象用于数据解析
}
// 接收 CAN 帧数据的解析和处理，根据不同的帧 ID 执行不同的操作，
// 并将解析结果传递给 makedata 对象进行进一步处理
void MyCanThread_recev::ReceiveCANThread(PVCI_CAN_OBJ preceive, int res)
{
    int count = 0;

    // 遍历接收到的CAN帧， 循环迭代处理每一帧
    for (unsigned int i = 0; static_cast<int>(i) < res; i++)
    {
        count += 1;//跟踪接收到的CAN帧数量
        QString receive_str = QStringLiteral("ID:");
        // 将当前接收到的CAN帧的ID附加到 receive_str 字符串中，
        // 然后追加字符串 " Data:" 以表示接下来是CAN帧的数据部分
        //接收到CAN帧时，将ID和数据一起记录下来
        receive_str.append(QString::number(preceive[i].ID));
        receive_str.append("    Data:");

        // 接收到的CAN帧的数据以十六进制形式追加到 receive_str 字符串
        for (int j = 0; j < preceive[i].DataLen; j++)
        {
            receive_str.append(QString::number(preceive[i].Data[j], 16));
            receive_str.append(" ");
        }

        // 根据接收到的CAN帧的ID，将相应的数据解析为十六进制字符串，
        // 并将解析结果传递给 makedata 对象进行进一步处理
        QString decode_rece = "";// 存储解析后的数据
        id = preceive[i].ID;

        // 根据不同的CAN帧ID执行不同的解析操作
        if (id == 0x181 || id == 0x182 || id == 0x183 || id == 0x184 || id == 0x185 || id == 0x186)
        {
            // 遍历CAN帧的数据字节，将每个字节的值转换为十六进制字符串，
            // 并将它们追加到 decode_rece 中，用空格分隔。
            for (int j = 0; j < preceive[i].DataLen; j++)
            {
                decode_rece.append(QString::number(preceive[i].Data[j], 16));
                decode_rece.append(" ");
            }

            // 使用makedata对象进行数据解析，将解析结果存储到合适的位置
            makedata->receData2realData(id, decode_rece);
        }
        else if (id == 0x2A0 || id == 0x3A0)
        {
            // 根据CAN帧ID不同的情况，处理方向数据
            if (id == 0x2A0)
            {
                // 字符串中的第 0 和 1 位置的字符替换为接收到的特定数据字节的十六进制字符串
                direction.replace(0, QString::number(preceive[i].Data[4], 16));
                direction.replace(1, QString::number(preceive[i].Data[6], 16));
            }
            else if (id == 0x3A0)
            {
                //第 2 位置的字符替换为接收到的特定数据字节的十六进制字符串
                direction.replace(2, QString::number(preceive[i].Data[0], 16));
            }

            // 使用makedata对象处理方向数据
            makedata->directionSelect(direction);
        }

        // 根据接收到的CAN帧ID和数据字节来确定模式的选择
        if (id == 0x1A0)
        {
            //接收到的CAN帧数据的第一个字节（preceive[i].Data[0]）转换为十六进制字符串
            if (QString::number(preceive[i].Data[0], 16) == "92")
            {
                mode = 0; // 模式0
            }
            else if (QString::number(preceive[i].Data[0], 16) == "a2")
            {
                mode = 1; // 模式1
            }
        }
    }
}

int MyCanThread_recev::modeselect()
{
    // 返回当前选择的模式
    if (mode == 0)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

```



#### 编码和解码

##### 编码（封装）

编码通常发生在(传感器数据、遥控器数据)数据发送之前。发送者会根据CAN协议的要求**将数据封装成一个CAN帧**。

软件步骤：

1. 确定需要发送的**（传感器和遥控器）****数据和相应的标识符**。
2. 创建一个**CAN帧结构体并填入数据和控制字段**。
3. 计算并添加CRC。
4. 发送帧到CAN总线。

```c++
//构造CANopen帧。
//根据CANopen规范设置帧ID和数据（例如PDO、SDO、心跳等）。
//使用QCanBusDevice的writeFrame方法发送帧。
QCanBusFrame canOpenFrame;
canOpenFrame.setFrameId(CANopenFrameId);  
// 例如PDO的ID
QByteArray payload;  
// 根据CANopen对象字典构造payload
// ... 设置payload为CANopen数据 ...
canOpenFrame.setPayload(payload);
device->writeFrame(canOpenFrame);
```



##### 解码（解封装）

解码则是**接收方对收到的CAN帧**进行解析的过程。

软件解码步骤：

1. 从CAN总线接收数据帧。
2. 检查CRC循环冗余校验以确保数据的完整性。
3. 解析帧结构，**提取标识符和数据**。
4. 根据应用需求处理数据。

```c++
//连接QCanBusDevice的framesReceived信号到一个槽。
//在槽中，使用readFrame读取CAN帧。
//根据CANopen协议解析帧ID和数据。
void MyClass::processReceivedFrames() {
    while (device->framesAvailable()) {
        QCanBusFrame frame = device->readFrame();
        // 解析frame中的ID和数据
        if (isCANopenFrame(frame)) {
            CANopenFrameId id = frame.frameId();
            QByteArray payload = frame.payload();
            // 根据CANopen协议解析payload
            // ...
        }
    }
}
```



#### CAN数据帧格式

一个标准的CAN数据帧包含以下部分：

1. **起始位**（Start of frame）: 1位标志，表示帧的开始。
2. **标识符**（Identifier）: 标准帧是11位，扩展帧是29位，标识符决定了消息的优先级。
3. **远程传输请求**（RTR，Remote Transmission Request）: 1位标志，区分数据帧（0）和远程请求帧（1）。
4. **IDE位**（Identifier Extension）: 1位标志，区分标准帧（0）和扩展帧（1）。
5. **r0位**（Reserved bit）: 保留位，用于将来的扩展。
6. **DLC**（Data Length Code）: 4位标志，指示数据字段的长度，最多为8字节。
7. **数据字段**（Data）: 最长8字节，包含传输的消息。
8. **CRC**（Cyclic Redundancy Check）: 15位CRC序列，用于错误检测。
9. **CRC分隔符**（CRC delimiter）: 1位固定为1的标志。
10. **ACK插槽**（ACK slot）: 发送者保留1位用于接收者发送确认。
11. **ACK分隔符**（ACK delimiter）: 1位固定为1的标志。
12. **结束位**（End of frame）: 7位固定为1的标志，表示帧的结束。

1. 



##### CAN原理 

- CAN 数据链路层采用**短帧结构**，**每帧为 8 字节**；CAN 信息的**每一帧都有CRC 校验**和其他检错措施；它有效地降低了数据的错误率，并且 CAN 节点出现**严重错误**时，它会**自动关闭**，因此使得总线上的其他节点不受影响。
- CAN 可以在**多主机模式**下工作，并且网络上的任何节点都可以随时主动向网络上的其他节点发送信息，而无需考虑主机和从机。当 CAN 总线上的许多节点同时发送信息时，首先发送**高优先级信息**，推迟低优先级信息。
- CAN 总线只定义了物理层和数据链路层，而 **CANopen** 是基于 CAN 总线的应用层协议。在 CANopen 应用层，设备之间通过**交换通信对象**进行通信。



##### CANopen实现

- CANOpen 中的**通信对象是 COB-ID**，COB-ID是一个用于标识CANopen通信对象的标识符，它由一个**11位的标识符**组成，用于**唯一标识网络上的每个CANopen设备**和它们之间的通信对象。COB-ID包括一个**标识符位和一个方向位**，用于指示通信是**从节点发送到节点**（传输方向为0）还是**从节点发送到总线**（传输方向为1）。
- CANOpen 定义了一个强制的默认标识符（CAN-ID）分配表。默认 ID 分配表基于 11 位 CAN-ID，包括 **4 位功能代码部分和 7 位节点 ID（节点 ID）部分**。
- 只有**前面三个PDO**被使用，如表6-1所示。主要用来**传输传感器的数据、遥控器手柄信号、上下位机之间的通信**。

##### PDO和SDO

CANopen 的通信对象类型中有**两个对象用于数据传输**。它们使用两种**不同的数据传输机制**来实现：

- PDO和SDO是两种不同类型的通信对象，用于在CANopen网络中进行数据交换。
  1. **PDO：过程数据对象**
     - PDOs用于实时过程数据的传输。用于传输 **8 字节或更少的数据**，并且没有其他协议预设。
     - 它们是在CANopen网络中**周期性地传输数据**的一种机制，适用于需要**实时更新**的数据，例如传感器数据或执行器状态。
     - PDO的配置是通过**对象字典**中的PDO通信参数对象完成的，其中包括COB-ID等信息。
  2. **SDO：设备数据对象**
     - SDOs用于在设备之间请求和传输服务数据。用于在设备之间传输大的低优先级数据，并且通常用于配置 CANopen 网络上的设备。
     - 它们是一种非周期性的数据传输机制，用于配置、诊断和管理CANopen设备。
     - SDO的传输通常包括读取或写入设备参数的请求和响应。每个SDO传输都与一个唯一的COB-ID相关联。

![can](%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86/%E5%9B%BE%E7%89%87/can.png)



#### **CAN通信搭建方式**

- 工控机和运动控制之间采用 **USB 转 CAN 模块。**USB 转 CAN 模块兼容周立功 API 及 CANTest 软件。**上位机软件开发 CAN 通信采用周立功 API**。上位机的通信功能主要为**编码发送信息和解码接收信息**。
- 接收功能采用 **VCI_Receive** 实现，发送功能采用 **VCI_Transmit** 实现，将数据发送到CAN总线，**周立功 API** 中用于实现CAN数据接收和发送的函数。
- **上位机软件**通过**CAN总线**发送给数据 id 号（0x01-0x06)、8位字节数、关节1-6阀口开度（三种模式信号）、运动控制（模式切换）**给控制器**。
- 上位机通过**CAN总线**收到传感器（0x181-0x186）和控制器数据 id 号、4或8位字节数、关节1-6角度（控制器信号、遥控器按钮、摇杆信号）、类型（传感器1-6数据，遥控器数据）。
- 工控机和外挂控制器的 CAN 通信通道为 1，外挂控制器和原车载控制器的CAN 通信通道为 0，传感器与外挂控制器的通信通道为 0，外挂控制器要接原车载控制器的遥控器信号接收器，原车载控制器不接。



##### CANopen概念、实现步骤

- **对象字典（Object Dictionary）**: CANopen设备中的一个参数表，包含了设备的所有可配置参数和变量。
- **SDO（Service Data Object）**: 用于传输单个对象字典条目的通讯对象。
- **PDO（Process Data Object）**: 用于传输实时过程数据的通讯对象，可以是周期性的也可以是事件驱动的。
- **心跳和节点监控**: 用来监控网络中设备的状态。

实现步骤

**步骤1: 确定硬件和软件需求**

- 确保上位机和下位机硬件都支持CAN接口。
- 选择合适的软件库，比如在上位机可以使用CANopenSocket、CANFestival或者其他支持CANopen协议的库。

**步骤2: 设计对象字典**

- 定义上位机和下位机需要交换的数据，并在对象字典中分配索引和子索引。

**步骤3: 初始化和配置CANopen网络**

- 配置好CAN硬件接口，设置比特率等参数。
- 初始化CANopen栈，包括SDO、PDO、心跳等。
- 设置每个节点的节点ID和通讯参数。

**步骤4: 实现SDO通讯**

- 上位机通过发送SDO请求来读写下位机的对象字典。
- 下位机收到SDO请求后，执行对应的读写操作。

**步骤5: 实现PDO通讯**

- 配置PDO映射和传输参数。
- 上位机和下位机根据PDO配置周期性地发送和接收实时数据。

**步骤6: 实现心跳和错误处理**

- 设置心跳生产者和消费者，以监控网络中的节点状态。
- 实现错误控制逻辑，处理通讯错误和节点状态变化。

**示例代码**

网络管理和具体的CANopen协议栈实现。以下是一个非常高级的伪代码示例，用于说明上位机如何使用CANopen来读取下位机对象字典中的一个参数：

```c++
// 上位机
#include <CANopen.h>
// 初始化CANopen
CANopen_Init(canInterfaceName);
// 读取下位机的对象字典参数
uint32_t objectId = 0x4000; // 对象字典中的索引
uint8_t subIndex = 1;       // 子索引
uint8_t nodeId = 0x01;      // 下位机的节点ID
uint8_t data[4];            // 用于存放读取的数据
size_t size = sizeof(data);
CANopen_ReadSDO(nodeId, objectId, subIndex, data, &size);
```

在下位机上，您需要配置对象字典，实现SDO服务和PDO传输等，下位机的实现将依赖于具体的CANopen协议栈和硬件平台。





#####  CANopen 的PDO

PDO 在 CANopen 通信协议中代表的是过程数据对象（Process Data Object）。它是一种数据对象，用于在 CANopen 网络中的节点之间传输实时数据，比如传感器读数或执行器位置。

PDO 的主要特点包括：

1. **高效性**：PDO被设计为一种非常高效的数据传输方式。一个CAN帧中可以合并多个数据块，从而减少开销，最大化数据吞吐量。
2. **周期性和事件驱动传输**：PDO可以配置为定期传输（周期性）或响应事件（事件驱动）。例如，传感器可能在检测到某个阈值之外的变化时传输其数据。
3. **映射**：PDO内的数据是根据PDO映射参数组织的。这些参数定义了哪些数据（来自对象字典）包括在PDO中，以及它们的顺序。
4. **通信参数**：PDO通信参数定义了PDO如何在网络中传输。这包括PDO是同步传输还是异步传输，传输类型，以及禁止时间。
5. **同步和异步**：PDO可以同步传输，响应总线上的SYNC消息，确保所有节点同时采取行动。它们也可以异步传输，响应内部事件或外部请求。
6. **传输类型**：PDO有多种传输类型，这些类型决定了何时发送PDO，如基于定时器（周期性），远程请求，或事件发生后。
7. **多个PDO**：节点可以使用多个PDO来传输不同类型的数据或优先级。每个PDO在总线上都有一个唯一的标识符。
8. **快速数据交换**：因为PDO可以在没有握手过程的情况下发送，它们适用于快速和频繁的数据交换，这对于实时控制应用是至关重要的。



##### CAN组成、数据传输流程

**CAN节点构成**

- **CAN收发器**: 负责将差分信号转换为TTL电平信号，或者将TTL电平信号转换为差分信号。
- **CAN控制器**: 接收并传输TTL电平信号，与MCU（微控制单元）通信。
- **MCU**: 处理CAN控制器传来的数据，并执行相应的操作。

**数据传输流程**

1. **发送数据**:
   - MCU准备好要发送的数据和标识符，并将其发送到CAN控制器。
   - CAN控制器将数据组成规定的报文格式，并在获得总线访问权限后，通过CAN收发器将报文发送到CAN总线上。
2. **接收数据**:
   - 网络中的所有节点（包括发送节点）都会接收到这个报文。
   - 每个节点的CAN控制器检查报文中的标识符，确定是否需要处理这个报文。
   - 如果报文是发给该节点的，MCU会对数据进行处理。

**项目应用**

1. **传输传感器数据**: 控制器读取关节传感器的数据，并通过CAN总线发送给上位机。上位机接收数据，并对其进行处理。
2. **遥控器手柄信号传输**: 控制器读取遥控器的数据（如按钮状态、摇杆位置等），并通过CAN总线发送给上位机。
3. 上下位机通信
   - 上位机根据需要发送控制命令和配置信息到控制器。
   - 控制器将运行状态、警报和其他反馈信息发送回上位机。

**通信模块的实现**

- **发送接口函数**: 将待发送的CAN消息编码并添加到发送队列中，定时发送到总线上。
- **接收接口函数**: 将接收到的数据放入接收队列中，缓存并按顺序处理接收到的CAN数据帧。







坐标统一

- 坐标装换确定喷浆**车辆相对于隧道的位置**，实现自动轨迹规划。涉及三坐标系：**隧道坐标系、车辆坐标系、机械臂坐标系。**
- 两个依赖坐标转换的功能：**曲线拟合、自动轨迹规划。**



**坐标转换流程：**

- 1.采集机械臂末端的位置点。
- 2.通过**坐标变换转到隧道坐标系**。从机械臂基坐标系转换到车辆坐标系，车辆坐标系转换到隧道坐标系。
- 3.利用这些描述**隧道几何轮廓的点拟合出隧道轮廓线**。
- 4.利用**隧道轮廓线生成一个喷浆轨迹曲面**，计算出喷浆轨迹路径点。
- 5.这些**路径点是在隧道坐标系下**，再转换到**机械臂坐标系**下。



**确定车辆坐标系在隧道坐标系下的位置：**

- 位置包含(X, Y, Z)和(Roll, Pitch, Yaw)。Roll、Pitch 可以通过水平仪获取，Yaw可以通过测量车辆纵轴线与隧道轴线的夹角获取。

### **传感器转换**

- 传感器标定主要确定传感器值和实际关节角度值之间的关系。
- 在标定时，只需将传感器的值和对应的真实关节角度值输入，就可以确定两者之间的关系。机械臂只需要进行一次标定即可，以后重新打开软件时，会默认加载标定好的关系。
- 传感器通过 **CAN** 将信号传给**上位机通讯模块**，处理**传感器数据**并计算出**当前机械臂的位置和姿态**(正运动学模型）。
- 轨迹规划模块规划出理论轨迹，通过**末端期望轨迹**由运动学求解**每个关节的运动量**，通过闭环的**运动控制模块**将**控制信号**发送SYMC 控制器，并**由 A/D 转换为比例阀阀口开度**，实现机械臂各关节运动，实现末端轨迹跟踪。
- 喷浆机械臂采用了**丹弗斯 PVG32 比例阀**，这是一种液压负载比例阀，其主要功能是通过**与负载相关的控制信号**来实现对**执行器的精确控制**。

### **PID跟踪控制**

- 实现自动控制来说，其目标是**控制轨迹的位置和速度**。

- 喷浆机械臂**关节1至关节4由液压缸驱动**，**关节5和关节6由电机驱动**。首先建立单关节的液压控制系统数学模型。

- PID+重力补偿是当前主流机械臂的关节 1-关节 4的控制方案。

- 机械臂的运动过程中存在的抖动会对轨迹跟踪精度产生影响，所以控制系统的误差范围大概是 0-10cm。

  

- **液压缸位置控制系统的工作原理**：运动控制器从**上位机获得理论关节角度**，然后**运动控制器发出 PWM 信号**控制比例阀的开口和方向，从而控制液压缸的运动，机械臂实现关节联动，然后通过关节**传感器获取实际关节角度计算误差**，再通过**控制算法调整 PWM 输出**使得油缸的位置满足误差要求，从而实现对液压缸位置的调节。









### Qt图形界面开发

- Qt 中实现了 OPenGL 的提供的函数接口，以创建具有OpenGL渲染能力的Qt应用程序。
- 使用`QOpenGLWidget`来创建一个**OpenGL渲染窗口**，使用`QOpenGLFunctions`来**调用OpenGL函数**，使用`QOpenGLShader`和`QOpenGLShaderProgram`来**处理着色器**，以及使用`QOpenGLBuffer`来**管理缓冲区对象**。

1. **QOpenGLWidget类：**
   - `QOpenGLWidget`类是Qt部件类，用于在Qt应用程序中**嵌入OpenGL渲染环境**。通过继承`QOpenGLWidget`并重写相关的OpenGL回调函数来实现自定义的OpenGL渲染。
2. **QOpenGLFunctions类：**
   - `QOpenGLFunctions`类是一个用于**封装OpenGL函数的类**。通过继承`QOpenGLFunctions`，在`QOpenGLWidget`中使用OpenGL函数，而不必直接调用OpenGL的C函数。
3. **QOpenGLContext类：**
   - `QOpenGLContext`类表示OpenGL上下文，**封装了与OpenGL相关的状态信息**。您可以使用这个类来管理OpenGL上下文。
4. **QOpenGLShader和QOpenGLShaderProgram类：**
   - 这两个类分别用于处理OpenGL**着色器和着色器程序**。`QOpenGLShader`类用于加载和编译着色器，而`QOpenGLShaderProgram`类用于**链接和管理多个着色器**，创建OpenGL着色器程序。
5. **QOpenGLBuffer类：**
   - `QOpenGLBuffer`类用于创建和管理OpenGL缓冲区对象，这在OpenGL中是**存储顶点数据、颜色数据**等的一种方式。



#### GUI界面

```c++
#include "gui.h"
// gui 类的构造函数
gui::gui(QObject *parent) : QObject(parent)
{
    //创建GUI主窗口和对话框：创建gui类实例
    //在构造函数中创建主窗口（MainWindow）、配置对话框（ConfigDialog）、
    //传感器校准界面（Calibration）、坐标设置对话框（CoordinatesSet）
    //曲线拟合参数设置对话框（curveFitParameterSet）等界面元素。
    mainWindow = new MainWindow;//主窗口
    configDialog = new ConfigDialog;//配置对话框
    sensorCalibration = new Calibration;//传感器校准界面 传感器标定
    coordinatesSet = new CoordinatesSet;//坐标系设置对话框 坐标系标定
    curfitInterface = new curveFitParameterSet;//曲线拟合参数设置对话框 曲线拟合采样

    // 显示主窗口
    mainWindow->show();


// 主窗口的手动模式按钮点击，自动模式按钮，XYZ模式按钮点击的信号发出，连接调用this对象的槽函数
    //将主窗口的各种信号（比如按钮点击、文本改变等事件）与类中的槽函数相连接。
    //当用户与界面交互（按下主窗口的按钮框）时，相应的槽函数会被触发。处理特定的用户界面事件.
    //当用户点击 按钮、选择不同的模式、设置参数、进行传感器校准等等。
    // 可能包括更新界面元素、与底层硬件进行通信、获取数据等。
    // 获取机器坐标、初始参数、传感器数据、设置参数、绘制轨迹等等。
    connect(mainWindow, SIGNAL(ManualModeSelected()), this, SLOT(onManualModeSelected()));
    connect(mainWindow, SIGNAL(AutomationModeSelected()), this, SLOT(onAutomationModeSelected()));
    connect(mainWindow, SIGNAL(XYZModeSelected()), this, SLOT(onXYZModeSelected()));
    connect(mainWindow, SIGNAL(ParaSetRadioClicked()), this, SLOT(onParaSetRadioClicked()));
    connect(mainWindow, SIGNAL(SimulatorButtonClicked()), this, SLOT(onSimulatorButtonClicked()));
    connect(mainWindow, SIGNAL(StartButtonClicked()), this, SLOT(onStartButtonClicked()));
    connect(mainWindow, SIGNAL(StopButtonClicked()), this, SLOT(onStopButtonClicked()));
    connect(mainWindow, SIGNAL(ResetButtonClicked()), this, SLOT(onResetButtonClicked()));
    connect(mainWindow, SIGNAL(CloseButtonClicked()), this, SLOT(onCloseButtonClicked()));
    connect(mainWindow, SIGNAL(RemoteReceiveMachineCoordinates()), this, SLOT(onRemoteControlSelected()));
    connect(mainWindow, SIGNAL(CommunicationFormatClicked()), this, SLOT(onCommunicationFormatClicked()));
    connect(mainWindow, SIGNAL(machineCoordinatesSliderChanged()), this, SLOT(onmachineCoordinatesSliderChanged()));
    connect(mainWindow, SIGNAL(machineCoordinatesTextChanged()), this, SLOT(onmachineCoordinatesTextChanged()));
    connect(mainWindow, SIGNAL(SensorCalibrationClicked()), this, SLOT(onSensorCalibrationClicked()));
    connect(mainWindow, SIGNAL(CoordinateCalibrationClicked()), this, SLOT(onCoordinateCalibration()));
    connect(mainWindow, SIGNAL(StartCANClicked()), this, SLOT(onStartCAN()));
    connect(mainWindow, SIGNAL(CurveFitSampleClicked()), this, SLOT(onCurveFitSample()));
    connect(mainWindow, SIGNAL(endEffectorVelocityChanged()), this, SLOT(onvelocityChanged()));
    connect(configDialog, SIGNAL(setCommunicationFormat()), this, SLOT(onsetCommunicationFormat()));
    connect(coordinatesSet, SIGNAL(setCoordinate()), this, SLOT(onsetCoordinate()));
    connect(sensorCalibration, SIGNAL(sensorCalibration()), this, SLOT(onsensorCalibration()));
    connect(sensorCalibration, SIGNAL(setSensor1_text()), this, SLOT(onsetSensor1_text()));
    connect(sensorCalibration, SIGNAL(setSensor2_text()), this, SLOT(onsetSensor2_text()));
    connect(sensorCalibration, SIGNAL(setSensor3_text()), this, SLOT(onsetSensor3_text()));
    connect(sensorCalibration, SIGNAL(setSensor4_text()), this, SLOT(onsetSensor4_text()));
    connect(sensorCalibration, SIGNAL(setSensor5_text()), this, SLOT(onsetSensor5_text()));
    connect(sensorCalibration, SIGNAL(setSensor6_text()), this, SLOT(onsetSensor6_text()));
    connect(sensorCalibration, SIGNAL(confirmSetS1()), this, SLOT(oncheck_sensor1()));
    connect(sensorCalibration, SIGNAL(confirmSetS2()), this, SLOT(oncheck_sensor2()));
    connect(sensorCalibration, SIGNAL(confirmSetS3()), this, SLOT(oncheck_sensor3()));
    connect(sensorCalibration, SIGNAL(confirmSetS4()), this, SLOT(oncheck_sensor4()));
    connect(sensorCalibration, SIGNAL(confirmSetS5()), this, SLOT(oncheck_sensor5()));
    connect(sensorCalibration, SIGNAL(confirmSetS6()), this, SLOT(oncheck_sensor6()));
    connect(curfitInterface, SIGNAL(setp1_text()), this, SLOT(onsetP1_text()));
    connect(curfitInterface, SIGNAL(setp2_text()), this, SLOT(onsetP2_text()));
    connect(curfitInterface, SIGNAL(setp3_text()), this, SLOT(onsetP3_text()));
    connect(curfitInterface, SIGNAL(setp4_text()), this, SLOT(onsetP4_text()));
    connect(curfitInterface, SIGNAL(setp5_text()), this, SLOT(onsetP5_text()));
    connect(curfitInterface, SIGNAL(setp6_text()), this, SLOT(onsetP6_text()));
    connect(curfitInterface, SIGNAL(setp7_text()), this, SLOT(onsetP7_text()));
    connect(curfitInterface, SIGNAL(setAll()), this, SLOT(onSetAll()));
}

// 获取机器坐标
MachineCoordinates gui::getMachineCoordinates(SingleJointControlMode mode)
{
    return mainWindow->getMachineCoordinates(mode);//从主窗口中获取对应的机器坐标
}

// 获取初始参数
initialpara gui::getinitialpara()
{
    return mainWindow->getinitialpara();
}

// 获取输入的实际关节值  从传感器校准对象中获取用户输入的实际关节值
QVector<double> gui::getInputRealJointValue()
{
    return sensorCalibration->getInputRealJointValue();
}

// 获取传感器值
QVector<double> gui::getSensorValue()
{
    return sensorCalibration->getSensorValue();
}

// 获取Ks
QVector<double> gui::getKs()
{
    return sensorCalibration->getKs();
}

// 设置传感器1的值  将传感器1的值从GUI传递到传感器校准对象中
void gui::setSensor1(double s1)
{
    sensorCalibration->setSonsor1FromGui(s1);
}

// 设置传感器2的值
void gui::setSensor2(double s2)
{
    sensorCalibration->setSonsor2FromGui(s2);
}

// 设置传感器3的值
void gui::setSensor3(double s3)
{
     sensorCalibration->setSonsor3FromGui(s3);
}

// 设置传感器4的值
void gui::setSensor4(double s4)
{
     sensorCalibration->setSonsor4FromGui(s4);
}

// 设置传感器5的值
void gui::setSensor5(double s5)
{
     sensorCalibration->setSonsor5FromGui(s5);
}

// 设置传感器6的值
void gui::setSensor6(double s6)
{
    sensorCalibration->setSonsor6FromGui(s6);
}

// 设置P1点 //曲线拟合对线框架
```

##### 整理函数

```c++

设置CAN开关状态
设置CAN状态
更新机器坐标图
更新机器人可视化
更新路径
绘制理论轨迹
绘制实际轨迹
获取机械臂到车辆的转换矩阵
获取车辆到隧道的转换矩阵
获取末端速度
获取波特率
获取数据位
获取奇偶校验位
获取停止位
当手动模式被选中时的槽函数
当自动模式被选中时的槽函数
当XYZ模式被选中时的槽函数
当参数设置单选按钮被点击时的槽函数
当模拟器按钮被点击时的槽函数
当启动按钮被点击时的槽函数
当停止按钮被点击时的槽函数
当复位按钮被点击时的槽函数
当关闭按钮被点击时的槽函数
当通信格式被点击时的槽函数
当设置通信格式时的槽函数
当传感器校准按钮被点击时的槽函数
当远程控制被选中时的槽函数
当机器坐标滑块改变时的槽函数
当机器坐标文本改变时的槽函数
当传感器校准完成时的槽函数
当坐标校准按钮被点击时的槽函数
当设置坐标时的槽函数
当启动CAN按钮被点击时的槽函数
当曲线拟合示例按钮被点击时的槽函数
当设置传感器1文本时的槽函数
当设置传感器2文本时的槽函数
当设置传感器3文本时的槽函数
当设置传感器4文本时的槽函数
当设置传感器5文本时的槽函数
当设置传感器6文本时的槽函数
当确认设置传感器1时的槽函数
当确认设置传感器2时的槽函数
当确认设置传感器3时的槽函数
当确认设置传感器4时的槽函数
当确认设置传感器5时的槽函数
当确认设置传感器6时的槽函数
当设置P1文本时的槽函数
当设置P2文本时的槽函数
当设置P3文本时的槽函数
当设置P4文本时的槽函数
当设置P5文本时的槽函数
当设置P6文本时的槽函数
当设置P7文本时的槽函数
当设置所有参数时的槽函数
当末端速度改变时的槽函数
模式选择函数
    
    
    
获取机器坐标
获取初始参数
获取输入的实际关节值
获取传感器值
设置传感器1的值
设置传感器2的值
设置传感器3的值
设置传感器4的值
设置传感器5的值
设置传感器6的值
设置P1点
设置P2点
设置P3点
设置P4点
设置P5点
设置P6点
设置P7点
设置机器坐标
设置TCP
设置PST
设置连接状态
设置传感器数据
设置水平仪数据
设置错误信息
```



#### openGL仿真

```c++
#include "glwidget.h"   // 包含 GLWidget 类的头文件。
#include <GL/glu.h>     // 包含 OpenGL 实用库。
#include <QDebug>       // 包含 Qt 调试输出库。

GLWidget::GLWidget(QWidget *parent) : QGLWidget(parent)
{
    // 构造函数，初始化成员变量。
    zoom = 0; // 缩放值初始化为0。
}
// 用于设置OpenGL的各种参数和状态，以便正确渲染图形
void GLWidget::initializeGL()
{
    // 初始化 OpenGL 环境。

    glEnable(GL_DEPTH_TEST); // 启用深度测试，用于3D渲染。
    glClearDepth(1.0); // 设置清除深度值。  表示深度缓冲区的默认值

    glEnable(GL_CULL_FACE); // 启用面剔除，提高性能。因为不可见的三角形将被剔除

    glEnable(GL_POINT_SMOOTH);// 启用点平滑，用于点的渲染。
    glPointSize(10.0);        // 设置点的大小。

    glEnable(GL_BLEND);       // 启用混合，用于透明效果。
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);  // 设置混合函数。

    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);   // 设置多边形平滑提示。
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);// 设置透视矫正提示。

    glEnable(GL_LIGHTING);                  // 启用光照。
    glClearColor(0.3, 0.3, 0.3, 1.0);       // 设置背景颜色。
}







```

##### 绘制3D场景

```c++
// 进行视图变换，最后调用绘制函数来渲染3D场景
void GLWidget::paintGL()
{
    // 绘制OpenGL场景。

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    // 清除颜色缓冲区和深度缓冲区，准备开始渲染新的一帧

    setView();
    // 设置视图矩阵。 以确保场景的正确渲染
    setLight();
    // 设置光照属性。

    glEnable(GL_COLOR_MATERIAL);
    // 启用颜色材质。 用于启用颜色渲染的开关
    glDisable(GL_LIGHTING);
    // 禁用光照以进行颜色渲染。

    glMatrixMode(GL_MODELVIEW);
    // 切换到模型视图矩阵堆栈，接下来的操作将影响模型视图矩阵
    glLoadIdentity();
    // 重置模型视图矩阵。
    glTranslatef(-100.0f, 0.0f, -zoom - 400.0f);  // 进行平移变换，将场景平移到指定位置
    glRotatef(rotationX, 1.0, 0.0, 0.0);     // 绕X轴旋转。
    glRotatef(rotationY + 50.0f, 0.0, 1.0, 0.0);  // 绕Y轴旋转。
    glRotatef(rotationZ, 0.0, 0.0, 1.0);     // 绕Z轴旋转。

    // 调用 robotvisual 对象的一些绘制函数。
    // 未初始化的 robotvisual 对象，需要在构造函数中初始化。
    // robotvisual->drawXYZ();
    // robotvisual->drawPastTCPs();

    glDisable(GL_COLOR_MATERIAL);            // 禁用颜色材质。
    glEnable(GL_LIGHTING);                   // 启用光照。

    // 调用 robotvisual 对象的绘制函数。
    // 未初始化的 robotvisual 对象，需要在构造函数中初始化。
    // robotvisual->draw();
}
```

##### 窗口大小、鼠标按下事件

```c++
//在窗口大小变化时被调用，更新OpenGL视口以适应新的窗口大小，
// 以确保渲染的内容正确呈现在新的窗口中
void GLWidget::resizeGL(int _w, int _h)
{
    // 调整 OpenGL 窗口大小。

    w = _w; h = _h;

    glViewport(0.0, 0.0, w, h);  // 设置视口。以确保OpenGL渲染的内容填满新的窗口区域

    setView();  // 重新设置视图。
}
//处理鼠标按下事件
void GLWidget::mousePressEvent(QMouseEvent *event)
{
    lastPos = event->pos();  // 记录鼠标点击位置。后续计算鼠标拖动的偏移量
}
//处理鼠标移动事件
void GLWidget::mouseMoveEvent(QMouseEvent *event)
{
    // 处理鼠标移动事件，根据鼠标拖动来旋转场景。
    //鼠标在水平和垂直方向上的位移量
    GLfloat dx = GLfloat(event->x() - lastPos.x()) / width();
    GLfloat dy = GLfloat(event->y() - lastPos.y()) / height();
    // 用户按下左鼠标按钮并拖动，它会根据垂直方向的位移量 dy 来更新 rotationX，
    // 根据水平方向的位移量 dx 来更新 rotationY，从而实现绕X轴和Y轴的旋转
    if(event->buttons() & Qt::LeftButton) {
        rotationX += 180 * dy;
        rotationY += 180 * dx;
        updateGL();  // 更新OpenGL场景。
    } else if(event->buttons() & Qt::RightButton) {
        rotationX += 180 * dy;
        rotationZ += 180 * dx;
        updateGL();  // 请求OpenGL重新渲染场景，以反映新的旋转角度
    }
    lastPos = event->pos();  // 更新上一次的鼠标位置。
}
//处理鼠标滚轮事件
void GLWidget::wheelEvent(QWheelEvent *event)
{
    // 处理鼠标滚轮事件，调整缩放值。

    GLfloat roll = event->delta();//检测鼠标滚轮的滚动值
    zoom += roll / 100;//调整缩放值 zoom
    updateGL();  // 更新OpenGL场景。请求OpenGL重新渲染场景，以反映新的缩放值
}
//设置一个距离参数 distance
void GLWidget::setDistance(double _distance)
{
    distance = _distance;
}
```



##### opengl投影矩阵、光照属性

```c++
//设置OpenGL的投影矩阵，定义了透视投影的参数，以便在渲染场景时正确显示物体的透视效果
void GLWidget::setView()
{

    glMatrixMode(GL_PROJECTION);  // 切换到 投影矩阵。
    glLoadIdentity();             // 重置投影矩阵。
    gluPerspective(60.0, 1.0*w/h, 0.1, 10000.0);  // 设置透视投影矩阵。
    // 视野角度60°，宽高比（确保投影不会发生拉伸），近裁剪面距离（任何离视点太近的物体都将被裁剪掉）
    // 远裁剪面距离（任何离视点太远的物体也将被裁剪掉）

    glMatrixMode(GL_MODELVIEW);  // 切换回 模型视图矩阵。
    glLoadIdentity();            // 重置模型视图矩阵。
}
// 设置OpenGL的光照属性，以影响场景中物体的渲染效果
void GLWidget::setLight()
{
    // 设置光照属性。

    GLfloat lamb[] = { 0.1f, 0.1f, 0.1f, 1.0 };
    // 环境光的颜色。深灰色。环境光是无处不在的光，对物体产生均匀的照明效果
    GLfloat ldif[] = { 1.0, 1.0, 1.0, 1.0 };
    // 漫反射光的颜色白色。漫反射光是从光源方向照射到物体表面并以不同程度散射的光
    GLfloat lpos[] = { -10.0, -10.0, 10.0, 1.0 };
    // 光源位置。最后的 1.0 表示光源是一个点光源

    glEnable(GL_COLOR_MATERIAL);  // 启用颜色材质。颜色材质会根据光照效果影响物体的颜色
    glDisable(GL_LIGHTING);       // 禁用光照以绘制光源点。暂时没有光源照射到物体
    glDisable(GL_LIGHT0);         // 禁用光源0。

    glColor4fv(ldif);             // 设置颜色。白色来表示光源的位置
    glBegin(GL_POINTS);           // 开始绘制点。
    glVertex4fv(lpos);            // 指定点的位置。即光源的位置
    glEnd();                       // 结束绘制点。

    glDisable(GL_COLOR_MATERIAL);  // 禁用颜色材质。为了在后续的渲染中使用光照效果
    glEnable(GL_LIGHTING);        // 启用光照。为后续的渲染启用光照效果
    glEnable(GL_LIGHT0);          // 启用光源0。表示光源0现在可用于照明物体

    glLightfv(GL_LIGHT0, GL_POSITION, lpos);   // 设置光源0的位置。
    glLightfv(GL_LIGHT0, GL_AMBIENT, lamb);    // 设置光源0的环境光颜色。
    glLightfv(GL_LIGHT0, GL_DIFFUSE, ldif);    // 设置光源0的漫反射光颜色。
}
```



#### openGL-轨迹规划

```c++
#include "trajectoryDisplayWindow.h"
#include <QCoreApplication>//Qt核心应用程序类的头文件
#include <QTimer>
#include <QDebug>
#include <QPoint>//Qt点类的头文件，用于2D坐标
#include <QWheelEvent>//Qt鼠标滚轮事件类
#include <QOpenGLWindow>
#include <QOpenGLBuffer>
#include <QOpenGLFunctions>//OpenGL功能类
#include <QOpenGLVertexArrayObject>//OpenGL顶点数组对象类
#include <QVector>
#include <QWidget>//Qt的小部件基类
#include <QGLWidget>
#include <GL/glu.h>//OpenGL实用工具库
#include <QHBoxLayout>//水平布局类
#include <windows.h>

using namespace std;










```

##### 视图缩放、旋转角度、窗口大小

```c++
// 视图的缩放、旋转角度
OpenGLWindow::OpenGLWindow(QWidget *parent)
    : QGLWidget(parent)
{
    m_scloe = -30;  // 视图的缩放因子  控制视图的缩放
    m_rotx = 5;     // X轴的旋转角度
    m_roty = 5;     // Y轴的旋转角度
    m_rotz = 5;     // Z轴的旋转角度
    m_count = 0;    // 计数器
    m_isize = 0;    // 大小
    m_anglev = 8;   // 角度
}

OpenGLWindow::~OpenGLWindow()
{
}

void OpenGLWindow::initializeGL()
{
    glClearColor(1, 1, 1, 1.0); // 设置OpenGL清除颜色为白色（即窗口背景颜色为白色）
    glShadeModel(GL_SMOOTH);   // 阴影模式为平滑  表示渲染的图形会使用平滑的着色方式
    glEnable(GL_DEPTH);        // 启用深度测试 处理3D场景中物体深度排序
}
// 处理窗口大小的改变，并更新OpenGL的投影矩阵和视口
void OpenGLWindow::resizeGL(int w, int h)
{
    if (h == 0)//防止height为0
    {
        h = 1;
    }
    glViewport(0, 0, w, h);//重置当前的视口

    glMatrixMode(GL_PROJECTION);//选择投影矩阵模式
    glLoadIdentity();//重置投影矩阵为单位矩阵
    gluPerspective(45.0, w / h, 0.1, 1000.0);//建立透视投影矩阵  参数包括视场角度、宽高比、近裁剪面和远裁剪面的距离设置

    glMatrixMode(GL_MODELVIEW);//选择模型观察矩阵模式
    glLoadIdentity();//重置模型观察矩阵为单位矩阵。这个矩阵通常用于描述相机的位置和方向

}
```



##### 绘制OpenGL场景

```c++
// 绘制OpenGL场景
//清除颜色缓冲区和深度缓冲区，以准备开始绘制新的帧。
//进行视图的缩放和旋转，根据之前在构造函数中设置的缩放因子和旋转角度来调整视图。
//创建一个圆柱体对象 objCylinder 用于绘制轴的箭头。
//接下来，它绘制了三个坐标轴（X、Y、Z轴）以及每个轴上的网格和箭头。
// 最后，它调用了 updateTheroyTraj() 和 updatePracticeTraj() 函数来绘制其他图形或轨迹
void OpenGLWindow::paintGL()
{
    // 清除颜色缓冲区和深度缓冲区
    //qDebug() << "paintGL with t_vetorx.size() = " << t_vetorx.size();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//清除屏幕和深度缓存
    // 重置当前的模型观察矩阵
    glLoadIdentity();//重置当前的模型观察矩阵。在glLoadIdentity()调用之后，函数返回之前，添加代码来创建基本的形
                     //目前所做的就是将屏幕清除成前面所决定的颜色，清除深度缓存并且重置场景，仍然没绘制任何东西。
                     //glPolygonMode(GL_FRONT_AND_BACK ,GL_LINE );
                     //前后面，填充方式（点point、线line、FILL）

    //旋转显示窗口 进行视图的缩放和旋转
    glTranslatef(-1, -4,m_scloe);//平移视图。这行代码将视图沿X轴平移-1个单位，沿Y轴平移-4个单位，以及沿Z轴平移m_scloe个单位
    glRotatef(m_rotx, 1.0, 0.0, 0.0);//绕X轴旋转 m_rotx 度
    glRotatef(m_roty-40, 0.0, 1, 0.0);
    glRotatef(m_rotz-2, 0.0, 0.0, 1);
    // 创建一个圆柱体对象
    GLUquadricObj *objCylinder = gluNewQuadric();

    int pt = 12;//xyz轴的长度 坐标轴的长度
    int num = 12;//控制网格疏密

    //Y轴
    glColor3f(0, 1, 0);//当前绘制颜色  参数 (0, 1, 0) 表示颜色的RGB分量，其中红色分量为0，绿色分量为1，蓝色分量为0
    glLineWidth(5); //设置线段的宽度
    glBegin(GL_LINES);//开始绘制一个图元，这里是线段
        glVertex3f(0,0,0);//线段的起始点坐标
        glVertex3f(pt,0,0);//线段的终点坐标
    glEnd();//结束当前图元的绘制



    //网格
    //Y轴的网格
    //绘制一个包括网格和箭头的三维坐标轴中的Y轴
    glPushMatrix();//将当前的模型视图矩阵推入矩阵堆栈

    glColor3f(0.8, 0.8, 0.8);//当前网格的绘制颜色。这里将颜色设置为浅灰色
    glTranslatef(-m_isize, -m_isize, -m_isize);//平移坐标系
    GLGrid(0, 0, 0, pt, 0, pt, num);//绘制一个三维网格 指定了网格的起点 (0, 0, 0) 和终点 (pt, pt, pt)
    glPopMatrix();//从矩阵堆栈中弹出之前保存的变换状态

    glPushMatrix();//保存下一个部分（绘制Y轴箭头）的变换状态
    glColor3f(0, 1, 0);//颜色设置为绿色
    glTranslatef(pt, -m_isize, -m_isize);//Y轴箭头从原点位置 (0, 0, 0) 平移到 (pt, -m_isize, -m_isize) 处
    glRotatef(90, 0, 1, 0.0);//绕Y轴旋转90度
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);//绘制了一个圆柱体，表示Y轴箭头
    glPopMatrix();//从矩阵堆栈中弹出之前保存的变换状态

 
```





##### 绘制X、Y、Z坐标轴上的字母标签

```c++
/*
 * 调用时只需将下两个接口进行调用，出入具体的嵌套接口即可
*/
    updateTheroyTraj();
    updatePracticeTraj();
}
//绘制X、Y、Z坐标轴上的字母标签
void OpenGLWindow::LabelXYZ()
{
    /*********************X,Y,Z字母***************************************/
        GLfloat size2 = 2.0;
        glLineWidth(size2);

        double a1[3]= {6.5,6.75,7};
        vector<double> n1_vetorx(a1,a1+3);
        double b1[3]= {13.0,13.0,13.0};
        vector<double> n1_vetory(b1,b1+3);
        double c1[3]= {-0.75,-0.5,-0.25};
        vector<double> n1_vetorz(c1,c1+3);
        if (n1_vetorx.size() >= 2) {                              //X
            glBegin(GL_LINE_STRIP);//开始绘制线条，因为字母通常由线条组成
            glTranslatef(-m_isize, -m_isize, -m_isize);//平移坐标系以确定字母位置
            glColor3f(1, 0, 0);//设置字母颜色为红色
            //指定了字母的各个端点
            glVertex3f(n1_vetorx[0], n1_vetorz[0], n1_vetory[0]);
            glVertex3f(n1_vetorx[2], n1_vetorz[2], n1_vetory[2]);
            glVertex3f(n1_vetorx[1], n1_vetorz[1], n1_vetory[1]);
            glVertex3f(n1_vetorx[2], n1_vetorz[0], n1_vetory[0]);
            glVertex3f(n1_vetorx[0], n1_vetorz[2], n1_vetory[0]);

            glEnd();
            glFlush();
        }

        double a2[3]= {12.8,12.65,12.5};
        vector<double> n2_vetorx(a2,a2+3);
        double b2[3]= {6.25,6.25,6.25};
        vector<double> n2_vetory(b2,b2+3);
        double c2[3]= {0.3,0.175,0.0};
        vector<double> n2_vetorz(c2,c2+3);
        if (n2_vetorx.size() >= 2) {                              //Y
            glBegin(GL_LINE_STRIP);
            glTranslatef(-m_isize, -m_isize, -m_isize);
            glColor3f(0, 1, 0);

            glVertex3f(n2_vetorx[0], n2_vetorz[0], n2_vetory[0]);
            glVertex3f(n2_vetorx[1], n2_vetorz[1], n2_vetory[1]);
            glVertex3f(n2_vetorx[1], n2_vetorz[2], n2_vetory[1]);
            glVertex3f(n2_vetorx[1], n2_vetorz[1], n2_vetory[1]);
            glVertex3f(n2_vetorx[2], n2_vetorz[0], n2_vetory[1]);

            glEnd();
            glFlush();
        }

        double a3[3]= {0.0,0.0,0.5};
        vector<double> n3_vetorx(a3,a3+3);
        double b3[3]= {0.0,0.0,0.0};
        vector<double> n3_vetory(b3,b3+3);
        double c3[3]= {12.75,13.00,13.25};
        vector<double> n3_vetorz(c3,c3+3);
        if (n3_vetorx.size() >= 2) {                              //Z
            glBegin(GL_LINE_STRIP);
            glTranslatef(-m_isize, -m_isize, -m_isize);
            glColor3f(0, 0, 1);

            glVertex3f(n3_vetorx[2], n3_vetorz[0], n3_vetory[0]);
            glVertex3f(n3_vetorx[0], n3_vetorz[0], n3_vetory[0]);
            glVertex3f(n3_vetorx[2], n3_vetorz[2], n3_vetory[0]);
            glVertex3f(n3_vetorx[0], n3_vetorz[2], n3_vetory[0]);


            glEnd();
            glFlush();
        }
}
```

##### 鼠标滚轮、按下、移动事件

```c++
//处理鼠标滚轮事件、鼠标按下事件和鼠标移动事件，同时还包括一个用于绘制网格的函数
void OpenGLWindow::wheelEvent(QWheelEvent *event)//处理鼠标滚轮事件
{
    qDebug() << event->delta();

    if (event->delta() < 0) {//检测鼠标滚轮的滚动方向并更新变量
                             //m_scloe 以实现场景的缩放
        m_scloe++;

    } else if (event->delta() > 0) {
        m_scloe--;
    }

    update();
}
//处理鼠标按下事件
void OpenGLWindow::mousePressEvent(QMouseEvent *event)
{
     lastPos = event->pos();//记录了鼠标按下时的位置
}
// 处理鼠标移动事件
// 算了鼠标在水平和垂直方向上的移动距离，
// 并根据鼠标按钮的状态（左按钮或右按钮）来更新
// 旋转角度 m_rotx 和 m_roty 或 m_rotz，从而实现场景的旋转。
void OpenGLWindow::mouseMoveEvent(QMouseEvent *event)
{
    QPoint pos = event->pos();
    //qDebug() << "x: " << pos.x() << "  y:" << pos.y();
    GLfloat dx = GLfloat(event->x() - lastPos.x())/360 ;
    GLfloat dy = GLfloat(event->y() - lastPos.y())/360;
    if(event->buttons() & Qt::LeftButton) {
        m_rotx +=  180 * dy;
        m_roty += 180 * dx;
    } else if(event->buttons() & Qt::RightButton) {
        m_rotx += 180 * dy;
        m_rotz += 180 * dx;
    }
    lastPos = event->pos();
    update();
}
// 绘制三维网格的函数
void OpenGLWindow::GLGrid(float pt1x, float pt1y, float pt1z, float pt2x, float pt2y, float pt2z, int num)

{
    const float _xLen = (pt2x - pt1x) / num;
    const float _yLen = (pt2y - pt1y) / num;
    const float _zLen = (pt2z - pt1z) / num;
    glLineWidth(0.01f);
    glLineStipple(1, 0x0303);//线条样式

    glBegin(GL_LINES);
    glEnable(GL_LINE_SMOOTH);

    int xi = 0;
    int yi = 0;
    int zi = 0;

    //绘制平行于X的直线
    for (zi = 0; zi <= num; zi++) {
        float z = _zLen * zi + pt1z;
        for (yi = 0; yi <= num; yi++) {
            float y = _yLen * yi + pt1y;
            glVertex3f(pt1x, y, z);
            glVertex3f(pt2x, y, z);

        }
    }
    //绘制平行于Y的直线
    for (zi = 0; zi <= num; zi++) {
        float z = _zLen * zi + pt1z;
        for (xi = 0; xi <= num; xi++) {
            float x = _xLen * xi + pt1x;
            glVertex3f(x, pt1y, z);
            glVertex3f(x, pt2y, z);
        }
    }
    //绘制平行于Z的直线
    for (yi = 0; yi <= num; yi++) {
        float y = _yLen * yi + pt1y;
        for (xi = 0; xi <= num; xi++) {
            float x = _xLen * xi + pt1x;
            glVertex3f(x, y, pt1z);
            glVertex3f(x, y, pt2z);
        }
    }
    glEnd();
}

```



##### 绘制理论轨迹和实际轨迹

```c++
// 绘制理论轨迹和实际轨迹
void OpenGLWindow::updateTheroyTraj()
{
//    qDebug() << "patinTheroy";
//    qDebug() << "t_vetorx.size() = " << t_vetorx.size() << endl;
    GLfloat size = 7.0;   //改变理论和实际轨迹的线宽 0.01~10.0
    glLineWidth( size );   // 设置线的宽度
    glBegin(GL_LINE_STRIP);// 开始绘制线条，表示理论轨迹
    glColor3f(0, 0, 1);   // 设置为蓝色
    // 遍历理论轨迹的数据点，将理论轨迹的每个点的坐标（X、Y、Z）传递给 glVertex3f 函数以绘制线段
    // 这些坐标值通过 glVertex3f 函数传递给 OpenGL，表示一个点的位置
    // 通过遍历所有数据点并使用 glVertex3f 函数绘制线段，
    // 从而在OpenGL窗口中显示了理论轨迹的运动路径
    for (int i = 0; i < keypoint->getTheroyTrajectoryX().size(); i++) {
        glVertex3f(keypoint->getTheroyTrajectoryY()[i]+5, keypoint->getTheroyTrajectoryZ()[i]+2, keypoint->getTheroyTrajectoryX()[i]);  //Y  Z  X
    }
    glEnd();//结束绘制
    glFlush();
}
// 绘制实际轨迹
void OpenGLWindow::updatePracticeTraj()
{
//    qDebug() << "patinPractice";
//    qDebug() << "p_vetorx.size() = " << keypoint->getpracticeTrajectoryX().size() << endl;
    GLfloat size = 7.0;   //改变理论和实际轨迹的线宽 0.01~10.0
    // 检查实际轨迹数据点的数量，如果数据点数目大于等于2，才开始绘制
    if (keypoint->getpracticeTrajectoryX().size() >= 2) {
        glLineWidth( size );
        glBegin(GL_LINE_STRIP);
        //glTranslatef(-m_isize, m_isize, -m_isize);
        glColor3f(1, 0, 0);                                     //红色
        // 开始绘制线条，然后遍历实际轨迹的数据点，
        // 将每个点的坐标（X、Y、Z）传递给 glVertex3f 函数以绘制线段。
        for (int i = 0; i < keypoint->getpracticeTrajectoryX().size(); i++) {
            glVertex3f(keypoint->getpracticeTrajectoryY()[i]+5, keypoint->getpracticeTrajectoryZ()[i]+2, keypoint->getpracticeTrajectoryX()[i]);
        }
        glEnd();
        glFlush();
    }
}
```



##### 三维模型导入opengl

- 利用 Solidworks 画出机械臂的三维模型，把机械臂分成几个相对运动的模块输出为零件体。然后将其格式变为 STL，最后把各个模块导入到 Blender 软件中，调整好坐标系的位置同时将模型进行一定比例的缩放，然后输出为 obj 格式。
- 通过在 QT 中使用 OPenGL 的load函数将模型加载进去，过使用 OpenGL 类库中的 glRotatef和 glTranslatef 函数对每个臂架的坐标系位置和方向进行了改变，
- 同时构建好模型参数和自动化轨迹规划好的关节角参数接口，使得两个能够进行有效的数据交换，这样就能实现离线的三维仿真。同时在**机械臂运动时**可以将**传感器采集的数据交给上位机**然后更新虚拟机械臂的运动。这样**三维实时仿真系统可以实时监测**机械臂的运动情况。



控制软件架构

- 中央控制模块主要负责处理来自各个模块的信息，然后正确的给出指令；
- 主界面接受来自用户的输入信息并反馈给中央控制模块。
- 主界面中包含了很多个子界面，子界面通过向主界面返回输入的信息，然后再返回给中央处理模块进行处理。

![控制架构](%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86/%E5%9B%BE%E7%89%87/%E6%8E%A7%E5%88%B6%E6%9E%B6%E6%9E%84.png)



#### **上位机软件界面内容**

- •**CAN通信格式设置：**设置CAN的通信频率、是否接入终端电阻。

- •**启动CAN：**完成CAN的初始化、CAN通信设备信息读取、CAN通信接口启动。

- •**传感器标定：**读入传感器的值和对应真实关节角值，确定传感器值和关节角度的关系。

- •**坐标系标定：**根据测量得出的位置集合关系，确定隧道坐标系、车辆坐标系、机械臂坐标系之间的关系。
- •**机械臂末端位置和姿态：**表示喷浆机械臂在**运动状态时末端**在机械臂坐标系中的位置。
- •**三维图形显示窗口：**展示**仿真效果和实时的机械臂运动状态**。在仿真状态下，会显示仿真下机械臂的运动状态。在控制机械臂运动时，会根据**传感器传回的参数实时更新**机械臂的三维模型状态。
- •**关节曲线显示：**绘制三维模型机械臂的**每个关节角度值的变化曲线**。
- •**运动轨迹显示：**显示**机械臂末端实时运动的轨迹**和自动轨迹规划下的理论喷浆轨迹。
- •**平台控制：**仿真表示生成一条**自动控制轨迹控制仿真图形**的运动，展示轨迹规划的结果，验证其合理性。**启动**表示将控制指令发送给运动控制器。**暂停**表示停止控制指令的发送。**复位**表示机械臂回到喷射起点的位置。关闭表示结束控制指令的发送，并关闭CAN通信。
- •**喷浆参数输入：**喷浆参数确定了**机械臂自动控制下的运动轨迹**。**喷浆宽度**表示沿隧道轴线方向的距离，**喷射高度**表示沿隧道轮廓的弧线方向距离，**步长**表示机械臂每次末端移动的直线距离。**喷射起点**表示机械臂的初始关节位置。



- •**隧道曲线采样拟合：**通过**机械臂获取隧道轮廓的表示点**，然后**生成一条与隧道形状近似的等距曲线**。

- •**控制模式：**表示三种的不同的控制方式。**手动模式**下，通过遥控器控制独立的关节运动。**XYZ模式**下，通过遥控器直接控制机械臂的末端运动，但目前只支持**直线运动**。全自动模式，不需要人工参与，控制软件生成控制指令控制机械臂的运动。

- •**参数设置完成：**选中后读入喷浆参数，并启动平台控制面板。目的是为了操作的安全性。

- •**控制器连接状态：**表示CAN总线的通信状态。**通信正常**则显示正常，指示灯为绿色，**通信故障**或者CAN连接丢失则显示异常，指示灯为红色。

- •**水平仪倾角：**表示车辆的倾斜程度。

- •**关节传感器数据：**关节表示**实时的机械臂关节角度**，误差表示与理论关节角的差值。

- •**单关节控制：**包含**滑动控制、输入数值、遥控器操作**三种单关节控制方式。。

  





Qt界面OpenGL上显示字段UI

1. CAN通信格式设置：

- 使用`QLabel`来显示“CAN通信格式设置”这个标题。
- 使用`QComboBox`或者`QSpinBox`来让用户选择CAN的通信频率。
- 使用`QCheckBox`来让用户选择是否接入终端电阻。
- 使用`QPushButton`提供一个“应用设置”的按钮，点击后将用户的选择应用到系统中。

2. 启动CAN：

- 使用`QPushButton`提供一个“启动CAN”按钮。
- 当用户点击这个按钮时，触发一个槽函数来完成CAN的初始化、CAN通信设备信息读取、CAN通信接口启动的工作。

3. 传感器标定：

- 使用`QLabel`来显示“传感器标定”这个标题。
- 使用`QLineEdit`或者`QLabel`来显示传感器的值。
- 使用`QLineEdit`让用户输入对应的真实关节角值。
- 使用`QPushButton`提供一个“标定”按钮，用于确定传感器值和关节角度的关系。

4. 坐标系标定：

- 使用`QLabel`来显示“坐标系标定”这个标题。
- 提供相应的输入框和按钮，让用户输入测量得出的位置集合，并进行标定。

5. 隧道曲线采样拟合：

- 使用`QLabel`来显示“隧道曲线采样拟合”这个标题。
- 使用`QPushButton`提供一个“采样”按钮，通过机械臂获取隧道轮廓的表示点。
- 使用`QPushButton`提供一个“拟合”按钮，生成一条与隧道形状近似的等距曲线。
- 可以使用`QOpenGLWidget`显示曲线的三维图形。

6. 控制模式：

- 使用`QLabel`来显示“控制模式”这个标题。
- 使用`QRadioButton`或`QComboBox`提供三种不同的控制方式的选择。
- 对于手动模式和XYZ模式，提供相应的控制界面，如使用`QSlider`来控制独立的关节运动，或者提供一个三维的控制杆来控制机械臂的末端运动。



Qt界面代码写

Qt Widgets应用程序的主窗口，并展示了如何连接用户界面元素（如按钮、下拉列表和复选框）到代码逻辑。在`applyCANSettings`和`startCAN`函数中

```c++
#include "mainwindow.h"    // 引入主窗口的头文件
#include "ui_mainwindow.h" // 引入UI的头文件，UI文件是通过Qt Designer生成的
#include <QMessageBox>     // 引入消息框类，用于显示信息
// 主窗口的构造函数
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent) // 初始化QMainWindow
    , ui(new Ui::MainWindow) // 创建UI对象
{
    ui->setupUi(this); // 设置UI，这个函数在ui_mainwindow.h中定义
    
    // 初始化界面
    ui->comboBoxBaudRate->addItem("500 kbps", QVariant(500000)); 
        // 添加波特率选项到下拉列表，并存储对应的值
    ui->comboBoxBaudRate->addItem("250 kbps", QVariant(250000));
        // 添加另一个波特率选项
    ui->checkBoxTerminalResistance->setChecked(true); 
        // 默认勾选终端电阻复选框

    // 连接信号和槽
    connect(ui->pushButtonApplySettings, &QPushButton::clicked, this, &MainWindow::applyCANSettings);
        // 当点击“应用设置”按钮时，调用applyCANSettings函数
    connect(ui->pushButtonStartCAN, &QPushButton::clicked, this, &MainWindow::startCAN);
        // 当点击“启动CAN”按钮时，调用startCAN函数
}

// 主窗口的析构函数
MainWindow::~MainWindow()
{
    delete ui; // 删除UI对象
}

// “应用设置”按钮的槽函数
void MainWindow::applyCANSettings()
{
    int baudRate = ui->comboBoxBaudRate->currentData().toInt(); // 获取选择的波特率
    bool useTerminalResistance = ui->checkBoxTerminalResistance->isChecked(); // 获取终端电阻复选框的状态

    // 在这里添加设置CAN通信格式的代码
    // ...

    // 显示一个消息框，告知用户设置已应用
    QMessageBox::information(this, "Settings Applied", "CAN settings have been applied.");
}

// “启动CAN”按钮的槽函数
void MainWindow::startCAN()
{
    // 在这里添加启动CAN通信的代码
    // ...

    // 显示一个消息框，告知用户CAN通信已启动
    QMessageBox::information(this, "CAN Started", "CAN communication has been started.");
}
```





openGL 可视化界面

Qt提供了**QOpenGLWidget和QOpenGLWindow**等类，用于在Qt应用程序中集成OpenGL渲染。

**用户界面与交互**

1. **控制界面开发**:
   - 使用Qt创建机械臂的操作面板，包括按钮、滑杆等控件，用户可以通过这些控件发送命令到机械臂。
   
2. **实时数据可视化**:
   - 利用OpenGL在Qt中渲染实时的机械臂状态，如位置、速度和喷浆状态，提供直观的反馈。


- **在Qt中实现机械臂的实时运动显示，使用`QOpenGLWidget`来创建一个可以绘制OpenGL图形的窗口部件。**

- **步骤1: 创建一个OpenGL窗口部件**

- 在你的Qt项目中，创建一个新的类继承自`QOpenGLWidget`，并重写其`initializeGL`，`resizeGL`，和`paintGL`方法。

- ```c++
  #include <QOpenGLWidget>
  #include <QOpenGLFunctions>
  class GLWidget : public QOpenGLWidget, protected QOpenGLFunctions
  {
      Q_OBJECT
  public:
      GLWidget(QWidget *parent = nullptr) : QOpenGLWidget(parent) {
          // 初始化代码，如设置定时器来更新画面
      }
  protected:
      void initializeGL() override {
          initializeOpenGLFunctions();
          glClearColor(0.0, 0.0, 0.0, 1.0); 
          // 设置背景色为黑色
          // 其他初始化OpenGL的代码，如设置光照、加载着色器等
      }
      void resizeGL(int w, int h) override {
          // 更新视口大小
          glViewport(0, 0, w, h);
      }
      void paintGL() override {
          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
          // 绘制代码，绘制你的机械臂
      }
  };
  ```

- **步骤2: 添加OpenGL窗口部件到主窗口**

- 在你的主窗口（或者任何其他容器内），创建`GLWidget`的实例并将其作为子部件添加进去。

- ```c++
  // 在主窗口构造函数中
  GLWidget *glWidget = new GLWidget(this);
  setCentralWidget(glWidget); 
  // 如果这是一个 QMainWindow 的派生类
  ```

- **步骤3: 实现绘制机械臂**

- 在`GLWidget`类的`paintGL`方法中，实现绘制机械臂的逻辑。这可能包括加载模型、设置变换矩阵以及绘制各个部分。

- ```c++
  void paintGL() override {
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      
      // 设置摄像机和视角
      // ...
  
      // 画机械臂的各个部分
      // ...
  }
  ```

- **步骤4: 实时更新画面**

- 如果机械臂的动作是动态的，你需要定期更新画面，刷新和主界面刷新50ms更新一次。使用`QTimer`来设置一个更新频率，然后在定时器超时的槽函数中调用`update()`，这会导致`paintGL`被调用。

- ```c++
  // 在GLWidget类中
  QTimer *timer = new QTimer(this);
  connect(timer, SIGNAL(timeout()), this, SLOT(update()));
  timer->start(16); // 大约每秒60帧
  ```

- **步骤5: 响应用户输入或数据**

- 需要响应用户输入或者实时数据来动态地显示机械臂的运动，将这些输入或数据传递到`GLWidget`中，并在绘制代码中使用这些数据来调整机械臂的位置和姿态。

- 注意

- - 不要忘记在你的`.pro`文件中添加对OpenGL模块的支持：

- ```c++
  QT += opengl
  ```

- - 对于更复杂的3D渲染，你可能需要使用OpenGL的高级功能，如顶点和片元着色器，以及模型加载库（如Assimp）来导入和渲染3D模型。
  - 你可能需要实现适当的向量和矩阵操作，Qt提供了`QMatrix4x4`和`QVector3D`类，它们可以帮助你进行这些数学计算。
  - 对于实时动画和交互，可能还需要结合使用`QMouseEvent`和`QKeyEvent`来处理鼠标和键盘事件，以允许用户通过



##### Qt 按钮界面什么设计

**1. 创建新的Qt Widgets应用程序**

Qt Creator创建一个新的Qt Widgets应用程序。

**2. 设计用户界面**

在Qt Creator的“设计”模式下，可以通过拖放来设计用户界面。

- **添加按钮**：在工具箱中找到QPushButton，将其拖到主窗口中。
- **设置按钮属性**：可以在属性编辑器中设置按钮的各种属性，如text属性可以定义按钮上显示的文字。
- **调整按钮大小和位置**：可以通过拖动和调整大小控件来设置按钮的准确位置和大小。

**3. 安排布局**

将按钮放入布局中，确保按钮的大小和位置可以随窗口的变化而动态调整。

- 在设计视图中选择按钮。
- 右键点击并选择“Lay Out”选项，可以选择水平布局、垂直布局或网格布局等。

**4. 编写信号和槽**

按钮界面的核心功能是通过信号和槽机制实现的，你需要为按钮的点击事件编写一个槽函数。

- 在设计视图中右键点击按钮，选择“转到槽”。
- 选择`clicked()`信号，并连接到一个新的槽函数，Qt Creator将会自动为你在代码中生成这个槽函数。

**5. 实现槽函数**

在代码编辑器中，找到自动生成的槽函数，并实现它。比如：

```c++
void MainWindow::on_pushButton_clicked()
{
    // 按钮点击时要执行的代码
    QMessageBox::information(this, "标题", "按钮被点击了!");
}
```

**6. 编译和运行**

点击“运行”按钮来编译和运行你的应用程序。如果一切正常，你将看到按钮按照你设计的布局出现在窗口中，并且点击它会出现一个消息框。



##### 按钮功能在QT实现

1. QPushButton

按钮组件，用它创建一个标准的按钮。

```c++
QPushButton *button = new QPushButton("Button Text", parentWidget);
```

2. Signal and Slot

当**按钮被点击时**，它会发出一个信号（signal），将这个**信号连接到一个槽函数**（slot）上，这个槽函数定义了**按钮被点击后将执行**的操作。

```c++
connect(button, &QPushButton::clicked, this, &MyClass::onButtonClicked);
```

在上面的代码中，`onButtonClicked`是一个成员函数，定义了按钮被点击时的操作。

3. QLayout

布局管理器，用于控制按钮的位置和大小。你可能会将按钮放入一个布局管理器中，以便于更灵活地控制其在界面中的位置。

```c++
QVBoxLayout *layout = new QVBoxLayout;
layout->addWidget(button);
parentWidget->setLayout(layout);
```

4. QSignalMapper (Optional)

- 如果你有**多个按钮需要连接到同一个槽函数**，根据是哪个按钮被点击来采取不同的行动，你可以使用`QSignalMapper`来“映射”信号到槽函数，并传递一个标识符。
- 在这个例子中，当`button1`被点击时，`onButtonClicked`槽函数会被调用，并且传递一个字符串"button1"作为参数。

```c++
QSignalMapper *signalMapper = new QSignalMapper(this);
connect(button1, SIGNAL(clicked()), signalMapper, SLOT(map()));
signalMapper->setMapping(button1, "button1");
connect(signalMapper, SIGNAL(mapped(QString)), this, SLOT(onButtonClicked(QString)));
```

5. QAction (Optional)

`QAction`是一个抽象的用户界面动作，它可以与按钮关联。这是一个可选的组件，当你希望同一个动作能够在多个地方被触发时使用，例如在按钮、菜单项和工具栏按钮之间共享同一个动作。







CAN通信在QT怎么实现

1. **确保你有Qt Serial Bus模块**： 在开始编程之前，你需要确保你的Qt安装包含了Qt Serial Bus模块。如果你使用的是Qt 5.8或更新版本，该模块应该已经包含在内。

2. **添加必要的模块到你的项目文件**： 在你的`.pro`文件中添加以下行以确保Serial Bus模块被包括：

   ```c++
   QT += serialbus
   ```

3. **包含必要的头文件**： 在你的代码中包含QCanBus和其他可能需要的类。

   ```c++
   #include <QCanBus>
   ```

4. **加载并配置CAN插件**： 你需要加载相应的CAN驱动，并根据你的CAN设备配置参数，例如波特率和通道。

   ```c++
   QString errorString;
   QCanBusDevice *device = QCanBus::instance()->createDevice(
       QStringLiteral("socketcan"), QStringLiteral("can0"), &errorString);
   if (!device) {
       // 处理错误情况
   }
   ```

5. **配置设备参数**： 在连接到CAN总线之前，你可以设置一些设备参数，例如波特率、帧ID过滤等。比特率（bit rate）数据传输的速度、

   ```c++
   device->setConfigurationParameter(QCanBusDevice::BitRateKey, QVariant(500000));
   ```

6. **连接到CAN总线**： 在配置好设备后，你可以尝试连接到CAN总线。

   ```c++
   if (!device->connectDevice()) {
       // 处理连接失败
   }
   ```

7. **发送CAN帧**： 创建一个QCanBusFrame对象并设置必要的数据，然后通过CAN设备发送出去。

   ```c++
   QCanBusFrame frame;
   frame.setFrameId(0x123);
   QByteArray payload("Hello CAN");
   frame.setPayload(payload);
   device->writeFrame(frame);
   ```

8. **接收CAN帧**： 为了接收CAN帧，通常需要连接一个槽到QCanBusDevice的`framesReceived`信号。

   ```c++
   connect(device, &QCanBusDevice::framesReceived, this, &MyClass::processReceivedFrames);
   ```

   实现处理函数来读取CAN帧：

   ```c++
   void MyClass::processReceivedFrames() {
       while (device->framesAvailable()) {
           const QCanBusFrame frame = device->readFrame();
           // 处理frame
       }
   }
   ```

9. **处理错误**： 还应该连接到错误信号来处理可能出现的任何CAN通信错误。

   ```c++
   connect(device, &QCanBusDevice::errorOccurred, this, &MyClass::processErrors);
   ```

10. **清理**： 当不再需要CAN通信时，应该适当地关闭并清理设备。

    ```c++
    device->disconnectDevice();
    delete device;
    ```





















经纬恒润：

经纬恒润专注于为汽车、无人运输等领域的客户提供电子产品、研发服务和高级别智能驾驶整体解决方案。技术范围包含智能驾驶、智能座舱、车身、底盘、新能源、人工智能等。





佑驾创新：

基于计算机视觉技术与人工智能算法打造的智能座舱产品，核心功能包括驾驶员监测系统（DMS）、乘客监测系统（OMS）、物体识别与人车交互系统。iCabin特别针对五大应用场景提供“主动式”服务，用户无需给出明确指令，即可“无感”体验先进的智能座舱技术。

无缝入车（支持多角度识别，无需动作配合）

儿童看护（实时情绪检测、危险动作检测、自动紧急报警）

1、协助开发自动驾驶系统相关工具链；
2、协助负责根据产品需求设计、开发和维护，图形化客户端；
3、协助负责产品客户端和主机之间的通信开发。

**道路环境感知**

MINIEYE 自主研发的视觉感知系统，通过对实际路况的分析，能对车辆、行人、车道、信号灯以及交通标志等道路目标和可行驶区域进行精确的检测。 [2] 

**舱内感知**

通过基于神经网络的视觉感知以及多传感器技术，进行眼睑检测、视线追踪、头部姿态识别、肢体检测以及物体检测，智能分析驾乘人员的状态及行为。 [2] 

**多传感器融合**

结合不同传感器的性能特点，通过目标的跟踪、关联及预测等融合方式，为自动驾驶提供更鲁棒的感知结果。

成谷科技：

专注于高速公路自动驾驶、**雷射融合车道天线**、**加油站收费天线**、**汽车电子系列产品**、**前装OBU芯片**、ETC电子不停车收费系统

科曼医疗：

呼吸机，手术灯之类的医疗器械

立芯科技

**什么是EDA**

EDA全称是**Electronic Design Automation**，也就是**电子设计自动化**，是指利用计算机辅助设计（CAD）软件，来完成超大规模集成电路（VLSI）芯片的功能设计、综合、验证、物理设计（包括布局、布线、版图、设计规则检查等）等流程的设计方式。EDA被誉为“芯片之母”，是电子设计的基石产业。

集成电路设计主要分为**模拟电路设计**和**数字电路设计**。我们身处的自然界是一个**模拟信号**的世界。人类感知的声音、图像、温度、压力、运行轨迹以及无法感知但真实存在的电磁波、微波等，都是模拟信号，它反映了我们所处的物理世界。处理模拟信号的芯片称为模拟芯片，它用于产生、放大、滤波、运算、转换、传输或处理模拟信号，如数模/模数转换器芯片、放大器芯片等。

声音、图像等模拟信号经采样量化后即可转换为以0和1表示的**数字信号**。数字信号被存储、处理后就有了丰富多彩的数字世界。处理这些0和1信号的芯片就是数字芯片，如图形处理芯片、微控制器芯片和数字信号处理单元芯片等。

了解

数字电路设计自动化EDA工具软件平台的相关软件开发，参与软件工程系统的设计、开发、测试、优化等过。

立芯软件科技有限公司成立于2020年11月，专注于**集成电路电子设计自动化（EDA）工具的研发工作。立芯以打造数字电路设计可以信赖的工具为宗旨**，致力于国产替代和科技创新，助力中国集成电路产业发展。

​    立芯自成立之初即获得国内知名投资机构和头部企业客户的认可，产品已在客户的多款高性能设计中得到验证，并已开始商用。

​    目前公司已经在上海、北京、福州等地设有分公司及研发中心，并与行业领先企业和国内高校联合承担多项国家重点研发计划。

​    作为技术密集型企业，立芯拥有完全自主研发的技术成果，并已受到国际同行的广泛认可。团队核心技术人员由工业界顶级专家、学术界知名科学家、清华、北大、复旦、交大、UIUC、UCLA、华为天才少年计划人选等尖端人才组成，研发团队硕博人才占比约80%，**曾多次取得中国大陆在国际EDA领域的首次突破。自成立以来，立芯已获得计算机软件著作权32件，申请国家发明专利29件（授权7件）。**





### **机械臂轨迹规划**

人工操控的末端喷嘴运动的轨迹是在线生成的，利用传感器信息和遥控器方向确定出下一个位置点。自动控制的末端喷嘴运动的轨迹是离线生成的，利用数学建模的方式，通过采样拟合出隧道轮廓曲线，然后**通过给定初始参数自动生成喷浆轨迹**。



- 末端喷头需要控制两类参数（位置和姿态）来表示它的空间位姿，对于位置参数需要控制 3 个参数(x,y,z)，对于姿态参数需要控制 2 个参数(Roll,Yaw)。
- **人工操控控制和自动控制喷浆**。人工操控控制和自动控制都需要**上位机软件提供轨迹规划功能**。人工操控控制是一种**在线轨迹生成方式**，而自动控制是**离线轨迹生成**方式。自动控制下的轨迹规划需要依赖隧道的几何轮廓曲线，需要针对不同的隧道生成相应的隧道轮廓曲线。
- **曲线拟合的数学模型**
- 根据分析采用三次多项式描述 Y 值，二次多项式描述 Z 值。
- **曲线拟合的计算**
- 采用 Y 为 3 阶多项式、Z 为 4 阶多项式阐述计算拟合曲线以及法向量
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps6.png)





人工操控末端喷嘴轨迹规划

- 遥控器通过**操作X/Y/Z方向上的摇杆**，发送指令给下位机，**下位机控制移动的速度**，同时**下位机将信息发送给上位机，上位机进行实时的逆运动学解算，然后将控制指令发送给下位机**。当摇杆处于中位时，停止运动。
- 辅助控制下如何生成实时的运动轨迹。辅助控制下的运动轨迹是直线，传感器可以将实时的关节角度传回，上位机通过正向运动学计算出机械臂喷嘴的当前位置，然后判断现在接收的运动方向，从而计算出下一个位置点。



#### 自动控制末端喷嘴轨迹规划

- 上位机先计算出**带有位置和速度的轨迹**，然后开启时钟，将关节位置和速度发送给下位机，下位机进行控制，然后再根据**当前时间取得新的插值点**，再发送位置和速度给下位机。
- 通过人工调整喷浆机械臂指定一个初始位置，然后给定隧道轨迹之间的**间距d 和路径的长度 w** 以及**插值步长**，自动轨迹规划程序就可以生成一条**完整的喷浆轨迹**。
- **机械臂是圆弧运动**时，对应 p1->p2->p3 或者 p4->p5->p6。需要借助**空间圆弧轨迹的规划方法**。



#### 喷嘴运动轨迹的关节空间轨迹规划

##### **关节五次多项式插值**

- 在完成喷嘴在三维坐标系轨迹规划，通过逆运动学求得各关节的变化量，此时需要对关节运动点进行**关节空间的插值规划**。机械臂需要在一定时间内完成从一个位置到另一个位置的移动，因此需要控制其运动速度。
- 为了实现这个目标，机械臂通常会采用**插值算法计算其运动轨迹**。**多项式插值**是一种常用的方法，可以通过**构造一个多项式函数**来**逼近实际的运动轨迹**，从而预测机械臂的位置、速度和加速度等运动状态。
- 多项式插值能够保证插值函数在给定的数据点上完全符合实际的运动轨迹。三次和五次多项式是常用的多项式插值方法。
- 根据**喷嘴末端的位姿运动轨迹**，使用**直线插补**，计算出每个位姿点的各个关节值。得到的**六个关节的逆解数据**，采用**五次多项式插值**方法，将轨迹规划后运动量传递给跟踪控制程序。通过CAN 信号**传输各个关节阀口的开度值**给车载控制器，并使机械臂执行操作，以最终到达轨迹终点。



#### 代码实现

##### 轨迹插补器

```c++
#include "trajectoryinterpolator.h"
#include "RobotAlgorithmModule.h"
// 轨迹插补器类的实现，用于计算和生成机器人的轨迹
trajectoryinterpolator::trajectoryinterpolator(QObject *parent) : QObject(parent)
{

}
//设置插补步长，即每个插补点之间的距离
void trajectoryinterpolator::setStepLength(double step)
{
    this->step = step;
}
// 分别设置起始点和目标点的位置，这些点用 Point 类型表示
void trajectoryinterpolator::setStartPoint(Point p)
{
    currentTCP = p;
}

void trajectoryinterpolator::setFinishPoint(Point p)
{
    desiredTCP = p;
}
// 分别设置起始点和目标点的姿态，这些姿态用 ApproachVector 类型表示
void trajectoryinterpolator::setStartPosture(ApproachVector posture)
{
    currentPST = posture;
}

void trajectoryinterpolator::setFinishPosture(ApproachVector posture)
{
    desiredPST = posture;
}
// 设置时间插补的参数，包括线速度 (v)、半径 (r)、角速度 (w) 和线段数 (n_segment)
void trajectoryinterpolator::setTimeInterPara(double v, double r, double w, double n_segment)
{
    this->v = v;
    this->r = r;
    this->w = w;
    this->n_segment = n_segment;
}
// 这个函数计算两点之间的插补点，通过线段插补来生成轨迹
// 函数首先清空轨迹点的容器
// 使用线段插补方法计算插补点，将插补点添加到轨迹点的容器中
void trajectoryinterpolator::stepInterpolator()
{
    //计算出两点之间的插值点
    trajectoryPoints.clear();
    Point point = currentTCP;
    // 创建 Point 和 ApproachVector 对象来存储当前点的位置和姿态
    // 并将它们添加到轨迹点和姿态点的容器中
    ApproachVector  posture = currentPST;
    trajectoryPoints.append(point);
    trajectoryPointsPostures.append(posture);
    double position[3];
    double p1[6]={0},p2[6]={0};

    // 将起始点和目标点的位置和姿态信息分别存储在数组 p1 和 p2 中
    p1[0] = currentTCP.x;
    p1[1] = currentTCP.y;
    p1[2] = currentTCP.z;
    p1[3] = currentPST.R;
    p1[4] = currentPST.P;
    p1[5] = currentPST.Y;
    p2[0] = desiredTCP.x;
    p2[1] = desiredTCP.y;
    p2[2] = desiredTCP.z;
    p2[3] = desiredPST.R;
    p2[4] = desiredPST.P;
    p2[5] = desiredPST.Y;
    // 将 p1 和 p2 传递给 pt 结构，其中 pt 用于表示线段的参数
    LinePOParam pt;
    InitialLinePOInpParam(p1, p2, &pt);
//    printf("pt.Orient.theta=%f\n",pt.Orient.theta);
    // 计算了角度变化 dtheta，这个角度变化将用于生成插值点
    double dtheta = pt.Orient.theta/(pt.Line.L / step);
    double Ti[4][4];
    double R[3][3],Roll,Pitch,Yaw;
    // 使用 while 循环，不断调用 LinePOInp 函数，生成插值点，直到 pt.InpFlag 变为3
    // 将 Ti 转换为旋转矩阵 R
    // 计算欧拉角（Roll、Pitch、Yaw）
    // 来获取插值点的位置和姿态信息
   while (pt.InpFlag != 3)
   {
        LinePOInp(&pt, step, dtheta, Ti);
        TransToRp(Ti,R,position);//将 Ti 转换为旋转矩阵 R
        RotToRPY(R,&Roll,&Pitch,&Yaw);// 计算欧拉角（Roll、Pitch、Yaw）
        // 来获取插值点的位置和姿态信息
        point.x = position[0];
        point.y = position[1];
        point.z = position[2];
        posture.R = Roll;
        posture.P = Pitch;
        posture.Y = Yaw;
        // 计算得到的插值点的位置和姿态信息添加到轨迹点和姿态点的容器
        trajectoryPoints.append(point);
        trajectoryPointsPostures.append(posture);
   }
}
// 实现了线段插补，可以在起始点和目标点之间生成一系列插值点，用于表示机器人的轨迹。
// 在循环中不断计算插值点，直到满足终止条件


// 计算轨迹的时间插补
void trajectoryinterpolator::timeInterpolator()
{

}
// 这个函数用于计算整个轨迹，首先调用 stepInterpolator() 来生成插补点，
// 然后可以调用 timeInterpolator() 来进行时间插补
void trajectoryinterpolator::calculate()
{
    stepInterpolator();
    //timeInterpolator();
}
// 分别返回轨迹点和姿态点的容器
QVector<Point> trajectoryinterpolator::getTrajectory()
{
    return trajectoryPoints;
}

QVector<ApproachVector> trajectoryinterpolator::getPosture()
{
    return trajectoryPointsPostures;
}
// 清空轨迹点和姿态点的容器，以便重新生成轨迹
void trajectoryinterpolator::clearTrajectory()
{
    trajectoryPoints.clear();
}

void trajectoryinterpolator::clearPosture()
{
    trajectoryPointsPostures.clear();
}

```

##### 轨迹规划

```c++
// 计算和处理轨迹规划中的直线路径和方向（姿态）插补。
// 它们处理从一个点到另一个点的移动，包括位置和姿态的变化，用于生成平滑、连续的运动轨迹。

// 计算两个方向之间方向插值的参数
void InitialOrientInpParam(double Rs[3][3], double Re[3][3], OrientInpParam *Param)
{
    double InvR[3][3]; // 存储逆矩阵的变量
    MatrixCopy((double *)Rs, 3, 3, (double *)Param->Rs); // 复制起始方向矩阵到Param结构体
    MatrixCopy((double *)Re, 3, 3, (double *)Param->Re); // 复制结束方向矩阵到Param结构体
    RotInv(Rs, InvR); // 计算起始方向矩阵 Rs 的逆矩阵
    MatrixMult((double *)InvR, 3, 3, (double *)Re, 3, (double *)Param->R);
    // 计算方向变换矩阵
    RotToAxisAng(Param->R, Param->omg, &Param->theta);
    // 将方向变换矩阵转换为轴角表示
    MatrixCopy((double *)Param->R, 3, 3, (double *)Param->Ri);
    // 方向变换矩阵复制到Param结构体
    Param->thetai = 0.0; // 初始化插值角度为0
    Param->InpFlag = 1; // 设置插值标志为1
    return;
}




// 在每个插补周期计算方向
// 在每个插补周期中计算方向的工作，根据插值角度 thetai 和四元数 q，得到插补后的旋转矩阵 Ri1
void QuaternionOrientInp(OrientInpParam *Param, double dtheta, double Ri1[3][3])
{
    double q[4];    // 定义一个四元数数组
    double R[3][3]; // 定义一个旋转矩阵数组
    Param->InpFlag = 2; // 设置插值标志为2
    Param->thetai = Param->thetai + dtheta; // 累加插值角度 每个插补周期中的角度增量
    if (Param->thetai >= Param->theta)
    {
        Param->thetai  = Param->theta; // 如果超过最终角度，则设置为最终角度
        Param->InpFlag = 3; // 设置插值标志为3  插值已经完成
    }
    // 将轴-角度表示 omg 和当前插值角度 thetai 转换为四元数
    AxisAngToQuaternion(Param->omg, Param->thetai, q); // 将轴角表示转换为四元数
    QuaternionToRot(q, R); // 将四元数转换为旋转矩阵
    MatrixMult((double *)Param->Rs, 3, 3, (double *)R, 3, (double *)Ri1);
    // 计算插补旋转矩阵
    // 将起始方向矩阵 Param->Rs 与插补得到的旋转矩阵 R 相乘，得到插补后的旋转矩阵 Ri1
    MatrixCopy((double *)Ri1, 3, 3, (double *)Param->Ri); // 复制Ri1到Param结构体
    return;
}



// 计算直线路径插补参数
// 初始化直线路径插补参数，包括起始点坐标、结束点坐标、方向向量等，以便后续的插补计算
void InitialLinePathParam(double p1[3], double p2[3], LineInpParam *p)
{
    // 遍历三个维度
    int i;
    for (i=0; i<3; i++)
    {
        p->p1[i] = p1[i]; // 设置起始点坐标
        p->p2[i] = p2[i]; // 设置结束点坐标
        p->pi[i] = p1[i]; // 设置当前插补点坐标
    }
    // 计算直线长度  通过欧几里得距离公式计算起始点和结束点之间的距离
    p->L = sqrt((p2[0] - p1[0])*(p2[0] - p1[0]) + (p2[1] - p1[1])*(p2[1] - p1[1]) + (p2[2] - p1[2])*(p2[2] - p1[2]));

    // 检查直线长度是否小于某个阈值 ，过小则方向向量设置为0
    if (p->L < ZERO_DISTANCE)
    {
        p->t[0] = 0.0;
        p->t[1] = 0.0;
        p->t[2] = 0.0;
    }
    else
    {
        // 计算方向向量
        p->t[0] = (p2[0] - p1[0]) / p->L;
        p->t[1] = (p2[1] - p1[1]) / p->L;
        p->t[2] = (p2[2] - p1[2]) / p->L;
    }
    p->InpFlag = 1; // 设置插值标志为1 表示已经初始化了直线路径插补参数
    p->Li = 0; // 初始化插补长度为0
    return;
}


//直线路径插补相关函
// 在每个插补周期计算直线路径插补坐标
void LinePathInp(LineInpParam *p, double dL, double pi1[3])
{
    p->InpFlag = 2; // 设置插值标志为2 正处于插值过程
    if (p->Li + dL >= p->L) // 当前插补长度加上待插补的长度 dL 大于等于直线的总长度
    {
        // 如果已经达到或超过终点，设置坐标为终点坐标
        pi1[0] = p->p2[0];//将当前插补点坐标设置为终点的 x 坐标
        pi1[1] = p->p2[1];
        pi1[2] = p->p2[2];
        p->Li = p->L; // 设置插补长度为直线的总长度
        p->InpFlag = 3; // 设置插值标志为3 表示已经到达终点
    }
    else if (p->L - p->Li < 2.0 * dL)
    {
        // 如果最后一步距离太小，减半步长
        dL = 0.5 * dL;  //将待插补的长度减半
        // 计算新的插补点坐标的 x 分量，根据当前插补点坐标、方向向量和新的待插补长度
        pi1[0] = p->pi[0] + p->t[0] * dL;
        pi1[1] = p->pi[1] + p->t[1] * dL;
        pi1[2] = p->pi[2] + p->t[2] * dL;
        p->Li = p->Li + dL; // 累加插补长度
    }
    else
    {
        // 正常插补
        pi1[0] = p->pi[0] + p->t[0] * dL;
        pi1[1] = p->pi[1] + p->t[1] * dL;
        pi1[2] = p->pi[2] + p->t[2] * dL;
        p->Li = p->Li + dL; // 累加插补长度
    }

    // 更新当前插补点坐标
    // 将新计算的插补点坐标的 x 分量更新为当前插补点坐标
    p->pi[0] = pi1[0];
    p->pi[1] = pi1[1];
    p->pi[2] = pi1[2];
    return;
}


//将姿态插补和直线路径插补封装在一起

// 计算直线路径和方向插补的参数
void InitialLinePOInpParam(double p1[6], double p2[6], LinePOParam *LPO)
{
    double Rs[3][3]; // 定义起始方向矩阵
    double Re[3][3]; // 定义结束方向矩阵
    RPYToRot(p1[3], p1[4], p1[5], Rs); // 将RPY转换为旋转矩阵
    RPYToRot(p2[3], p2[4], p2[5], Re); // 将RPY转换为旋转矩阵
    InitialLinePathParam(p1, p2, &(LPO->Line)); // 初始化直线路径参数
    InitialOrientInpParam(Rs, Re, &(LPO->Orient)); // 初始化方向插补参数
    RpToTrans(Rs, p1, LPO->Ts); // 将旋转矩阵和位置向量转换为变换矩阵
    RpToTrans(Rs, p1, LPO->Ti); // 将旋转矩阵和位置向量转换为变换矩阵
    RpToTrans(Re, p2, LPO->Te); // 将旋转矩阵和位置向量转换为变换矩阵
    LPO->InpFlag = 1; // 设置插值标志为1
    return;
    }


// 这个函数用于初始化直线路径和方向（姿态）插补的参数。它先将起始和结束点的RPY（Roll, Pitch, Yaw）转换为旋转矩阵，然后初始化直线路径和方向插补的参数。
// 最后，将这些参数转换为变换矩阵，并设置插值标志。

// 计算每个插补周期中的直线路径坐标和方向
void LinePOInp(LinePOParam *LPO, double dL, double dtheta, double Ti[4][4])
{
    double pi[3]; // 存储插补坐标的数组
    double Ri[3][3]; // 存储插补旋转矩阵的数组
    LPO->InpFlag = 2; // 设置插值标志为2  正处于插值过程
    LinePathInp(&LPO->Line, dL, pi); // 进行直线路径插补，计算下一个插补点的坐标
    QuaternionOrientInp(&LPO->Orient, dtheta, Ri);
    // 计算方向的插补，计算下一个插补点的旋转矩阵
    // 如果直线和方向插补都完成，则设置插值标志为3
    if (LPO->Line.InpFlag == 3 && LPO->Orient.InpFlag == 3)
    {
        LPO->InpFlag = 3;
    }
    RpToTrans(Ri, pi, Ti); // 将插补旋转矩阵和坐标转换为变换矩阵
    MatrixCopy((double *)Ti, 4, 4, (double *)LPO->Ti); // 将变换矩阵复制到LPO结构体
    return;
}

// 它首先计算直线路径的插补坐标，然后计算方向的插补旋转矩阵。
// 如果直线和方向插补都完成，就将插值标志设置为3，并将结果转换为变换矩阵。



```



###### 方向姿态插值和轨迹规划

```c++
// 1、计算和处理轨迹规划中的直线路径和方向（姿态）插补。
// 处理从一个点到另一个点的移动，包括位置和姿态的变化，用于生成平滑、连续的运动轨迹。
// 计算两个方向之间方向插值的参数
定义一个用于存储逆矩阵的变量 InvR。
将起始方向矩阵 Rs 复制到OrientInpParam结构体的 Rs 字段中。
将结束方向矩阵 Re 复制到OrientInpParam结构体的 Re 字段中。
计算起始方向矩阵 Rs 的逆矩阵，并将结果存储在 InvR 中。
计算方向变换矩阵，并将结果存储在 OrientInpParam结构体的 R 字段中。
将方向变换矩阵 R 转换为轴角表示，并将轴角表示的角速度存储在 OrientInpParam结构体的 omg 字段中，角度存储在 theta 字段中。
将方向变换矩阵 R 复制到 OrientInpParam 结构体的 Ri 字段中。
初始化插值角度 thetai 为0。
设置插值标志 InpFlag 为1。
void InitialOrientInpParam(double Rs[3][3], double Re[3][3], OrientInpParam *Param)
{
    double InvR[3][3]; // 定义一个用于存储逆矩阵的变量
    MatrixCopy((double *)Rs, 3, 3, (double *)Param->Rs); // 复制起始方向到Param结构体
    MatrixCopy((double *)Re, 3, 3, (double *)Param->Re); // 复制结束方向到Param结构体
    RotInv(Rs, InvR); // 计算Rs的逆矩阵
    MatrixMult((double *)InvR, 3, 3, (double *)Re, 3, (double *)Param->R); // 计算方向变换矩阵
    RotToAxisAng(Param->R, Param->omg, &Param->theta); // 将方向变换矩阵转换为轴角表示
    MatrixCopy((double *)Param->R, 3, 3, (double *)Param->Ri); // 复制R到Param结构体
    Param->thetai = 0.0; // 初始化插值角度为0
    Param->InpFlag = 1; // 设置插值标志为1
    return;
}
```

###### 在每个插补周期计算方向

```c++
// 在每个插补周期计算方向
// 定义一个四元数数组
// 定义一个旋转矩阵数组
// 设置插值标志为2
// 累加插值角度
// 如果超过最终角度，则设置为最终角度
// 设置插值标志为3
// 将轴角表示转换为四元数
// 将四元数转换为旋转矩阵
// 计算插补旋转矩阵
// 复制Ri1到Param结构体
声明了两个数组q和R，用于存储四元数和旋转矩阵。
将插值标志InpFlag设置为2，表示插值正在进行中。
累加插值角度thetai，然后检查是否超过了最终目标角度theta，如果超过了，则将thetai设置为theta，并将插值标志InpFlag设置为3，表示插值已完成。
调用AxisAngToQuaternion函数，将轴角表示(omg和thetai)转换为四元数，并将结果存储在数组q中。
调用QuaternionToRot函数，将四元数转换为旋转矩阵，并将结果存储在数组R中。
调用MatrixMult函数，将Param结构体中的旋转矩阵Rs与新计算的旋转矩阵R相乘，得到插补后的旋转矩阵Ri1。
最后，将新计算的旋转矩阵Ri1复制到Param结构体的Ri字段中。
void QuaternionOrientInp(OrientInpParam *Param, double dtheta, double Ri1[3][3])
{
    double q[4]; // 定义一个四元数数组
    double R[3][3]; // 定义一个旋转矩阵数组
    Param->InpFlag = 2; // 设置插值标志为2
    Param->thetai = Param->thetai + dtheta; // 累加插值角度
    if (Param->thetai >= Param->theta)
    {
        Param->thetai  = Param->theta; // 如果超过最终角度，则设置为最终角度
        Param->InpFlag = 3; // 设置插值标志为3
    }
    AxisAngToQuaternion(Param->omg, Param->thetai, q); // 将轴角表示转换为四元数
    QuaternionToRot(q, R); // 将四元数转换为旋转矩阵
    MatrixMult((double *)Param->Rs, 3, 3, (double *)R, 3, (double *)Ri1); // 计算插补旋转矩阵
    MatrixCopy((double *)Ri1, 3, 3, (double *)Param->Ri); // 复制Ri1到Param结构体
    return;
}
```

###### 计算直线路径插补的参数

```c++
// 计算直线路径插补的参数
void InitialLinePathParam(double p1[3], double p2[3], LineInpParam *p)
{
    int i;
    for (i=0; i<3; i++)
    {
        p->p1[i] = p1[i]; // 设置起始点坐标
        p->p2[i] = p2[i]; // 设置结束点坐标
        p->pi[i] = p1[i]; // 设置当前插补点坐标
    }
    // 计算直线长度
    p->L = sqrt((p2[0] - p1[0])*(p2[0] - p1[0]) + (p2[1] - p1[1])*(p2[1] - p1[1]) + (p2[2] - p1[2])*(p2[2] - p1[2]));

    // 判断直线长度是否过小，过小则方向向量设置为0
    if (p->L < ZERO_DISTANCE)
    {
        p->t[0] = 0.0;
        p->t[1] = 0.0;
        p->t[2] = 0.0;
    }
    else
    {
        // 计算方向向量
        p->t[0] = (p2[0] - p1[0]) / p->L;
        p->t[1] = (p2[1] - p1[1]) / p->L;
        p->t[2] = (p2[2] - p1[2]) / p->L;
    }
    p->InpFlag = 1; // 设置插值标志为1
    p->Li = 0; // 初始化插补长度为0
    return;
}
```

###### 在每个插补周期计算直线路径插补坐标

```
将姿态插补和直线路径插补封装在一起
```

```c++
// 在每个插补周期计算直线路径插补坐标
void LinePathInp(LineInpParam *p, double dL, double pi1[3])
{
    p->InpFlag = 2; // 设置插值标志为2
    if (p->Li + dL >= p->L)
    {
        // 如果已经达到或超过终点，设置坐标为终点坐标
        pi1[0] = p->p2[0];
        pi1[1] = p->p2[1];
        pi1[2] = p->p2[2];
        p->Li = p->L; // 设置插补长度为直线长度
        p->InpFlag = 3; // 设置插值标志为3
    }
    else if (p->L - p->Li < 2.0 * dL)
    {
        // 如果最后一步距离太小，减半步长
        dL = 0.5 * dL;
        pi1[0] = p->pi[0] + p->t[0] * dL;
        pi1[1] = p->pi[1] + p->t[1] * dL;
        pi1[2] = p->pi[2] + p->t[2] * dL;
        p->Li = p->Li + dL; // 累加插补长度
    }
    else
    {
        // 正常插补
        pi1[0] = p->pi[0] + p->t[0] * dL;
        pi1[1] = p->pi[1] + p->t[1] * dL;
        pi1[2] = p->pi[2] + p->t[2] * dL;
        p->Li = p->Li + dL; // 累加插补长度
    }

    // 更新当前插补点坐标
    p->pi[0] = pi1[0];
    p->pi[1] = pi1[1];
    p->pi[2] = pi1[2];
    return;
}
```

###### 计算直线路径和方向插补的参数

```c++
// 计算直线路径和方向插补的参数
void InitialLinePOInpParam(double p1[6], double p2[6], LinePOParam *LPO)
{
    double Rs[3][3]; // 定义起始方向矩阵
    double Re[3][3]; // 定义结束方向矩阵
    RPYToRot(p1[3], p1[4], p1[5], Rs); // 将RPY转换为旋转矩阵
    RPYToRot(p2[3], p2[4], p2[5], Re); // 将RPY转换为旋转矩阵
    InitialLinePathParam(p1, p2, &(LPO->Line)); // 初始化直线路径参数
    InitialOrientInpParam(Rs, Re, &(LPO->Orient)); // 初始化方向插补参数
    RpToTrans(Rs, p1, LPO->Ts); // 将旋转矩阵和位置向量转换为变换矩阵
    RpToTrans(Rs, p1, LPO->Ti); // 将旋转矩阵和位置向量转换为变换矩阵
    RpToTrans(Re, p2, LPO->Te); // 将旋转矩阵和位置向量转换为变换矩阵
    LPO->InpFlag = 1; // 设置插值标志为1
    return;
    }
```

###### 计算每个插补周期中的直线路径坐标和方向

```c++
// 这个函数用于初始化直线路径和方向（姿态）插补的参数。它先将起始和结束点的RPY（Roll, Pitch, Yaw）转换为旋转矩阵，然后初始化直线路径和方向插补的参数。
// 最后，将这些参数转换为变换矩阵，并设置插值标志。

// 计算每个插补周期中的直线路径坐标和方向
void LinePOInp(LinePOParam *LPO, double dL, double dtheta, double Ti[4][4])
{
    double pi[3]; // 定义用于存储插补坐标的数组
    double Ri[3][3]; // 定义用于存储插补旋转矩阵的数组
    LPO->InpFlag = 2; // 设置插值标志为2
    LinePathInp(&LPO->Line, dL, pi); // 计算直线路径插补坐标
    QuaternionOrientInp(&LPO->Orient, dtheta, Ri); // 计算方向插补旋转矩阵
    if (LPO->Line.InpFlag == 3 && LPO->Orient.InpFlag == 3)
    {
        LPO->InpFlag = 3; // 如果直线和方向插补都完成，则设置插值标志为3
    }
    RpToTrans(Ri, pi, Ti); // 将插补旋转矩阵和坐标转换为变换矩阵
    MatrixCopy((double *)Ti, 4, 4, (double *)LPO->Ti); // 将变换矩阵复制到LPO结构体
    return;
}
// 这个函数用于计算每个插补周期中的直线路径坐标和方向。
// 它首先计算直线路径的插补坐标，然后计算方向的插补旋转矩阵。如果直线和方向插补都完成，就将插值标志设置为3，并将结果转换为变换矩阵。
```

























多线程使用使用方法

方法一：

①创建一个类从QThread类派生

②在子线程类中重写 run 函数, 将处理操作写入该函数中 

③在主线程中创建子线程对象, 启动子线程, 调用start()函数



方法二：

①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数

②在主线程中创建一QThread类对象 

③在主线程中创建一个业务类对象 

④将业务类对象移动到子线程中 

⑤在主线程中启动子线程

 ⑥通过信号槽的方式, 执行业务类中的业务处理函数。



多线程使用注意事项: 

* 1. 业务对象, 构造的时候不能指定父对象 
* 2. 子线程中不能处理ui窗口(ui相关的类) 
* 3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口







#### 自动生成运动轨迹实现

该类的实现考虑了从基本的线性运动到复杂的空间曲线

`AutoGenerateTrajectory` 类是一个用于自动生成运动轨迹的工具，主要应用于机器人或自动化设备。以下是对该类主要方法的整理和详细解释：

1. **构造函数** (`AutoGenerateTrajectory`):
   - 初始化实例，设定标志 `flag` 为1，并创建一个新的曲线拟合对象 `curveFit`。`flag` 可能用于控制轨迹生成的某些方面。
2. **设置初始参数** (`setinitialpara`):
   - 用于设置轨迹规划的基本参数，例如路径的宽度和高度。这些参数对后续的轨迹计算至关重要。
3. **设置机器人起始关节值** (`setjointsvalue`):
   - 设定机器人或设备起始时的关节坐标。这些值作为轨迹规划的起点。
4. **设置样本点** (`setSamplePoint`):
   - 设置用于曲线拟合的样本点。这些点可能来自实际测量或预定义的路径点。
5. **计算曲线参数** (`computeCurvePara`):
   - 基于样本点，用于曲线拟合或其他计算
6. **获取位置和姿态** (`getPosition`, `getPosture`):
   - 返回计算得到的一系列位置和姿态点，这些点构成了预定轨迹的关键部分。
7. **获取机器人初始关节值** (`getInitialJoint`):
   - 提供轨迹规划开始时机器人的关节值。
8. **计算法向量** (`computeNormalVector`):
   - 计算给定参数下的法向量，这对于确定物体在空间中的具体姿态非常重要。
9. **轨迹测试** (`testTrajectory`):
   - 进行轨迹测试，验证轨迹生成算法的正确性和实用性。
10. **弧形轨迹计算** (`arcTrajectory`):
    - 专门用于计算弧形轨迹，这在特定的应用场景（如隧道、圆形轨道等）中非常有用。
11. **隧道曲线拟合** (`fitTunnelCurve`):
    - 针对隧道或类似环境进行曲线拟合，以生成适应该特定环境的轨迹。
12. **自动生成整个运动轨迹** (`AutoGenerateTraj`):
    - 获取轨迹的相关参数，如半径、宽度和圆周数。
13. **获取轨迹参数** (`getR`, `getW`, `getCircleCount`):
    - 提供轨迹规划相关的详细参数，如半径、宽度和圆周数。
14. **获取起始位置** (`getStartPostion`):
    - 返回轨迹规划起始时的位置坐标，这对于整体轨迹的准确性至关重要。



#### 逆运动学求解

这段代码构成了一个逆向运动学引擎，它的核心作用是根据机器人末端执行器（TCP）的预定位置和姿态来计算其各关节应该达到的角度。以下是对代码中主要函数的功能和实现思路的整理：

1. **构造函数 (`inversekinematicsengine`)**:
   - 初始化逆向运动学引擎对象。这是整个引擎的起点，用于设置基本的状态和参数。
2. **设置TCP位置 (`setTCP`)**:工具中心点，TCP
   - 设置机器人末端执行器的目标位置。这个位置是运动规划的基础，所有计算都是为了达到这个位置。
3. **设置机器参数 (`setMachineParameters`)**:
   - 设定机器人的几何参数，如Denavit-Hartenberg参数，这些参数描述了机器人关节和连杆的几何属性。
4. **设置末端执行器姿态 (`setApproachVector`)**:
   - 定义末端执行器的空间方向。这不仅关乎位置，还包括了末端执行器对空间的取向。
5. **设置目标关节角度 (`TargetVector`)**:
   - 提供目标关节角度。这些角度代表了机器人各关节的最终目标状态。六个关节的目标角度
6. **设置起始机器坐标 (`setMachineCoordinatesStart`)**:
   - 设定起始机器坐标，即运动开始前机器人关节的角度。
7. **逆向运动学求解 (`solve`)**:
   - 核心函数，根据末端执行器的目标位置和姿态，通过数学运算求解出每个关节的角度。这一过程涉及复杂的数学模型，包括矩阵运算和三角函数。
8. **方向设置 (`getDir`)**:
   - 设定运动的方向参数，这可能影响运动的具体方式或路径，dirc和dirs可能是与机器人移动或定位相关的方向参数。
9. **速度计算 (`speedcaculate`)**:
   - 基于特定模型和参数计算机器人的运动速度，这对于动态控制非常关键。
10. **获取机器坐标 (`getMachineCoordinates`)**:
    - 返回机器人当前的机器坐标，即各关节的角度信息。
11. **清除机器坐标组 (`clearMachineCoordinatesGroup`)**:
    - 清除或重置机器坐标组，为新的运动规划准备。
12. **获取末端执行器位置和姿态**:
    - `getEndeffectorPosition` 和 `ggetEndeffectorPosition` 返回末端执行器当前和相关的位置。
    - `getEndeffectorPosture` 和 `ggetEndeffectorPosture` 返回末端执行器当前和相关的姿态。
13. **转换矩阵计算**:
    - `TransformMatrix` 和 `MiddleTransformMatrix` 计算基于关节角度的转换矩阵。
14. **正向运动学 (`FK` 和 `FFK`)**:
    - 根据给定的关节角度计算末端执行器的位置和姿态。
15. **获取运动模式 (`getway`)**:
    - 返回当前运动规划的模式或路径选择信息。

整个逆向运动学引擎的运作流程大致如下：首先，根据机器人的物理结构和初始状态（包括关节角度和末端执行器的位置姿态）设置相关参数。接着，通过 `solve` 函数或 `solveXYZ` 函数进行核心的逆向运动学计算，求解出达到目标位置和姿态所需的各关节角度。这个过程可能涉及到多种算法和数学模型的应用。计算结果可以用于指导机器人的实际运动，实现精准控制。



##### inversekinematicsengine.cpp逆向运动学计算

```c++
inversekinematicsengine.cpp
    //执行逆向运动学计算
//setTCP(Point newTCP)设置末端点位置
    //设置机器人的 DH 参数
    //DH 参数是一组数值，用来定义机器人的关节和连杆之间的几何关系，从而建立起机器人的坐标系。每个关节都有自己的 DH 参数，包括以下几个值：
//a： 这是沿着前一个关节 Z 轴的偏移距离。
//alpha： 这是绕前一个关节 Z 轴旋转的角度。
//d： 这是沿着前一个关节 X 轴的偏移距离。
//theta： 这是绕前一个关节 X 轴旋转的角度。
//通过这些参数，可以构建机器人每个关节的坐标系，并通过变换矩阵来描述关节之间的变换关系。DH 参数的使用使得机器人的正向运动学（从关节角度计算末端执行器位置）和逆向运动学（从末端执行器位置计算关节角度）的计算变得相对简单，减少了运动学分析的复杂性。
    //设置末端点的姿态（ApproachVector）
    //当前计算点的前一点的关节角度值
    //根据输入的目标关节角度数组，将其进行处理后赋值给类成员变量 TargetJoint
    //设置当前计算点的前一点的机器坐标值
```









Headers头文件

```c++
/最终将数据写入下位机和从下位机读出数据
//controlcentral   
1.con口的参数设置   
2.读取传感器数据    
3.
//configdialog      1.将面板中设置好的通信格式参数送给controlcentral
//dataexchange      1.将传进来的关节角度值按照通信协议打包好为str类型输出
                   //2.将获得的传感器数据解析为关节角度值和水平仪倾角输出

//机械臂绘制
1.读取模型数据
2.改变每个关节坐标原点的位置和姿态

 //传感器函数关系  传感器的正负方向要和关节运动的正负方向相同
 //旋转矩阵与欧拉轴，转角，四元数之间的相互转换
                   
Headers
includes.h  
mainwindow.h
mycanthread.h
robotvisualisationwidget.h
sendmsg.h
sensorfuntion.h
trajectory_plan.h
trajectoryDisplayWindow.h （openGLWindow)
    

```

Sources

```c++
Sources
AutoGenerateTrajectory.cpp 
//(位移关节的初始值、正运动学解、计算在隧道坐标系下的起始点的初始转角>0、将初始位置进行正和逆运动学计算，然后得到第一个点的位置，后将第二个进行偏移w得到第二个点、偏距w，先计算出单边的点，然后通过偏距将另一边点补齐、再增加一个比d更小距离的路径点,并等距w获得对应的路径点)
//做一些改进，采样点的起始位置和喷浆的起始位置不同时，能够正确处理轨迹规划问题
    //1.记录下初始位置的位置向量和方向向量
    //2.设置好轨迹规划的参数
    //3.按照参数取得u，然后计算出key point，再偏置得到另一个key point
     //计算喷浆起始点的位置向量和方向向量
    //计算喷浆起始点位置偏离采样点集的开始或结束地方的距离
 checkjoint.cpp、checksensor.cpp（关节、传感器）
 coordinatesinfo.cpp（坐标信息）
 curvefit.cpp（曲线拟合）

```

#####  controlcentral.cpp控制单元

```c++
 controlcentral.cpp
      //系统参数初始化，开启系统运行，系统状态的实时反馈
    //整个系统的执行入口
    //void ControlCentral::trajectoryPlanning()
    //调用轨迹规划程序实现运动仿真
    //1.计算出所有的轨迹点
    //2.求出插值点对应的关节角度值
    //3.将robotModel中的关节值更新
    //在自动轨迹规划内设置采样点
     //刷新斜面基准下的新方向增量,傻瓜半自动
    //刷新斜面基准，根据隧道的半自动
    //Gui->setTCP(jointsPoints);最后一根连杆的末端点位置
    //Gui->setPST(pst);末端点姿态
    //更新传感器数据值，并计算与理论值的误差
    //单位是度(and mm)
    //绘制dynamic关节角曲线图
     //绘制机械臂3D图
    //1.每个关节角的位置，2.每个关节角的RPY值
    //如果是仿真则采用仿真的数据，如果是在实时控制机械臂，则采用真实关节值更新三维动画
    /* 发送数据至下位机代码*/
    //设置一个数据开始发送的标志位，启动数据发送
    // 按一定的控制频率将数据发送给下位机
    //void ControlCentral::getP1()
    //input 关节角度  关节角度值来自于传感器的值
    //output 机械臂末端点
    //再利用坐标系转换  得到隧道坐标系下的位置
    //调用逆运动学引擎提供的正向运动学计算末端点的位置
```

##### glwidget.cpp图形渲染

```c++
glwidget.cpp  
    //显示OpenGL图形并进行交互。这个类实现了一些基本的OpenGL绘制功能和事件处理，实现图形的渲染和交互操作。
    //void GLWidget::initializeGL() OpenGL初始化设置，包括深度测试、颜色设置、光照设置等。
    //void GLWidget::paintGL()  清空缓冲区，设置视图和光照，绘制3D场景。
    // 鼠标事件处理函数：mousePressEvent、mouseMoveEvent、wheelEvent 函数处理鼠标按下、鼠标移动和滚轮事件，用于进行交互操作，如旋转视图、缩放等。

```

gui.cpp

```c++
gui.cpp==看gui.h理解
    //定义了一个名为 gui 的类，它继承自 QObject 类，这意味着这个类可以使用 Qt 的信号和槽机制。这个类似乎与用户界面的操作和控制有关
    //构造函数：
//explicit gui(QObject *parent = nullptr);
这是 gui 类的构造函数，可以传入一个父级对象指针作为参数。

//成员函数：这个类包含了一系列函数，用于获取和设置不同的数据，如机器坐标、传感器值、参数等。这些函数还包括设置一些状态、更新图形、触发信号等操作。

//signals 部分：在这个部分声明了一些信号，这些信号可以在特定条件下被发射（emit）。这些信号与用户界面的事件交互有关，当某些事件发生时，信号会被触发。

//slots 部分：在这个部分声明了一些槽函数，这些函数通常用于响应特定的信号。当信号被触发时，与之相关联的槽函数会被调用。
    //这些槽函数对应于用户界面中的不同操作或按钮点击事件，例如手动模式选择、自动模式选择、XYZ模式选择、参数设置点击等。
    //设置通信格式的槽函数。
    //当机器坐标滑块或文本改变时触发的槽函数。
    //传感器校准的槽函数。
    //设置坐标的槽函数。
    //开启CAN通信的槽函数。
    //设置 传感器 文本的槽函数。
    //设置 点 文本的槽函数。
    // 速度变化的槽函数。

//私有成员变量：在这个类中声明了一些指向其他类的指针，如 MainWindow*、ConfigDialog* 等，这些可能是与用户界面和其他部分相关的类。
    MainWindow* mainWindow;//MainWindow 是应用程序的主窗口，用于显示用户界面。
    ConfigDialog* configDialog;//用于显示和处理配置对话框，允许用户设置一些参数或选项
    Calibration* sensorCalibration;//用于处理传感器的校准操作
    CoordinatesSet* coordinatesSet;//用于管理和处理坐标
    curveFitParameterSet* curfitInterface;//用于管理和处理曲线拟合操作的参数

//总体来说，这个 gui 类似乎用于管理用户界面的各种操作、设置和状态。它通过信号和槽机制实现了用户界面与代码逻辑之间的通信和交互。这个类可能是在Qt框架中用于用户界面设计和操作的一部分。
```

##### inversekinematicsengine.cpp逆向运动学计算

```c++
inversekinematicsengine.cpp//执行逆向运动学计算
//setTCP(Point newTCP)末端点位置
    //设置机器人的 DH 参数
    //DH 参数是一组数值，用来定义机器人的关节和连杆之间的几何关系，从而建立起机器人的坐标系。每个关节都有自己的 DH 参数，包括以下几个值：
//a： 这是沿着前一个关节 Z 轴的偏移距离。
//alpha： 这是绕前一个关节 Z 轴旋转的角度。
//d： 这是沿着前一个关节 X 轴的偏移距离。
//theta： 这是绕前一个关节 X 轴旋转的角度。
//通过这些参数，可以构建机器人每个关节的坐标系，并通过变换矩阵来描述关节之间的变换关系。DH 参数的使用使得机器人的正向运动学（从关节角度计算末端执行器位置）和逆向运动学（从末端执行器位置计算关节角度）的计算变得相对简单，减少了运动学分析的复杂性。
    //设置末端点的姿态（ApproachVector）
    //当前计算点的前一点的关节角度值
    //根据输入的目标关节角度数组，将其进行处理后赋值给类成员变量 TargetJoint
    //设置当前计算点的前一点的机器坐标值
```

joystick.cpp手柄检测

```c++
joystick.cpp
    // openJoy()打开手柄，开启对手柄的检测功能
    // 轮询检测手柄按键函数
paintTheroyTrajectory(QVector<Point> t)//理论曲线接口
paintpracticeTrajectory(vector<double> p)//实际曲线接口
    
main.cpp
    #include "mainwindow.h"：应用程序的主窗口类的声明。

#include <QApplication>： Qt 框架的应用程序类的头文件。

#include "inversekinematicsengine.h"：逆向运动学引擎类的声明。

#include "trajectoryinterpolator.h"：轨迹插值器类的声明。

#include "AutoGenerateTrajectory.h"：自动生成轨迹的类的声明。

#include "robotmodel.h"：机器人模型类的声明。

#include "gui.h"：图形用户界面（GUI）类的声明。

#include "controlcentral.h"：控制中心类的声明。

int main(int argc, char *argv[])：这是主函数的定义，它接受命令行参数 argc 和 argv[]。

QApplication a(argc, argv);：创建了一个 QApplication 类的实例 a，并传递命令行参数给它，用于初始化 Qt 应用程序。
```

##### mainwindow.cpp主窗口

```c++
mainwindow.cpp //初始化主窗口以及主窗口内各个部件的状态、样式、文本
//MainWindow(QWidget *parent): QMainWindow(parent), ui(new Ui::MainWindow)  调用 ui 对象的 setupUi 函数，用于将界面的设计布局应用到当前主窗口对象。
    //滑动条和数值框的值后面应该根据传感器读取的数值进行初始化
    //手动输入值的初始化,这里的值应该设置为传感器获得的数据
    //on_SettingFinish_clicked()自动化轨迹生成参数设置好后，选中设置完成，才能进行仿真和启动
    //如果从手动模式切换到自动控制模式时，参数设置完成按钮已经被按下，参数不能被读入，重新选中才能读入参数
    void MainWindow::on_Simulator_clicked()
{
    //调用函数实现仿真运动
    if(selectSimulator)
    {
        qDebug() << "simulator" << endl;
        selectSimulator = false;
        selectStart = true;
        ui->Simulator->setChecked(true);
        ui->Start->setChecked(false);
        ui->Stop->setChecked(false);
        ui->Reset->setChecked(false);
        ui->Close->setChecked(false);
        emit SimulatorButtonClicked();
    }
}
void MainWindow::on_Start_clicked()
{//读取保存好的关节组数据文件，发送到下位机
    
//包含两个 MainWindow 类的槽函数，分别是 on_Simulator_clicked 和 on_Start_clicked，用于响应名为 Simulator 和 Start 的按钮的点击事件
```

mycanthread.cpp CAN通信

```c++
mycanthread.cpp、mycanthread_recev.cpp(看代码更好)
    //connect(clock, SIGNAL(timeout()), this, SLOT(testConnectStatus())); 连接 clock 的超时信号到 MyCanThread 类的 testConnectStatus() 槽函数。
// ReceiveCANThread();//接收CAN数据
    #include "mycanthread.h"
#include <QDebug>

MyCanThread::MyCanThread():QThread()
{
    stopped = false;//线程是否停止
    devtype=3;//USBCAN1
    devind=0;//
    res=0;//
    canind=0;//CAN
    reftype=0;//
    bool ok;
    clock = new QTimer;
    clock->setInterval(80);
    VCI_ERR_INFO vei;
    VCI_CAN_OBJ preceive[100];
    VCI_CAN_OBJ psend;
    int baud=0x10000000;//
    openSuccess = false;
    ConnectError = true;
    send_flag = false;
    receData = "38 00 00 00 00 00 00 37";
    clock->start();
    //连接 clock 的超时信号到 MyCanThread 类的 testConnectStatus() 槽函数。
    connect(clock, SIGNAL(timeout()), this, SLOT(testConnectStatus()));
}

void MyCanThread::run()
{
    while(!stopped)
    {
        ReceiveCANThread();//接收CAN数据
    }
    stopped = false;
}

void MyCanThread::testConnectStatus()
{
//    qDebug()<< "探测CAN连接状态";
    VCI_CAN_OBJ psend;
    //
    ULONG Tr;
    psend.ID=id;    //帧 ID
    psend.SendType=0;   //0 时为正常发送（发送失败会自动重发，重发最长时间为 1.5-3 秒）
    psend.RemoteFlag=0; //是否是远程帧。=0 时为为数据帧，=1 时为远程帧（数据段空）
    psend.ExternFlag=0;     //是否是扩展帧。=0 时为标准帧（11 位 ID），=1 时为扩展帧（29 位 ID）
    psend.DataLen=8;    //数据的有效字节长度，最大为8个字节
    VCI_ERR_INFO vei;
//    for (int i=0; i < 8; i++)
//    {
//        psend.Data[i]='00';
//    }

//    Tr=VCI_Transmit(devtype,devind,canind,&psend,1);    //发送数据
//    if(Tr != 1){
//        ConnectError = true;
//        qDebug()<< "发送失败";
//    }else{
//        qDebug()<< "连接正常";
//    }
    VCI_CAN_STATUS vcs;
    //DWORD dwRel;
//    if(VCI_ReadCANStatus(devtype,devind,canind,&vcs) == ERR_CMDFAILED)
//    {
//        qDebug()<< "连接失败";
//    }else{
//        qDebug()<< "连接正常";
//    }
//    if(VCI_ReadErrInfo(devtype,devind,canind,&vei) == ERR_NO_STARTUP)
//    {
//        qDebug()<< "连接失败";
//    }else{
//        qDebug()<< "连接正常";
//    }
}

void MyCanThread::stop()
{
    stopped = true;
}

void MyCanThread::ReceiveCANThread()
{
    VCI_ERR_INFO vei;
    VCI_CAN_OBJ preceive[1000];
    ULONG res = 2;
    //int count;

    res=VCI_GetReceiveNum(devtype,devind,canind);//获取缓冲区中接收但尚未被读取的帧数

    if(res<=0)//未接收到数据或操作失败
    {
//        qDebug() << "未收到下位机数据";
//        ConnectError = true;
        if(VCI_ReadErrInfo(devtype,devind,canind,&vei)!=STATUS_ERR)
        {
            //qDebug()<<QStringLiteral("3-7  1:")<<QString::number(vei.ErrCode,16);
        }
    }else{
        res=VCI_Receive(devtype,devind,canind,preceive,1000,100);//200ms     接收数据

//        qDebug()<<"Frame ID"<<res;
            if(res==4294967295)//4294967295=0xFFFFFFFF
            {
                if(VCI_ReadErrInfo(devtype,devind,canind,&vei)!=STATUS_ERR)
                {
                    qDebug()<<"Read Data failed"<<"Error Data:"<<QString::number(vei.ErrCode,16);
                }
            }else{
                //qDebug() << "接收成功";
                emit my_signal(preceive, res);
            }
    }

}
// 在 CAN 通信中传输数据
void MyCanThread::TransmitCANThread(unsigned int id,unsigned char *ch)
{
    VCI_CAN_OBJ psend;
    //
    ULONG Tr;
    psend.ID=id;    //帧 ID
    psend.SendType=0;   //0 时为正常发送（发送失败会自动重发，重发最长时间为 1.5-3 秒）
    psend.RemoteFlag=0; //是否是远程帧。=0 时为为数据帧，=1 时为远程帧（数据段空）
    psend.ExternFlag=0;     //是否是扩展帧。=0 时为标准帧（11 位 ID），=1 时为扩展帧（29 位 ID）
    psend.DataLen=8;    //数据的有效字节长度，最大为8个字节
    for (int i=0; i < 8; i++)
    {
        psend.Data[i]=ch[i];
    }

    Tr=VCI_Transmit(devtype,devind,canind,&psend,1);    //发送数据
    if(Tr==1){
//        qDebug()<< "发送成功";
    }
}

bool MyCanThread::getOpenStatus()
{
    return this->openSuccess;
}

bool MyCanThread::getConnectStatus()
{
    return this->ConnectError;
}

void MyCanThread::OpenCANThread()
{
//    bool ok;
    VCI_ERR_INFO vei;
//    VCI_CAN_OBJ preceive[100];
//    VCI_CAN_OBJ psend;
    int baud=0x01000000;    //参数有关数据缓冲区地址首指针

//    设置设备参数 canind = 0
//        if(VCI_SetReference(devtype,devind,canind,reftype,&baud)==STATUS_ERR){
//            qDebug("set reference error");
//            VCI_CloseDevice(devtype,devind);
//            return;
//        }

   //打开设备
    if(VCI_OpenDevice(devtype,devind,res)==STATUS_ERR)//
    {
        if(VCI_ReadErrInfo(devtype,devind,canind,&vei)!=STATUS_ERR)
        {
        qDebug()<<"Open failed"<<QString::number(vei.ErrCode,16);
        }else
            qDebug()<<"error";
        return;
    }else{
            qDebug()<<"open successed";
    }


    //初始化
    VCI_INIT_CONFIG init_config;
    init_config.Mode=0;//正常模式，1为只听模式
    init_config.Filter=1;//滤波方式
    //can
    //波特率是250Kbps
    init_config.Timing0=0x01;//定时器0
    init_config.Timing1=0x1c;//定时器1
    //接受的地址
    init_config.AccCode=0x10000000;//验收码
    init_config.AccMask=0xFFFFFFFF;//屏蔽码
    //
    if(VCI_InitCAN(devtype,devind,canind,&init_config)==STATUS_ERR){
        qDebug("Init Error");
        VCI_CloseDevice(devtype,devind);
        return;
    }else
        qDebug()<<"Init successed";


    //读取设备信息
    VCI_BOARD_INFO vbi;
    if(VCI_ReadBoardInfo(devtype,devind,&vbi)!=STATUS_ERR){
        qDebug()<<QStringLiteral("Count_Channel:")<<vbi.can_Num;
        qDebug()<<QStringLiteral("version_hardware:")<<vbi.hw_Version;
        qDebug()<<QStringLiteral("version_APIlib:")<<vbi.in_Version;
        qDebug()<<QStringLiteral("Num_Interrupt:")<<vbi.irq_Num;
        qDebug()<<QStringLiteral("can_Channel:")<<vbi.can_Num;
    }
    //清除缓冲区
    VCI_ClearBuffer(devtype,devind,canind);

    //启动设备
    if(VCI_StartCAN(devtype,devind,canind)==STATUS_ERR){
        qDebug()<<"start fail";
        VCI_CloseDevice(devtype,devind);
        return;
    }else{
        openSuccess = true;
        ConnectError = false;
        qDebug()<<"start successed";
    }
}

void MyCanThread::CloseCANThread()
{
    VCI_CloseDevice(devtype,devind);
    openSuccess = false;
    ConnectError = true;
    qDebug()<<"closed";
}


//        qDebug()<< "id="<< id << endl;

//        //判断ID=16#14的接收缓存，如果是38 22 22 22 22 22 22 37 则发送数据
//        if (id == 20){
//            if (QString::number(preceive[i].Data[0],16) == "38"
//                    and QString::number(preceive[i].Data[1],16) == "22"
//                    and QString::number(preceive[i].Data[2],16) == "22"
//                    and QString::number(preceive[i].Data[3],16) == "22"
//                    and QString::number(preceive[i].Data[4],16) == "22"
//                    and QString::number(preceive[i].Data[5],16) == "22"
//                    and QString::number(preceive[i].Data[6],16) == "22"
//                    and QString::number(preceive[i].Data[7],16) == "37"){
//                send_flag = true;
//                //发送一个信号，开启发送线程
//                emit startSendThread();
//            }
//        }

//        if(id == 20)
//        {
//            qDebug()<< "接收到下位机要求新一组数据的信息";
////            QString s="0x";
////            qDebug()<<QStringLiteral("FtameID:")<<s.append(QString::number(preceive[i].ID,16));
////            qDebug()<<QStringLiteral("FrameData:")<<QString::number(preceive[i].Data[0],16)<<QString::number(preceive[i].Data[1],16)
////                    <<QString::number(preceive[i].Data[2],16)<<QString::number(preceive[i].Data[3],16)
////                    <<QString::number(preceive[i].Data[4],16)<<QString::number(preceive[i].Data[5],16)
////                    <<QString::number(preceive[i].Data[6],16)<<QString::number(preceive[i].Data[7],16);
////            qDebug()<<QStringLiteral("FrameLength:")<<preceive[i].DataLen;
//        }
  }

}
```



pwmAndVelocity() .cpp 电机脉宽

用于计算电机的脉宽调制（PWM）信号和速度的函数

##### robotvisualisationwidget.cpp机器人可视化状态

```c++
robotvisualisationwidget.cpp //机器人的可视化状态
    //绘制机械臂 位置
    // jointsPostures = rot;姿态
    // 更新关节的位置和姿态
    // glRotatef(GLfloat(-(coords.f_1)*180/PI), 0.0, 1.0, 0.0);
    OpenGL中的旋转函数，根据角度进行旋转操作。实现机器人可视化中的姿态变换，以在三维空间中正确显示机器人的朝向
    //  glTranslatef(340.6f, 0.0, -45.25f);OpenGL中的平移函数，用于在三维空间中平移物体或模型。控制机器人可视化中的位置调整，以便在三维空间中正确放置机器人的位置
    //绘制末段点
    //绘制世界坐标系的XYZ轴
```

sendmsg.cpp发送CAN消息到下位机

```c++
sendmsg.cpp  通信==用于发送 CAN 消息到下位机
   
#include "sendmsg.h"
#include <QCoreApplication>
#include <iostream>
//初始化发送和接收线程，并建立线程之间的通信连接。这样，在实例化 sendMsg 对象时，就可以在合适的时候发送和接收 CAN 消息
sendMsg::sendMsg()
{
    qRegisterMetaType<VCI_CAN_OBJ>("VCI_CAN_OBJ");
    //注册can结构体， 以便在信号和槽之间传递 CAN 数据
    qRegisterMetaType<PVCI_CAN_OBJ>("PVCI_CAN_OBJ");//注册can结构体
    qRegisterMetaType<CAN_SEND_FRAME_STRUCT>("CAN_SEND_FRAME_STRUCT");
    // 连接的 CAN 设备和通道
    deviceTye = 3;
    device = 0;
    chanel = 0;

    makedata = new makeData;
    sendThreadCAN1 = new MyCanThread;
    //处理发送 CAN 消息的线程。然后将该线程移到一个独立线程 sendThread 中执行
    sendThreadCAN1->moveToThread(&sendThread);
    processMsg = new MyCanThread_recev;
    //处理接收 CAN 消息的线程。然后将该线程移到一个独立线程 processThread 中执行
    processMsg->moveToThread(&processThread); 
 
    connect(sendThreadCAN1,SIGNAL(my_signal(PVCI_CAN_OBJ,int)),processMsg,SLOT(ReceiveCANThread(PVCI_CAN_OBJ,int)));
    //使用 connect 函数将 sendThreadCAN1 的信号连接到 processMsg 的槽，用于将接收到的 CAN 消息传递给消息处理线程。
    connect(processMsg, SIGNAL(startSendThread()), this, SLOT(transmitSendInfo()));
    //使用 connect 函数将 processMsg 的信号连接到 this 的槽 transmitSendInfo()，以便在消息处理线程接收到信息后触发一个发送信号。
}


void sendMsg::setJoints(QVector<int> joints)
{
    this->joints = joints;
}

void sendMsg::setPWM(QVector<int> pwm)
{
    this->pwm = pwm;
}

// 此处对于模式切换有改动，主要适应于半自动和手动模式，如果使用全自动模式请使用
// 根据所选的运动模式，发送控制模式的命令到下位机。根据不同的模式，发送相应的数据帧，以告知下位机切换到对应的控制模式。
void sendMsg::sendSelectMode(KinematicsMode mode)
{
    unsigned char data_from_text[8];
    unsigned int start_id = 400;//0x190
    QString start_char;
    //当控制模式为自动模式时，代码向 start_char 字符串中追加了一串表示 CAN 数据帧内容的固定十六进制数字。这个字符串可能在后续的 CAN 通信中被使用，可能是作为控制信息发送给下位机。
    if(mode == KinematicsMode::Automation)
    {
        std::cout << "Automation" << std::endl;
        start_char.append("37 01 01 01 01 01 01 38");
    }
    else if(makedata->getchangemode() == true)
    {
        std::cout << "XYZ" << std::endl;
        start_char.append("37 02 02 02 02 02 02 38");
    }
    else if(makedata->getchangemode() == false)
    {
        std::cout << "manual" << std::endl;
        start_char.append("37 03 03 03 03 03 03 38");
    }

     //告诉下位机 机械臂的控制模式
     for(int i = 0; i < 8; i++)
     {
         data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
     }
     \
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
     QThread::msleep(5);
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
          QThread::msleep(5);
sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
}

void sendMsg::sensorCalibration(){
     makedata->savepos();
}

void sendMsg::sendEndFlag()
{
}
// 启动发送线程和处理线程，用于处理发送和接收 CAN 消息
void sendMsg::start()
{
    sendThreadCAN1->OpenCANThread();//打开 CAN 设备
    sendThreadCAN1->start();//启动 CAN 发送线程
    sendThread.start();//启动 sendThread 和 processThread 线程
    processThread.start();
}
void sendMsg::stopSendAndRecv()
{
    sendThreadCAN1->stop();   //停止从 CAN 总线接收数据
}
void sendMsg::close()//关闭和终止与 CAN 通信相关的线程
{
    sendThread.quit();//停止发送线程
    processThread.quit();//停止接收线程
    sendThreadCAN1->stop();//停止 CAN 接收线程
    sendThreadCAN1->CloseCANThread();//关闭 CAN 设备
}
//发送一个信号，表示开始发送消息。该信号会被连接到相应的槽函数，以实现数据的发送
void sendMsg::transmitSendInfo()
{
    emit start_sendMessage();
}
bool sendMsg::getOpenStatus()//CAN 设备是否已打开
{
    return sendThreadCAN1->getOpenStatus();
}
bool sendMsg::getConnectStatus()// CAN 设备是否已连接
{
    return sendThreadCAN1->getConnectStatus();
}





重点：

//发送 CAN 消息
void sendMsg::sendMessage()
{
    //采用事件触发机制，而不是盲等
    //如果上位机接收到下位机的信息，需要发送下一组关节角数据，则开启线程，启动数据发送

    //1.写明ID地址    2.制造数据
    //下位机发送了启动信号,则改变send_flag = true;while send_flag =true {发送数据,改变send_flag=flase,等待下位机通知再次发送} //停止发送按钮也可以直接改变send_flag=false
    QString transmit_str = QStringLiteral("ID:");
    unsigned int id = 0, start_id=16;

    unsigned char data_from_text[8];
    QStringList list1;
    QString start_char;
    start_char.append("38 33 33 33 33 33 33 37");
    //当没有发送完计算出的所有关节角组，一直等待发送

    //将关节角和 PWM 数据发送到 CAN 总线上，以便与下位机进行通信和控制。每个数据包的格式都经过了转换，然后通过 sendThreadCAN1 对象的方法进行发送
    // PWM=脉冲宽度调制数据，用于控制电机的速度或位置
     //先发送一帧数据给下位机，告诉下位机要开始接收数据，38 33 33 33 33 33 33 37
     for(int i = 0; i < 8; i++)
     {
         data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
     }
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
    //将 data_from_text 数组中的数据发送到 CAN 总线上，使用 ID start_id

     unsigned int pwm_ID = 10;//构造 PWM 数据的 ID
     for (int i=0;i < 6;i++) {
        id = static_cast<unsigned int>(i + 1);        
         //ID: 1~6
        pwm_ID++;
        sendData = makedata->rawData2sendData(joints[i]);
         //将关节角数据转换为发送给下位机的格式
        sendData_pwm = makedata->rawData2sendData(pwm[i]);
         //将 PWM 数据转换为发送给下位机的格式
        //qDebug() << "sendData " << sendData << endl;
        //makedata->receData2realData(sendData);
        //qDebug() << "realJoint " << makedata->getRealValue();

        //发送关节角
        for(int j = 0; j < 8; j++)
        {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(id,(unsigned char *)data_from_text);//将关节角数据发送到 CAN 总线上，使用相应的 ID

        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear();
        sendData_pwm.clear();
    }


}
// 发送 PWM 数据到下位机的代码块
void sendMsg::sendMessages(){
     //作为新的发送器
    QString sendData_pwm;


    unsigned char data_from_text[8];

     unsigned int pwm_ID = 0x191;
    sendData_pwm = makedata->rawData6sendData(pwm);
//    qDebug() << "sendData_pwm:" << sendData_pwm<<endl;
//从 pwm 数组中获取 PWM 数据，并将其转换为一种适合发送给下位机的格式

        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);
//将转换后的 PWM 数据以指定的 ID (pwm_ID) 发送到 CAN 总线上
        sendData.clear();
        sendData_pwm.clear();
}

//发送 XYZ 模式的消息。它包括创建用于发送数据的缓冲区、将 PWM 数据转换为适合发送的格式，以及通过 sendThreadCAN1->TransmitCANThread 方法将数据发送到 CAN 总线上。
void sendMsg::sendXYZmess(){
    QString sendData_pwm;


    unsigned char data_from_text[8];

     unsigned int pwm_ID = 0x191;
    sendData_pwm = makedata->rawData6sendData(pwm);
//    qDebug() << "sendData_pwm:" << sendData_pwm<<endl;


        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear();
        sendData_pwm.clear();
}


//发送自动模式的消息。与 sendXYZmess() 函数类似，它也包括创建缓冲区、转换 PWM 数据并发送数据
void sendMsg::sendAUTOmess(){
    QString sendData_pwm;


    unsigned char data_from_text[8];

     unsigned int pwm_ID = 0x191;
    sendData_pwm = makedata->rawData6sendData(pwm);
//    qDebug() << "sendData_pwm:" << sendData_pwm<<endl;


        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear();
        sendData_pwm.clear();
}
//根据十六进制表示将字符转换为整数
int sendMsg::hex_str_to_int(unsigned char *ch)
```

timingtransmitter.cpp定时发送控制信号

```c++
timingtransmitter.cpp 定时发送控制信号
#include "timingtransmitter.h"
#include "QDebug"
#include "math.h"
#include <QDateTime>
#define PI 3.14159265358979323846
    //TimingTransmitter 类是一个继承自 QThread 的类，用于实现定时发送控制信号
TimingTransmitter::TimingTransmitter():QThread()
{
    alarm = new QTimer;
    alarm->setInterval(25);//定时器的间隔为 25 毫秒
    alarm->start();
    connect(alarm,SIGNAL(timeout()),this,SLOT(onTransmitter()));
    //连接定时器的 timeout 信号到 onTransmitter 槽函数，实现定时触发
}
//设置控制模式，即切换控制模式。根据不同的模式，定时器的触发行为可能会改变
void TimingTransmitter::modeselect(KinematicsMode kinematicsmode){
    this->kinematicsmode = kinematicsmode;
}


//onTransmitter 槽函数是定时触发的主要处理逻辑。根据当前的控制模式，它会发射不同的信号，即 start_XYZ 或 start_auto，从而触发相关的控制操作
void TimingTransmitter::onTransmitter(){

    if((this->kinematicsmode == KinematicsMode::manual)) {
//        qDebug() << "定时器发送成功！" << "manual" << endl;
    }
    else if(this->kinematicsmode == KinematicsMode::Automation){
//        qDebug() << "定时器发送成功！" << "Automation" << endl;
        AUTOcontrol();
    }else {
//        qDebug() << "定时器发送成功！" << "XYZ" << endl;
        XYZcontrol();
    }
}

//在控制模式为 XYZ 时执行的操作。它会通过 emit start_XYZ() 发射一个信号，可能是用来触发某些与 XYZ 控制相关的操作
void TimingTransmitter::XYZcontrol(){
        emit start_XYZ();
}


//控制模式为 Automation 时执行的操作。它会通过 emit start_auto() 发射一个信号，可能是用来触发某些与自动化控制
void TimingTransmitter::AUTOcontrol(){
            emit start_auto();
```

##### sensorFunction.cpp传感器数据和关节数据进行处理

```C++ 
sensorFunction.cpp //对传感器数据和关节数据进行处理
//设置传感器数据、关节数据和一个参数 k
//getJointValue(int sensor)：函数用于返回一个传感器值作为关节数
    //fixFun()：修正操作，根据传感器数据计算 tmpJoint 并更新 offset 的值  == 根据基准值调整传感器数据
```

##### trajectory_plan.cpp轨迹点和姿态

```c++
trajectory_plan.cpp、trajectoryDisplayWindow.cpp、trajectoryinterpolator.cpp
    // 直线路径插补相关函数
    // 将姿态插补和直线路径插补封装在一起
    // 窗口类，用于显示轨迹（或路径）的信息
    
    
    //生成机械臂运动的轨迹点和姿态，可以根据提供的点、姿态和参数进行固定步长插值或时间插值。这些插值方法可以用于控制机械臂在特定路径上的运动
    //轨迹插值器。这个类的作用是计算和生成机械臂运动的轨迹点和姿态，以便控制机械臂在特定路径上进行运动。它可以使用固定步长插值或时间插值的方法来生成轨迹点和姿态，以实现机械臂的运动规划和控制。
trajectoryinterpolator.h
  //class trajectoryinterpolator : public QObject
    //继承自 QObject，具有信号和槽的特性，用于轨迹的插值计算和规划
    成员函数：
void setStepLength(double step);：设置固定步长插值中的步长。
void setStartPoint(Point p);：设置轨迹的起始点。
void setFinishPoint(Point p);：设置轨迹的结束点。
void setStartPosture(ApproachVector posture);：设置轨迹起始点的姿态。
void setFinishPosture(ApproachVector posture);：设置轨迹结束点的姿态。
void setTimeInterPara(double v, double r, double w, double n_segment);：设置时间插值所需的参数，包括机械臂喷头移动速度、过渡圆弧半径、轨迹宽度和弧线段数量。
void stepInterpolator();：进行固定步长插值，用于生成轨迹点，但不能控制喷头的移动速度。
void timeInterpolator();：进行时间插值，计算生成插值点，可以控制喷头的移动速度。
void calculate();：根据设置的参数计算轨迹和姿态。
QVector<Point> getTrajectory();：获取生成的轨迹点。
QVector<ApproachVector> getPosture();：获取生成的轨迹姿态。
    
```

##### trajectoryDisplayWindow.cpp  OpenGL 在 GUI 显示

```c++
trajectoryDisplayWindow.cpp
    //承自 QGLWidget 的自定义 OpenGL 窗口类，用于在 GUI 中显示 3D 图形
OpenGLWindow :: OpenGLWindow(QWidget *parent)
       :QGLWidget(parent)
{
    m_scloe = -30;//缩放参数
    m_rotx = 5;//绕 X、Y、Z 轴的旋转角度，用于控制模型的旋转效果
    m_roty = 5;
    m_rotz = 5;
    m_count = 0;//跟踪绘制次数
    m_isize = 0;//控制渲染的某些元素的大小
    m_anglev = 8;//控制渲染中的角度

}

OpenGLWindow::~OpenGLWindow()
{
}

void OpenGLWindow::initializeGL()
{
    glClearColor(1, 1, 1, 1.0);//GL背景色=白色
    glShadeModel(GL_SMOOTH);//着色模式==平滑着色模
    glEnable(GL_DEPTH);//启用深度测试。深度测试是OpenGL中用来控制绘制顺序的一个重要机制，确保远处的对象不会遮挡近处的对象。
}

//用于在OpenGL窗口大小改变时重新配置OpenGL的视口设置和投影矩阵配置，以适应新的窗口尺寸
void OpenGLWindow::resizeGL(int w, int h)
{
    if (h == 0)//防止height为0
    {
        h = 1;
    }
    glViewport(0, 0, w, h);//重置当前的视口 ==指定了渲染窗口中可以用来显示图形的区域

    glMatrixMode(GL_PROJECTION);//选择投影矩阵  ==选择投影矩阵模式，以便设置透视投影矩阵
    glLoadIdentity();//重置投影矩阵
    gluPerspective(45.0, w / h, 0.1, 1000.0);//建立透视投影矩阵 ==四个参数：视场角、宽高比、近裁剪面和远裁剪面

    glMatrixMode(GL_MODELVIEW);//选择模型观察矩阵
    glLoadIdentity();//重置模型观察矩阵

}
//OpenGL窗口中绘制3D场景，包括坐标轴、网格、圆柱体等元素。
//这些元素的绘制是通过OpenGL的绘制函数和变换函数来实现的，以达到在3D空间中可视化显示场景的效果
void OpenGLWindow::paintGL()
{
    //qDebug() << "paintGL with t_vetorx.size() = " << t_vetorx.size();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//清除屏幕和深度缓存
    glLoadIdentity();//重置当前的模型观察矩阵。在glLoadIdentity()调用之后，函数返回之前，添加代码来创建基本的形
                     //目前所做的就是将屏幕清除成前面所决定的颜色，清除深度缓存并且重置场景，仍然没绘制任何东西。
                     //glPolygonMode(GL_FRONT_AND_BACK ,GL_LINE );
                     //前后面，填充方式（点point、线line、FILL）

    //OpenGL 的平移、旋转函数显示窗口 
    glTranslatef(-1, -4,m_scloe);
    glRotatef(m_rotx, 1.0, 0.0, 0.0);
    glRotatef(m_roty-40, 0.0, 1, 0.0);
    glRotatef(m_rotz-2, 0.0, 0.0, 1);
    GLUquadricObj *objCylinder = gluNewQuadric();//创建一个新的二次曲面对象，这里用于绘制圆柱体

    int pt = 12;//xyz轴的长度
    int num = 12;//控制网格疏密

    //Y轴
    glColor3f(0, 1, 0);
    glLineWidth(5);
    glBegin(GL_LINES);//开始绘制线段。
        glVertex3f(0,0,0);// 绘制线段的顶点坐标
        glVertex3f(pt,0,0);
    glEnd();              // 结束绘制线段

    //网格
    //Y
    glPushMatrix();

    glColor3f(0.8, 0.8, 0.8);
    glTranslatef(-m_isize, -m_isize, -m_isize);
    GLGrid(0, 0, 0, pt, 0, pt, num);//绘制网格
    glPopMatrix();

    glPushMatrix();
    glColor3f(0, 1, 0);
    glTranslatef(pt, -m_isize, -m_isize);
    glRotatef(90, 0, 1, 0.0);
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);//绘制圆柱体
    glPopMatrix();

    //Z
    glPushMatrix();
    glTranslated(-m_isize, m_isize, -m_isize);
    glRotatef(-90, 1.0, 0.0, 0.0);
    glColor3f(0.8, 0.8, 0.8);
    GLGrid(0, 0, 0, pt, 0, pt, num);
    glPopMatrix();

    glPushMatrix();
    glColor3f(0, 0, 1);
    glTranslatef(-m_isize, pt, -m_isize);
    glRotatef(-90, 1, 0, 0);
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);
    glRasterPos3d(5.0,5.0,5.0);//设置光栅位置，用于在场景中绘制文字
    glPopMatrix();

    //X
    glPushMatrix();                           //push,pop栈使用
    glTranslatef(-m_isize, -m_isize, -m_isize);
    glRotatef(90, 0.0, 0.0, 1.0);              //网格所在空间位置
    glColor3f(0.8, 0.8, 0.8);                  //网格颜色
    GLGrid(0, 0, 0, pt, 0, pt, num);
    glPopMatrix();

    glPushMatrix();
    glColor3f(1, 0, 0);                         //箭头颜色
    glTranslatef(-m_isize, -m_isize, pt);
    glRotatef(90, 0, 0, 1);
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);//小箭头
    glPopMatrix();

    LabelXYZ();

/*
 * 调用时只需将下两个接口进行调用，出入具体的嵌套接口即可
*/
    updateTheroyTraj();
    updatePracticeTraj();
}

//绘制坐标轴标签的函数 LabelXYZ()，它绘制了X、Y和Z轴上的字母标签
void OpenGLWindow::LabelXYZ()
{
    /*********************X,Y,Z字母***************************************/
        GLfloat size2 = 2.0;
        glLineWidth(size2);
        //通过一系列的数组定义（a1、b1、c1、a2、b2、c2、a3、b3、c3）定义了每个轴上的标签的位置
        double a1[3]= {6.5,6.75,7};
        vector<double> n1_vetorx(a1,a1+3);
        double b1[3]= {13.0,13.0,13.0};
        vector<double> n1_vetory(b1,b1+3);
        double c1[3]= {-0.75,-0.5,-0.25};
        vector<double> n1_vetorz(c1,c1+3);
        //调用OpenGL的绘制函数来绘制每个轴上的标签
        if (n1_vetorx.size() >= 2) {                              //X
            glBegin(GL_LINE_STRIP);//开始绘制线段，依次添加顶点坐标
            glTranslatef(-m_isize, -m_isize, -m_isize);
            glColor3f(1, 0, 0);//置颜色为红色

     //Y
            glBegin(GL_LINE_STRIP);
            glTranslatef(-m_isize, -m_isize, -m_isize);//对每个轴上的标签进行平移，以适应场景中的位置
            glColor3f(0, 1, 0);

            glVertex3f(n2_vetorx[0], n2_vetorz[0], n2_vetory[0]);
            glEnd();
            glFlush();
        }

        double a3[3]= {0.0,0.0,0.5};
        vector<double> n3_vetorx(a3,a3+3);
        double b3[3]= {0.0,0.0,0.0};
        vector<double> n3_vetory(b3,b3+3);
        double c3[3]= {12.75,13.00,13.25};
        vector<double> n3_vetorz(c3,c3+3);
        if (n3_vetorx.size() >= 2) {                              //Z
            glBegin(GL_LINE_STRIP);
            glTranslatef(-m_isize, -m_isize, -m_isize);
            glColor3f(0, 0, 1);

            glVertex3f(n3_vetorx[2], n3_vetorz[0], n3_vetory[0]);
            glVertex3f(n3_vetorx[0], n3_vetorz[0], n3_vetory[0]);
            glVertex3f(n3_vetorx[2], n3_vetorz[2], n3_vetory[0]);
            glVertex3f(n3_vetorx[0], n3_vetorz[2], n3_vetory[0]);


            glEnd();
            glFlush();
        }
}

//用于处理鼠标滚轮事件和鼠标按下事件
//用户通过鼠标滚轮来控制场景的缩放效果
void OpenGLWindow::wheelEvent(QWheelEvent *event)//处理鼠标滚轮事件
    update();//实现场景的缩放效果。调用 update() 来重新绘制场景
}

void OpenGLWindow::mousePressEvent(QMouseEvent *event)//处理鼠标按下事件。当用户按下鼠标按钮时，会触发这个函数
void OpenGLWindow::mouseMoveEvent(QMouseEvent *event)


//绘制OpenGL中的网格
void OpenGLWindow::GLGrid(float pt1x, float pt1y, float pt1z, float pt2x, float pt2y, float pt2z, int num)

{
    const float _xLen = (pt2x - pt1x) / num;
    const float _yLen = (pt2y - pt1y) / num;
    const float _zLen = (pt2z - pt1z) / num;
    glLineWidth(0.01f);
    glLineStipple(1, 0x0303);//线条样式

    glBegin(GL_LINES);
    glEnable(GL_LINE_SMOOTH);

    int xi = 0;
    int yi = 0;
    int zi = 0;
    //绘制平行于X的直线
    for (zi = 0; zi <= num; zi++) {
        float z = _zLen * zi + pt1z;
        for (yi = 0; yi <= num; yi++) {
            float y = _yLen * yi + pt1y;
            glVertex3f(pt1x, y, z);//指定每个线段的两个端点坐标，从而构成直线段
            glVertex3f(pt2x, y, z);

        }
    }
    //绘制平行于Y的直线
    for (zi = 0; zi <= num; zi++) {
        float z = _zLen * zi + pt1z;
        for (xi = 0; xi <= num; xi++) {
            float x = _xLen * xi + pt1x;
            glVertex3f(x, pt1y, z);
            glVertex3f(x, pt2y, z);
        }
    }
    //绘制平行于Z的直线
    for (yi = 0; yi <= num; yi++) {
        float y = _yLen * yi + pt1y;
        for (xi = 0; xi <= num; xi++) {
            float x = _xLen * xi + pt1x;
            glVertex3f(x, y, pt1z);
            glVertex3f(x, y, pt2z);
        }
    }
    glEnd();
}


//用于绘制理论轨迹
void OpenGLWindow::updateTheroyTraj()
//绘制实际轨迹
void OpenGLWindow::updatePracticeTraj()

```























#####  `OpenGLWindow` 的类

这段代码展示了一个名为 `OpenGLWindow` 的类，该类继承自 `QGLWidget` 并用于创建OpenGL窗口。它用于显示3D图形并处理相关的OpenGL绘图和事件。

```c++
using namespace std;  // 使用标准C++命名空间
class OpenGLWindow : public QGLWidget
{
    Q_OBJECT  // 使用Qt元对象宏，启用Qt的信号和槽机制
public:
    explicit OpenGLWindow(QWidget *parent = nullptr);  // 构造函数
    ~OpenGLWindow();  // 析构函数
    void GLGrid(float pt1x, float pt1y, float pt1z, float pt2x, float pt2y, float pt2z, int num);  // 绘制网格的函数

private:
    void LabelXYZ();  // 标注坐标轴的函数

protected:
    void initializeGL();  // 初始化OpenGL上下文
    void resizeGL(int w, int h);  // 在窗口大小变化时调整OpenGL视口
    void paintGL();  // 绘制OpenGL场景
    void mousePressEvent(QMouseEvent *event);  // 处理鼠标按下事件
    void mouseMoveEvent(QMouseEvent *event);  // 处理鼠标移动事件
    void wheelEvent(QWheelEvent *event);  // 处理鼠标滚轮事件

private:
    void updateTheroyTraj();  // 更新理论轨迹
    void updatePracticeTraj();  // 更新实际轨迹

    // 一些私有成员变量，用于存储不同数据
};
这个类似乎定义了一个用于展示3D图形的OpenGL窗口，其中包含了许多用于初始化、绘制、处理事件等的函数。这个类可能会在Qt框架中使用，用于创建一个3D可视化的窗口，并通过继承自 QGLWidget 来实现与OpenGL的交互。
```





