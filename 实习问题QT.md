## 喷浆：



### Qt多线程组件会用到哪些、实现

- 在喷浆机械臂项目中，一个**线程收集传感器数据**，在另一个**线程逆运动学计算**，在第三个**线程进行实时的轨迹规划**，同时**主线程用于处理用户界面的响应**。
- 在实现多线程时，要注意**线程安全和资源竞争**的问题。特别是在**更新UI或访问共享数据**时，需要使用**信号和槽**或其他线程同步机制来保证安全。Q**t 的信号和槽机制是线程安全的**，这意味着你可以在**不同的线程之间发送信号**，Qt 会负责跨线程的通信。
- 多线程是一个常见的需求，用来处理**实时传感器数据采集、机械臂控制、用户界面响应**等多个并行任务。Qt 实现多线程功能：

1. **QThread**： `QThread`是 Qt 提供的用于多线程编程的基础类。通过继承`QThread`并重写其`run()`方法，**在新线程中执行任务**。这适用于**长时间运行或需要频繁更新的任务**。

   ```c++
   class WorkerThread : public QThread {
       Q_OBJECT
       void run() override {
           // 你的长时间运行的任务或循环
           emit resultReady(someResult);
       }
   signals:
       void resultReady(const QString &s);
   };
   ```

2. **QtConcurrent**： `QtConcurrent`模块运行函数或方法**作为并发任务**。它非常适合用于没有必要直接使用线程的并发操作。

   ```c++
   #include <QtConcurrent>
   void myFunction() {
       // 需要并发执行的代码
   }
   // 在某处调用
   QFuture<void> future = QtConcurrent::run(myFunction);
   ```

3. **QObject::moveToThread()**： 你可以创建一个`QThread`对象，并将`QObject`及其子类的实例移动到这个线程中。使用`moveToThread()`方法**可以将对象的所有槽函数的执行移动到新线程**。

   ```c++
   QThread *thread = new QThread;
   Worker *worker = new Worker;
   worker->moveToThread(thread);
   connect(thread, &QThread::started, worker, &Worker::process);
   connect(worker, &Worker::finished, thread, &QThread::quit);
   connect(worker, &Worker::finished, worker, &Worker::deleteLater);
   connect(thread, &QThread::finished, thread, &QThread::deleteLater);
   thread->start();
   ```

4. **QThreadPool**： `QThreadPool`管理一组线程，可以重用这些**线程来运行任务**。这适用于执行大量的短期任务。任务是通过继承`QRunnable`并实现其`run()`方法来定义的。

   ```c++
   class MyTask : public QRunnable {
       void run() override {
           // 任务代码
       }
   };
   // 添加任务到线程池
   QThreadPool::globalInstance()->start(new MyTask);
   ```



### Qt信号和槽：

Qt 的信号和槽（Signals and Slots）机制在多线程环境中体现得非常明显，因为它提供了一种安全的方式来进行跨线程的通信。

在**单线程应用程序**中，信号和槽用于**对象**之间的通信。在**多线程应用程序**中，信号和槽同样可以用来在**不同的线程**之间传递信息，Qt 框架会自动处理线程间的同步问题。

当你在一个**线程中发射（emit）信号**，并且该**信号连接到了另一线程中对象的槽**时，Qt 会自动将**信号消息排队到接收对象的事件循环**中，确保**槽函数在接收对象所属的线程中被调用**。这种方式称为队列连接（Queued Connection）。

以下是几个关键点，它们概述了信号和槽在多线程中的体现：

1. **线程安全的通信**：
   - 信号和槽机制是线程安全的，可以用于将数据从一个线程传递到另一个线程，无需担心竞态条件或锁问题。
2. **队列连接（Queued Connection）**：
   - 当信号和槽跨线程工作时，默认情况下，Qt 使用队列连接。这意味着当一个线程向另一个线程发射信号时，该信号会被放入事件队列中。接收线程会在处理完当前事件后，按顺序处理队列中的信号。
3. **直接连接（Direct Connection）**：
   - 如果你选择直接连接，槽将在信号被发射的那个线程上直接执行，而不管接收对象属于哪个线程。这种方式需要开发者自己确保线程安全。
4. **自动切换连接类型**：
   - 当连接发生在同一个线程内时，Qt 使用直接连接。当涉及到不同线程时，Qt 自动转换为队列连接。
5. **事件循环**：
   - 每个线程可以有自己的事件循环，允许槽函数在适当的上下文中执行。
6. **信号连接的灵活性**：
   - 你可以在运行时连接或断开信号和槽，这使得动态多线程编程变得简单。

下面是一个简单的跨线程信号和槽的例子：

```c++
class Producer : public QObject {
    Q_OBJECT
public:
    void produce() {
        emit produced("This is a message from another thread");
    }
signals:
    void produced(const QString &message);
};
class Consumer : public QObject {
    Q_OBJECT
public slots:
    void consume(const QString &message) {
        qDebug() << "Message received in consumer thread:" << message;
    }
};
// 在主函数中
Producer *producer = new Producer();
Consumer *consumer = new Consumer();
QThread *thread = new QThread();
consumer->moveToThread(thread);
// 连接信号和槽
connect(producer, &Producer::produced, consumer, &Consumer::consume);
thread->start();
producer->produce(); // 这将导致在consumer线程中调用 consume 槽
```

在这个例子中，当`produce()`方法被调用时，它将在`producer`对象所在的线程中发射`produced`信号。然后，由于`Consumer`对象被移动到了另一个线程，接收到的信号将被排队到该线程的事件循环中，`consume`槽函数将在那里被调用。







### Qt组件：

1. **GUI模块**:
   - `QWidget`: 这是Qt中所有**用户界面对象的基类**。你提到通过继承`QWidget`并重新实现虚拟事件处理程序来创建自定义窗口小部件。
   - `QOpenGLWidget`: 如果你在GUI中集成了OpenGL，那么可能会用到这个类，它提供了一个用于**渲染OpenGL图形的窗口部件**。
   - 信号与槽机制: 通过`QObject::connect()`实现信号和槽的连接。
2. **OpenGL模块**:
   - 可能使用了`QOpenGLContext`, `QOpenGLBuffer`, `QOpenGLShaderProgram`等类来实现OpenGL的渲染和操作。
3. **通讯模块**:
   - 如`QTcpSocket`, `QUdpSocket`等，或者如果你是通过串口通信，可能用到了`QSerialPort`。
   - **对于CAN通信，Qt没有直接的支持，你可能使用了第三方库或者硬件厂商提供的SDK**。
4. **Eigen库**：用于矩阵运算。
5. QThread线程库：



### CAN节点构成、数据传输流程、通信运用

**CAN节点构成**

- **CAN收发器**: 负责将差分信号转换为TTL电平信号，或者将TTL电平信号转换为差分信号。
- **CAN控制器**: 接收并传输TTL电平信号，与MCU（微控制单元）通信。
- **MCU**: 处理CAN控制器传来的数据，并执行相应的操作。

**数据传输流程**

1. **发送数据**:
   - MCU准备好要发送的数据和标识符，并将其发送到CAN控制器。
   - CAN控制器将数据组成规定的报文格式，并在获得总线访问权限后，通过CAN收发器将报文发送到CAN总线上。
2. **接收数据**:
   - 网络中的所有节点（包括发送节点）都会接收到这个报文。
   - 每个节点的CAN控制器检查报文中的标识符，确定是否需要处理这个报文。
   - 如果报文是发给该节点的，MCU会对数据进行处理。

**在项目中的具体应用**

1. **传输传感器数据**: 控制器读取关节传感器的数据，并通过CAN总线发送给上位机。上位机接收数据，并对其进行处理。
2. **遥控器手柄信号传输**: 控制器读取遥控器的数据（如按钮状态、摇杆位置等），并通过CAN总线发送给上位机。
3. 上下位机通信
   - 上位机根据需要发送控制命令和配置信息到控制器。
   - 控制器将运行状态、警报和其他反馈信息发送回上位机。

**通信模块的实现**

- **发送接口函数**: 将待发送的CAN消息编码并添加到发送队列中，定时发送到总线上。
- **接收接口函数**: 将接收到的数据放入接收队列中，缓存并按顺序处理接收到的CAN数据帧。











### 上下位机通讯模块

在喷浆机械臂的系统中，上位机（PC或控制器界面）与下位机（机械臂控制系统）之间的CAN通讯通常涉及以下组件：

1. **硬件接口**：上位机需要有一个硬件接口（如USB-CAN适配器或内置的CAN卡）来实现物理层的连接。
2. **驱动程序**：操作系统需要识别硬件接口，这通常通过安装适当的驱动程序来实现。厂家提供的SDK包
3. **通讯库**：上位机的软件开发中，需要使用特定的库来实现CAN协议的数据发送和接收。

**实现通讯模块**

下面是上位机与下位机通讯模块实现的一般步骤：

**步骤1: 硬件选择与配置**

确保上位机有适合的CAN接口硬件。对于下位机，通常是CAN模块或微控制器内置的CAN接口。

**步骤2: 驱动与库的安装**

- **在上位机上安装CAN接口的驱动程序。**
- **如果是Windows，可能需要一个特定厂商的CAN接口库。**
- 如果是Linux，可以使用SocketCAN。
- 对于Qt应用程序，可以使用`Qt SerialBus`模块，它支持SocketCAN和某些特定的CAN适配器。

**步骤3: 编写CAN到上位机软件**

- 在Qt中，添加`Qt SerialBus`模块到项目中。
- 使用`QCanBus`类来创建CAN设备，并配置比特率和其他必要参数。
- 使用`QCanBusFrame`来构造CAN消息，设置标识符和数据。
- 发送和接收CAN帧，处理接收到的数据。

**步骤4: 编写CAN到下位机软件**

- 配置下位机的CAN接口，设置相应的过滤器和中断（如果有的话）。
- 编写接收中断处理函数，以处理上位机发送的数据。
- 编写发送函数，将下位机的数据如传感器读数发送到上位机。

**步骤5: 编码解码实现**

- 定义数据的封装（编码）和解封装（解码）格式。
- 上位机软件需要包含将数据封装为CAN帧的逻辑。
- 下位机软件需要能够解析来自上位机的CAN帧，并按照定义的格式提取数据。

**示例：Qt 上位机CAN通讯代码**

```c++
#include <QCanBus>
#include <QCanBusFrame>

// 创建CAN设备
QString canInterfaceName = "can0"; // 例子中使用SocketCAN
QCanBusDevice *device = QCanBus::instance()->createDevice("socketcan", canInterfaceName);
device->connectDevice();

// 构建CAN帧
QCanBusFrame frame;
frame.setFrameId(0x123); // CAN标识符
QByteArray payload;
// ... 填充负载数据 ...
frame.setPayload(payload);

// 发送CAN帧
device->writeFrame(frame);

// 接收CAN帧
connect(device, &QCanBusDevice::framesReceived, this, [&]() {
    while (device->framesAvailable()) {
        const QCanBusFrame frame = device->readFrame();
        // ... 处理接收到的帧 ...
    }
});
```

在实现CAN通讯时，需要注意数据的同步性和实时性，确保上位机和下位机能够及时处理数据，并且能够正确地处理错误和异常情况。

对于下位机，如果使用的是通用微控制器，你将需要使用对应的硬件抽象层（HAL）或直接通过寄存器来操作CAN控制器。



### 机器人正逆运动学

**正运动学（Forward Kinematics, FK）**指的是给定关节（驱动器）的位置，计算机器人的手臂（或末端执行器）的位置和方向。

**逆运动学（Inverse Kinematics, IK）**是指给定机器人末端执行器的位置和方向，计算实现该位置和方向所需的关节角度。

#### 正运动学的步骤：

1. 定义机器人的几何参数，如关节轴线、关节位置等。
2. 建立每个关节的坐标系。
3. 使用D-H（Denavit-Hartenberg）参数方法，计算每个关节相对于前一个关节的变换矩阵。
4. 连乘各个关节的变换矩阵，得到机器人末端执行器相对于基座的变换矩阵。
5. 从最终的变换矩阵中提取末端执行器的位置和姿态。

#### 逆运动学解析法步骤：

1. **提取末端位置和姿态信息**：从期望的末端执行器的位置和姿态信息出发。
2. **解析位置**：基于机器人的几何结构，解析计算出末端执行器位置所对应的关节角度。这一步可能涉及到三角函数、向量和几何学的计算。
3. **解析姿态**：基于机器人的结构和先前计算出的位置关节角度，解析计算出末端执行器姿态对应的关节角度。
4. **检查解的有效性**：不是所有的数学解都是物理上可行的。需要检查解是否在机器人关节的运动范围内。
5. **选择解**：如果存在多个解，需要根据某种标准（如最小运动原则、最接近当前位置等）选择最佳解。



步骤：

1. **建立坐标系**：在机器人的每一个关节和末端执行器上建立坐标系。常见的坐标系有世界坐标系、基座坐标系、各关节坐标系和工具坐标系。
2. **分析机构几何关系**：根据机器人的结构，分析各个关节、连杆之间的几何关系。这包括长度、角度以及它们之间的相互关系。
3. **建立方程**：使用几何学的知识，建立关于关节变量的方程。这些方程通常包括三角函数、向量运算等数学操作。
4. **求解方程**：使用数学工具求解上一步建立的方程，得到关节变量的值。这可能需要使用代数方法、迭代方法等。
5. **验证解**：求解得到的关节变量需要在机器人的工作范围内，并且要满足机器人运动学的约束条件。需要对求解得到的解进行验证，确保其合理性和准确性。
6. **反解求取**：如果机器人逆运动学存在多解，需要根据实际应用场景或者其他辅助条件来选择最合适的解。

优点

1. **计算效率高**：对于结构简单的机器人，几何法求解逆运动学问题的速度很快。
2. **直观易懂**：几何法依赖于机器人结构的直观几何关系，相对容易理解。

缺点

1. **不适用于复杂机构**：对于结构复杂的机器人，几何法求解起来非常困难，甚至无法应用。
2. **可能存在多解或无解的情况**：几何法求解的解可能不唯一，或者在某些情况下可能没有解。



#### 在Qt中实现逆运动学：

用Qt创建GUI来接收用户输入的目标位置和姿态信息，展示计算结果，并调用后端逻辑（C++类）来执行运动学计算。

设置一个Qt界面调用逆运动学计算函数：

1. **设计GUI**：使用Qt Designer或代码来创建一个用户界面，该界面包含输入末端执行器位置和姿态的输入框，和一个按钮来触发计算。
2. **编写逆运动学算法类**：创建一个C++类来实现上述逆运动学的算法。
3. **连接GUI和逆运动学算法**：在Qt的槽函数中连接按钮信号和算法类的逆运动学函数。
4. **展示结果**：计算完成后，将结果更新到界面上。

以下是一个示例代码框架，假设你已经有了一个逆运动学的解算函数 `calculateIK`：

```c++
// 1. 创建算法类
class KinematicsSolver {
public:
    QVector<double> calculateIK(const QVector3D& targetPosition, const QQuaternion& targetOrientation) {
        // 你的逆运动学计算逻辑
        QVector<double> jointAngles;
        // ... 计算关节角度 ...
        return jointAngles;
    }
};

// 2. 在你的主窗口类中创建槽函数
class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    MainWindow(QWidget *parent = nullptr) : QMainWindow(parent) {
        // 创建UI组件，设置布局等
        // ...
        connect(calculateButton, &QPushButton::clicked, this, &MainWindow::onCalculateClicked);
    }

public slots:
    void onCalculateClicked() {
        QVector3D targetPosition; // 假设这是从UI获取的
        QQuaternion targetOrientation; // 假设这是从UI获取的
        KinematicsSolver solver;
        QVector<double> jointAngles = solver.calculateIK(targetPosition, targetOrientation);
        // 更新UI展示结果
        // ...
    }
};
```











### CAN通信协议格式，编码解码怎么做

CAN通信协议是一种用于多个主机设备之间通信的协议，尤其是在汽车电子等领域中。它允许设备在没有主机计算机的情况下互相通信。CAN协议由ISO 11898标准定义，并规定了电气特性和数据帧的格式。

#### CAN数据帧格式

一个标准的CAN数据帧包含以下部分：

1. **起始位**（Start of frame）: 1位标志，表示帧的开始。
2. **标识符**（Identifier）: 标准帧是11位，扩展帧是29位，标识符决定了消息的优先级。
3. **远程传输请求**（RTR，Remote Transmission Request）: 1位标志，区分数据帧（0）和远程请求帧（1）。
4. **IDE位**（Identifier Extension）: 1位标志，区分标准帧（0）和扩展帧（1）。
5. **r0位**（Reserved bit）: 保留位，用于将来的扩展。
6. **DLC**（Data Length Code）: 4位标志，指示数据字段的长度，最多为8字节。
7. **数据字段**（Data）: 最长8字节，包含传输的消息。
8. **CRC**（Cyclic Redundancy Check）: 15位CRC序列，用于错误检测。
9. **CRC分隔符**（CRC delimiter）: 1位固定为1的标志。
10. **ACK插槽**（ACK slot）: 发送者保留1位用于接收者发送确认。
11. **ACK分隔符**（ACK delimiter）: 1位固定为1的标志。
12. **结束位**（End of frame）: 7位固定为1的标志，表示帧的结束。

####  CANopen 的PDO

PDO 在 CANopen 通信协议中代表的是过程数据对象（Process Data Object）。它是一种数据对象，用于在 CANopen 网络中的节点之间传输实时数据，比如传感器读数或执行器位置。

PDO 的主要特点包括：

1. **高效性**：PDO被设计为一种非常高效的数据传输方式。一个CAN帧中可以合并多个数据块，从而减少开销，最大化数据吞吐量。
2. **周期性和事件驱动传输**：PDO可以配置为定期传输（周期性）或响应事件（事件驱动）。例如，传感器可能在检测到某个阈值之外的变化时传输其数据。
3. **映射**：PDO内的数据是根据PDO映射参数组织的。这些参数定义了哪些数据（来自对象字典）包括在PDO中，以及它们的顺序。
4. **通信参数**：PDO通信参数定义了PDO如何在网络中传输。这包括PDO是同步传输还是异步传输，传输类型，以及禁止时间。
5. **同步和异步**：PDO可以同步传输，响应总线上的SYNC消息，确保所有节点同时采取行动。它们也可以异步传输，响应内部事件或外部请求。
6. **传输类型**：PDO有多种传输类型，这些类型决定了何时发送PDO，如基于定时器（周期性），远程请求，或事件发生后。
7. **多个PDO**：节点可以使用多个PDO来传输不同类型的数据或优先级。每个PDO在总线上都有一个唯一的标识符。
8. **快速数据交换**：因为PDO可以在没有握手过程的情况下发送，它们适用于快速和频繁的数据交换，这对于实时控制应用是至关重要的。



#### CANopen概念、实现步骤

- **对象字典（Object Dictionary）**: CANopen设备中的一个参数表，包含了设备的所有可配置参数和变量。
- **SDO（Service Data Object）**: 用于传输单个对象字典条目的通讯对象。
- **PDO（Process Data Object）**: 用于传输实时过程数据的通讯对象，可以是周期性的也可以是事件驱动的。
- **心跳和节点监控**: 用来监控网络中设备的状态。

实现步骤

**步骤1: 确定硬件和软件需求**

- 确保上位机和下位机硬件都支持CAN接口。
- 选择合适的软件库，比如在上位机可以使用CANopenSocket、CANFestival或者其他支持CANopen协议的库。

**步骤2: 设计对象字典**

- 定义上位机和下位机需要交换的数据，并在对象字典中分配索引和子索引。

**步骤3: 初始化和配置CANopen网络**

- 配置好CAN硬件接口，设置比特率等参数。
- 初始化CANopen栈，包括SDO、PDO、心跳等。
- 设置每个节点的节点ID和通讯参数。

**步骤4: 实现SDO通讯**

- 上位机通过发送SDO请求来读写下位机的对象字典。
- 下位机收到SDO请求后，执行对应的读写操作。

**步骤5: 实现PDO通讯**

- 配置PDO映射和传输参数。
- 上位机和下位机根据PDO配置周期性地发送和接收实时数据。

**步骤6: 实现心跳和错误处理**

- 设置心跳生产者和消费者，以监控网络中的节点状态。
- 实现错误控制逻辑，处理通讯错误和节点状态变化。

**示例代码**

网络管理和具体的CANopen协议栈实现。以下是一个非常高级的伪代码示例，用于说明上位机如何使用CANopen来读取下位机对象字典中的一个参数：

```c++
// 上位机
#include <CANopen.h>
// 初始化CANopen
CANopen_Init(canInterfaceName);
// 读取下位机的对象字典参数
uint32_t objectId = 0x4000; // 对象字典中的索引
uint8_t subIndex = 1;       // 子索引
uint8_t nodeId = 0x01;      // 下位机的节点ID
uint8_t data[4];            // 用于存放读取的数据
size_t size = sizeof(data);
CANopen_ReadSDO(nodeId, objectId, subIndex, data, &size);
```

在下位机上，您需要配置对象字典，实现SDO服务和PDO传输等，下位机的实现将依赖于具体的CANopen协议栈和硬件平台。



#### 编码和解码

在CAN协议中，编码和解码是指数据的封装和解封装过程。(传感器数据、遥控器数据)

##### 编码（封装）

编码通常发生在数据发送之前。发送者会根据CAN协议的要求**将数据封装成一个CAN帧**。

软件步骤：

1. 确定需要发送的**（传感器和遥控器）****数据和相应的标识符**。
2. 创建一个**CAN帧结构体并填入数据和控制字段**。
3. 计算并添加CRC。
4. 发送帧到CAN总线。

```c++
//构造CANopen帧。
//根据CANopen规范设置帧ID和数据（例如PDO、SDO、心跳等）。
//使用QCanBusDevice的writeFrame方法发送帧。
QCanBusFrame canOpenFrame;
canOpenFrame.setFrameId(CANopenFrameId);  
// 例如PDO的ID
QByteArray payload;  
// 根据CANopen对象字典构造payload
// ... 设置payload为CANopen数据 ...
canOpenFrame.setPayload(payload);
device->writeFrame(canOpenFrame);
```



##### 解码（解封装）

解码则是**接收方对收到的CAN帧**进行解析的过程。

软件解码步骤：

1. 从CAN总线接收数据帧。
2. 检查CRC以确保数据的完整性。
3. 解析帧结构，**提取标识符、DLC和数据**。
4. 根据应用需求处理数据。

```c++
//连接QCanBusDevice的framesReceived信号到一个槽。
//在槽中，使用readFrame读取CAN帧。
//根据CANopen协议解析帧ID和数据。
void MyClass::processReceivedFrames() {
    while (device->framesAvailable()) {
        QCanBusFrame frame = device->readFrame();
        // 解析frame中的ID和数据
        if (isCANopenFrame(frame)) {
            CANopenFrameId id = frame.frameId();
            QByteArray payload = frame.payload();
            // 根据CANopen协议解析payload
            // ...
        }
    }
}
```



##### 示例

在CANopen协议中，PDO**过程数据对象**用于高效传输如传感器数据和遥控器指令这样的实时数据。

###### 下位机（机器人控制器）实现：

下位机需要将**关节数据、拉线传感器数据和遥控器数据**打包到**CAN帧**中，并发送到CAN网络上。这里，我们使用一个16位整数来表示每个传感器的数据，共有六个关节和一个拉线传感器，加上遥控器数据。

**数据帧格式设定（以大端格式为例）：**

- Byte 0-1: 关节1的传感器数据
- Byte 2-3: 关节2的传感器数据
- Byte 4-5: 关节3的传感器数据
- Byte 6-7: 关节4的传感器数据
- Byte 8-9: 关节5的传感器数据
- Byte 10-11: 关节6的传感器数据
- Byte 12-13: 拉线传感器数据
- Byte 14-15: 遥控器数据

**下位机发送逻辑代码：**

```c++
#include <stdint.h>
#include <CAN.h>
void sendSensorData(uint16_t joints[6], uint16_t wireSensor, uint16_t remoteData) {
    uint8_t payload[16];
    // 填充数据到payload数组中，注意大端或小端格式
    for (int i = 0; i < 6; i++) {
        payload[i * 2] = (joints[i] >> 8) & 0xFF; // 高字节
        payload[i * 2 + 1] = joints[i] & 0xFF; // 低字节
    }
    payload[12] = (wireSensor >> 8) & 0xFF;
    payload[13] = wireSensor & 0xFF;
    payload[14] = (remoteData >> 8) & 0xFF;
    payload[15] = remoteData & 0xFF;
    // 创建CAN帧
    CAN_Frame canFrame; 
    // 定义一个CAN_Frame类型的变量canFrame，它将存储CAN帧的各个组成部分。
    canFrame.id = 0x100; 
    // 设置CAN帧的标识符（ID）为十六进制的0x100。在CAN网络中，这个ID用来标识消息的发送者和/或消息的类型。
    canFrame.length = 16; 
    // 设置CAN帧的数据长度为16。注意这里有一个潜在的错误，因为CAN帧的数据字段最大长度为8字节。
    memcpy(canFrame.data, payload, 16); 
    // 将参数payload指向的内存内容复制到canFrame的数据字段中。这里将复制16字节到CAN帧的数据字段，但是正如前面所说，CAN标准规定的最大长度为8字节，所以这可能是不正确的。
    // 发送CAN帧
    CAN_Send(&canFrame);
}
```

###### 上位机（PC）实现：

- 上位机需要从**CAN网络读取CAN帧**，然后**解析出各个关节和传感器的数据**。
- 需要加载相应的**CAN驱动**，并根据你的**CAN设备配置参数**，例如波特率和通道。

**上位机接收逻辑：**

```c++
#include <QCanBus>
#include <QCanBusFrame>
#include <cstdint>
#include <array>

// 假定device是已经配置好并连接的QCanBusDevice对象
void readSensorData(QCanBusDevice *device) {
    while (device->framesAvailable()) { 
        // 检查设备的接收队列中是否有待处理的数据帧可读取
        const QCanBusFrame frame = device->readFrame();  
        // 读取一帧数据
        // 检查这个数据帧是否具有特定的标识符0x100，这通常用于区分不同的数据包或消息类型
        if (frame.frameId() == 0x100 && frame.payload().size() == 16) {
            const QByteArray payload = frame.payload(); 
            // 获取数据帧的载荷（数据部分）

            // 解析数据
            uint16_t joints[6]; // 存储六个关节的数据
            uint16_t wireSensor; // 存储拉线传感器的数据
            uint16_t remoteData; // 存储遥控器的数据

            // 解析关节数据，每个关节数据由2字节组成
            for (int i = 0; i < 6; i++) {
                joints[i] = (static_cast<uint16_t>(payload.at(i * 2)) << 8) | 
                            static_cast<uint8_t>(payload.at(i * 2 + 1));
            }

            // 解析拉线传感器数据
            wireSensor = (static_cast<uint16_t>(payload.at(12)) << 8) | 
                         static_cast<uint8_t>(payload.at(13));

            // 解析遥控器数据
            remoteData = (static_cast<uint16_t>(payload.at(14)) << 8) | 
                         static_cast<uint8_t>(payload.at(15));

            // 处理数据
            // ...
            // 在这部分，你可以将解析的数据传递给其他函数进行处理，比如更新UI，控制机械臂等
        }
    }
}

```

这里，我们假设CAN接口已经配置好，并且`device`对象是连接的`QCanBusDevice`。这个函数应该被绑定到接收到CAN帧的信号或在轮询循环中调用。



##### 编码解码什么做的

- 编码传感器数据，遥控器数据，下位机进行数据解码处理
- 有两个传感器是通过下位机转发因为走的can1，其他走can0所以直接拿（国产两个，大臂和关节6，走同一个can线会掉，所以靠下位机转发）
- 解码就是下位机要进行编码，把有些数据传上来，上位机发的数据需要在下位机解码给相应接口使用。

**编码设计：**

1. **定义消息结构**：首先，要明确定义CANopen消息的结构，包括消息类型、对象字典索引、数据长度等信息。
2. **构建消息帧**：将消息的各个字段填充到CAN消息帧中。这通常包括消息的ID、数据长度、数据和校验位。
3. **设置通信参数**：根据通信需求，设置CAN消息的通信参数，如消息优先级、数据传输速率等。
4. **编码数据**：将消息中的数据编码为字节序列，通常使用大端或小端字节序，具体取决于CANopen协议规范。
5. **计算校验和**：计算并添加校验和，以确保消息的完整性。通常使用CRC或其他校验算法。
6. **发送消息**：使用CAN通信硬件将消息发送到总线上。

**解码设计：**

1. **接收消息**：从CAN总线接收消息。
2. **验证消息**：检查接收到的消息的校验和，以确保消息的完整性。
3. **解析消息帧**：从消息帧中提取CANopen消息的各个字段，包括消息类型、对象字典索引、数据长度等。
4. **解码数据**：将消息中的字节序列解码为可用的数据结构。要考虑字节序和数据类型的转换。
5. **处理消息**：根据消息类型和对象字典索引，执行适当的处理操作。这可能包括读取、写入、配置设备或执行其他控制操作。
6. **错误处理**：在解码和处理过程中，要处理可能出现的错误，如消息格式错误、校验失败等。
7. **应答消息**：根据消息类型和操作结果，生成适当的应答消息，并将其发送回总线上，以便与其他设备进行通信。









## 控制系统方案

**逆运动学求解、轨迹规划、运动控制**

该原型机臂架采用**六自由度机构驱动喷嘴运动**，液压执行机构由**电液比例多路阀控制**，由**操纵工用遥控器**通过 **PLC 控制器型电液比例多路阀**发出操控信号量，实现开环控制。本项目增设臂架运动参数检测系统，通过上位机进行运动闭环控制建模、轨迹规划以及控制系统设计，实现自动控制。

#### 液压系统

机械臂七个自由度运动，即整体臂架的回转、大臂的仰俯、小臂的仰俯、伸缩臂的伸缩，喷头垂直于伸缩臂中心轴的 360°回转、及喷头水平 240°回转、以及 喷嘴 8°的刷动，都是**液压驱动**，其中整体臂架的回转由液压马达和减速机组成的液压回转装置驱动，大、小臂的仰俯动作以及伸缩臂的伸缩，均由液压缸驱动，而喷头的垂直、水平旋转则分别由 360°、240°螺旋油缸驱动，上述 **6 轴自由度的运动均由电液比例流量-方向**符合控制阀进行控制，而喷嘴的刷动则不需人工干预，由**液压马达通过凸轮机构产生循环摇摆运动**。

#### 电控系统

湿喷台车的电气系统采用 **CAN-BUS 总线**技术、基于嵌入式系统的工程机械控制器为核心、是实现机电液一体化控制的新型控制系统，主要负责对**液压控制阀、整机、发动机和液压泵的控制**。

#### **机械臂运动控制逻辑：**

通过机械臂采样获取**隧道轮廓信息**，利用原控制器发射末端喷嘴运动方向控制指令，上位机会生成该方向上的运动轨迹，然后通过逆运动学计算关节角度，再发送给中间运动控制器控制机械臂的运动.

- 人工操作遥控器**发出机械臂各关节运动指令**
- 遥控器发射端调制并发射信号
- 遥控器接收端接收并解调信号
- **=上位机进行轨迹规划和逆运动学解算得到各关节控制量**
- **中间控制器发送控制指令**
- PLC控制器A/D、D/A转换信号
- **电液比例阀**执行动作
- 各油缸马达运动
- 机械臂各关节运动
- 完成喷嘴末端运动路径人工操作
  
  

### 传感器选型

- 检测机械臂各关节位姿信息，用于控制器输出信号运算
- 角度传感器——测量臂杆的旋转角度及俯仰角度，**旋转编码器5个**；
- 直线位移**拉伸传感器1个**——测量臂杆的伸缩长度。
- **数据传输方式 ----- CAN 信号传输**
- **加装六个传感器：大臂旋转编码器、大臂俯仰旋转编码器、小臂俯仰编码器、小臂伸缩拉线传感器、喷嘴俯仰传感器、喷嘴正逆转传感器。**







### 喷浆操控模式

- **手动模式：**通过遥控器手柄操作六个关节，**每个关节是独立运动**的，施工人员一般每次只控制一个关节的运动，以便直接观察运动的趋势。
- **半自动模式：**该模式下**直接操作机械臂末端喷头的运动**，其运动参数包含**三个移动自由度和三个转动自由度**，半自动模式下只控制三个移动自由度和两个转动自由度。**半自动模式需要借助遥控器发射运动信号**。通过**上位机软件选择半自动模式**，原遥控器的指令就会发生变化。
- **全自动模式：**首先进行**坐标系的标定**，然后完成隧道轮廓点的采样生成**隧道拟合轮廓曲线**，再设置**自动喷浆参数**，最后仿真并验证生成的**理论轨迹**是否合理。如果轨迹是合理的，则将**轨迹发送至下位机**执行，如果不合理则重新设置参数生成新的轨迹。

### 硬件和软件

- 硬件包含了工控机、控制器、传感器。
- 软件包含了上位机控制软件和下位机控制程序。

#### **硬件：**

- **工控机**是研华嵌入式工控机ARK-3500，**运动控制器**是三一控制器 SYMC-92X。**编码器**是德国博思特 IXARC 系列。
- **工控机**主要负责**算法的运行并输出轨迹规划**的结果。
- **模块间的主要通信方式是 CAN 总线**，控制器支持 CAN 网络。
- 新增的**硬件模块计算控制指令**，然后发送给原控制器执行。
- **传感器的信号**由新加装的**运动控制器**接收。水平仪可以检测车身的倾斜状态。

![喷浆硬件图](../../%25E6%25A1%258C%25E9%259D%25A2/%25E8%2587%25AA%25E5%25B7%25B1%25E6%2595%25B4%25E7%2590%2586/%25E5%259B%25BE%25E7%2589%2587/%25E5%2596%25B7%25E6%25B5%2586%25E7%25A1%25AC%25E4%25BB%25B6%25E5%259B%25BE.png)

#### 软件：

软件系统包含了上位机软件和下位机程序。

- 上位机软件主要负责**轨迹规划**。
- 下位机程序主要负责**运动控制**。

##### **上位机软件功能：**

- **逆运动学模块**：提供**正向运动学计算和逆向运动学解算**。
- **轨迹规划模块**：根据运动路径参数生成一条可执行的轨迹。
- **三维仿真和参数可视化模块**：根据生成的理论轨迹控制虚拟模型运动，也可以在机械臂**运动时根据传感器传回的关节参数实时更新虚拟模型**；同时会**实时显示每个关节当前的变化曲线**和机械臂末端喷头的运动轨迹。
- **坐标系标定模块**：确定隧道坐标系、车辆坐标系、机械手坐标系之间的关系。
- **传感器标定模块**：建立传感器的值和实际关节角度的关系。
- **隧道采样模块**：通过机械臂末端获取采样点，拟合隧道轮廓曲线。
- **通信模块**：建立上位机和下位机之间通信，接收传感器数据和发送目标关节角度。



**上位机软件操作：**

自动控制模式操作流程：

- 开启 CAN->传感器标定->坐标系标定->选择全自动模式->**设置喷浆参数和机械臂的初始关节角**(看面板右侧的关节角值设置)->选择参数设置完成->仿真->启动。

辅助末端模式操作流程：

- 开启CAN->传感器标定->坐标系标定->选择 XYZ 模式->操作遥控器。

















##### 下位机程序功能：

- **传感器数据处理模块**：将传感器传回的数据进行解码。
- **遥控器信号处理模块**：将遥控器的数据进行解码。
- **运动控制模块**：包含**手动、半自动、全自动**三种控制模式；
- 在手动模式下，接收遥控器信号直接转发给原车载控制器。
- 在半自动模式下，**接收遥控器信号并判断运动方向**，再将**方向信号发送给上位机，上位机计算好关节变量后**发送给下位机控制机械臂的运动。
- 全自动模式下，通过**上位机生成运动轨迹后下发给运动控制器**，然后控制机械臂的运动

下位机程序有两部分，一部分是**原车载控制器**的，一部分是**外挂控制器**的；都调成调试模式。

- 工控机监测**外挂控制器的变量信息**，主要包括**操作模式、关节传感器的值、接收的上位机的关节角值**、关节停止运动的变量、（在辅助末端操作模式下，监测各个方向的变量）；
- 另外设置一台笔记本电脑监测原车载控制器的变量，主要是**控制关节的几个变量**。









![软件](../../%25E6%25A1%258C%25E9%259D%25A2/%25E8%2587%25AA%25E5%25B7%25B1%25E6%2595%25B4%25E7%2590%2586/%25E5%259B%25BE%25E7%2589%2587/%25E8%25BD%25AF%25E4%25BB%25B6.png)

![上位机软件界面](../../%25E6%25A1%258C%25E9%259D%25A2/%25E8%2587%25AA%25E5%25B7%25B1%25E6%2595%25B4%25E7%2590%2586/%25E5%259B%25BE%25E7%2589%2587/%25E4%25B8%258A%25E4%25BD%258D%25E6%259C%25BA%25E8%25BD%25AF%25E4%25BB%25B6%25E7%2595%258C%25E9%259D%25A2.png)

上位机软件界面





## 六自由度机械臂运动学模型

喷浆机械臂具有 6 个自由度，前面 4 个自由度控制末端喷头的位置，但是引入了冗余自由度，通过结合喷浆机械臂的运动轨迹以及其控制原则给出了合理的约束，采用**二连杆机械臂模型**求解了 **6 自由度**的喷浆机械臂的逆运动学，求解过程简洁高效，不需要依赖大量的矩阵运算，能够快速给出解，因此可以用于实时控制。



- 
- 针对**逆运动学**求解提出约束关节的解析法求解存在冗余的喷浆机械臂，根据末端执行器的位姿求解各关节的变化量。



### 机械臂运动学模型

利用 **DH 建模法**构建喷浆机械臂的坐标系，写出 DH 参数，在坐标系中添加了喷头坐标系e，用来描述目标位姿与受喷面的角度关系和距离。两个移动关节被合并到一起成为一个关节用坐标系 4 。

### 正运动学求解

- 机械臂的正运动学可通过 D-H 法建立，建立各个关节的坐标系，通过**齐次坐标转换**得到该机械臂的运动学方程，经过矩阵变换即可计算出末端执行器的位姿。
- D-H 法是机械臂运动学参数化方法，它使用四个参数来描述相邻连杆之间的转动和平移关系，即连杆长度a、绕 Z 轴旋转的角度α、在 Z 轴上的平移量d以及相邻连杆的夹角。



### 逆运动学求解

#### 几何法

- **正向运动学公式**：0-6T 从坐标系0到坐标系6的变换矩阵。
- **决定末端位置的是前面 4 个关节**，但是由于存在冗余自由度，这里有 3 个已知参数，可以建立 3 个方程，但是有四个未知数，直接根据公式求解的方式是无法解出的。通过喷浆轨迹分析**结合几何法**来求解**前面四个关节角度**，并利用**正向运动学公式通过分离变量**的方式求解关节 5 和关节 6。
- 关节 2 和关节 3 被描述成**平面二连杆模型**。
- 通过在这个模型下的(![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps1.png))求解出关节角度值。
- 通过末端喷头在X-Y平面内的值就可以**求出关节角1**
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps2.png)
- 分离变量角度1，**求出关节角度5，6**，
- 确定末端喷头位置的四个关节变量和末端喷头的位置可以建立函数关系
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps3.png)
- 确定末端喷头的位置只需要3个关节角，这里有4个关节角，引入了冗余自由度，下面通过分析**喷浆机械臂的运动轨迹来添加约束使得方程能够被求解**。但是这里先给出没有添加约束条件的关节角2和关节角3的计算公式：
- **根据几何法求解关节2、关节3角度值**
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps4.png)
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps5.png)



#### 解析法

- 使用约束关节法进行喷浆机械臂逆运动学求解，通过**已知末端执行器坐标系位姿矩阵T**，求解出![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps7.png)的值。
- 由于喷浆机械臂的![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps8.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps9.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps10.png)存在冗余关节，如果直接用解析法求解，会出现多解或无穷解。求解![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps11.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps12.png)、![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps13.png)时，通过末端执行器所处三维空间坐标为![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps14.png)，对特定关节进行约束，达到准确求解的目的。
- 利用约束关节的解析法和工作空间的划分获得最少运动关节数的最优解。



1. **定义机械臂结构：**
   - 确定机械臂的结构，包括每个关节的类型、长度，以及坐标系的选择。
2. **建立坐标系：**
   - 在每个关节处建立坐标系，通常选择DH（Denavit-Hartenberg）参数描述。
3. **描述末端执行器的位姿：**
   - 根据机械臂的坐标系，描述末端执行器在全局坐标系中的位姿，通常使用平移矢量和旋转矩阵或四元数。
4. **编写运动学方程：**
   - 利用机械臂的运动学模型，编写表示末端执行器位姿与关节角度之间关系的方程组。这可以使用转换矩阵和运动学方程来完成。
5. **解方程组：**
   - 将得到的方程组进行求解，得到关节角度的解。这可能涉及到代数运算和解方程的数学技巧。
6. **验证解的可行性：**
   - 验证计算得到的关节角度是否在机械臂的可行范围内。









## **机械臂轨迹规划**

人工操控的末端喷嘴运动的轨迹是在线生成的，利用传感器信息和遥控器方向确定出下一个位置点。自动控制的末端喷嘴运动的轨迹是离线生成的，利用数学建模的方式，通过采样拟合出隧道轮廓曲线，然后**通过给定初始参数自动生成喷浆轨迹**。



- 末端喷头需要控制两类参数（位置和姿态）来表示它的空间位姿，对于位置参数需要控制 3 个参数(x,y,z)，对于姿态参数需要控制 2 个参数(Roll,Yaw)。
- **人工操控控制和自动控制喷浆**。人工操控控制和自动控制都需要**上位机软件提供轨迹规划功能**。人工操控控制是一种**在线轨迹生成方式**，而自动控制是**离线轨迹生成**方式。自动控制下的轨迹规划需要依赖隧道的几何轮廓曲线，需要针对不同的隧道生成相应的隧道轮廓曲线。
- **曲线拟合的数学模型**
- 根据分析采用三次多项式描述 Y 值，二次多项式描述 Z 值。
- **曲线拟合的计算**
- 采用 Y 为 3 阶多项式、Z 为 4 阶多项式阐述计算拟合曲线以及法向量
- ![img](file:///C:\Users\彭凯\AppData\Local\Temp\ksohtml20920\wps6.png)





### 人工操控末端喷嘴轨迹规划

- 遥控器通过**操作X/Y/Z方向上的摇杆**，发送指令给下位机，**下位机控制移动的速度**，同时**下位机将信息发送给上位机，上位机进行实时的逆运动学解算，然后将控制指令发送给下位机**。当摇杆处于中位时，停止运动。
- 辅助控制下如何生成实时的运动轨迹。辅助控制下的运动轨迹是直线，传感器可以将实时的关节角度传回，上位机通过正向运动学计算出机械臂喷嘴的当前位置，然后判断现在接收的运动方向，从而计算出下一个位置点。



### 自动控制末端喷嘴轨迹规划

- 上位机先计算出**带有位置和速度的轨迹**，然后开启时钟，将关节位置和速度发送给下位机，下位机进行控制，然后再根据**当前时间取得新的插值点**，再发送位置和速度给下位机。
- 通过人工调整喷浆机械臂指定一个初始位置，然后给定隧道轨迹之间的**间距d 和路径的长度 w** 以及**插值步长**，自动轨迹规划程序就可以生成一条**完整的喷浆轨迹**。
- **机械臂是圆弧运动**时，对应 p1->p2->p3 或者 p4->p5->p6。需要借助**空间圆弧轨迹的规划方法**。



### 喷嘴运动轨迹的关节空间轨迹规划

**关节五次多项式插值**

- 在完成喷嘴在三维坐标系轨迹规划，通过逆运动学求得各关节的变化量，此时需要对关节运动点进行**关节空间的插值规划**。机械臂需要在一定时间内完成从一个位置到另一个位置的移动，因此需要控制其运动速度。
- 为了实现这个目标，机械臂通常会采用**插值算法计算其运动轨迹**。**多项式插值**是一种常用的方法，可以通过**构造一个多项式函数**来**逼近实际的运动轨迹**，从而预测机械臂的位置、速度和加速度等运动状态。
- 多项式插值能够保证插值函数在给定的数据点上完全符合实际的运动轨迹。三次和五次多项式是常用的多项式插值方法。
- 根据**喷嘴末端的位姿运动轨迹**，使用**直线插补**，计算出每个位姿点的各个关节值。得到的**六个关节的逆解数据**，采用**五次多项式插值**方法，将轨迹规划后运动量传递给跟踪控制程序。通过CAN 信号**传输各个关节阀口的开度值**给车载控制器，并使机械臂执行操作，以最终到达轨迹终点。







## **PID控制器**

- 实现自动控制来说，其目标是**控制轨迹的位置和速度**。

- 喷浆机械臂**关节1至关节4由液压缸驱动**，**关节5和关节6由电机驱动**。首先建立单关节的液压控制系统数学模型。

- PID+重力补偿是当前主流机械臂的关节 1-关节 4的控制方案。

- 机械臂的运动过程中存在的抖动会对轨迹跟踪精度产生影响，所以控制系统的误差范围大概是 0-10cm。

  

- **液压缸位置控制系统的工作原理**：运动控制器从**上位机获得理论关节角度**，然后**运动控制器发出 PWM 信号**控制比例阀的开口和方向，从而控制液压缸的运动，机械臂实现关节联动，然后通过关节**传感器获取实际关节角度计算误差**，再通过**控制算法调整 PWM 输出**使得油缸的位置满足误差要求，从而实现对液压缸位置的调节。



## **控制软件开发**

逆运动学模块、轨迹规划模块、三维图形仿真模块、通信模块



### 上位机与下位机通信

- 上位机与下位机之间的通讯方式选择了 CAN 总线。工控机和运动控制之间采用 USB 转 CAN 模块。
- CAN 总线是多主机总线。CAN 协议的最大特点之一是取消了传统的站地址编码，而是对通信数据块进行了编码。它使用平衡发送和差分接收数据收发器来驱动总线。
- 工业计算机具有 RS232和USB通讯接口，运动控制器支持CAN网络通讯，两者之间没有直接通讯。







#### CAN原理

- CAN 数据链路层采用**短帧结构**，**每帧为 8 字节**；CAN 信息的**每一帧都有CRC 校验**和其他检错措施；它有效地降低了数据的错误率，并且 CAN 节点出现**严重错误**时，它会**自动关闭**，因此使得总线上的其他节点不受影响。
- CAN 可以在**多主机模式**下工作，并且网络上的任何节点都可以随时主动向网络上的其他节点发送信息，而无需考虑主机和从机。当 CAN 总线上的许多节点同时发送信息时，首先发送**高优先级信息**，推迟低优先级信息。
- CAN 总线只定义了物理层和数据链路层，而 **CANopen** 是基于 CAN 总线的应用层协议。在 CANopen 应用层，设备之间通过**交换通信对象**进行通信。



#### CANopen实现

- CANOpen 中的**通信对象是 COB-ID**，COB-ID是一个用于标识CANopen通信对象的标识符，它由一个**11位的标识符**组成，用于**唯一标识网络上的每个CANopen设备**和它们之间的通信对象。COB-ID包括一个**标识符位和一个方向位**，用于指示通信是**从节点发送到节点**（传输方向为0）还是**从节点发送到总线**（传输方向为1）。
- CANOpen 定义了一个强制的默认标识符（CAN-ID）分配表。默认 ID 分配表基于 11 位 CAN-ID，包括 **4 位功能代码部分和 7 位节点 ID（节点 ID）部分**。
- 只有**前面三个PDO**被使用，如表6-1所示。主要用来**传输传感器的数据、遥控器手柄信号、上下位机之间的通信**。

#### PDO和SDO

CANopen 的通信对象类型中有**两个对象用于数据传输**。它们使用两种**不同的数据传输机制**来实现：

- PDO和SDO是两种不同类型的通信对象，用于在CANopen网络中进行数据交换。
  1. **PDO：过程数据对象**
     - PDOs用于实时过程数据的传输。用于传输 **8 字节或更少的数据**，并且没有其他协议预设。
     - 它们是在CANopen网络中**周期性地传输数据**的一种机制，适用于需要**实时更新**的数据，例如传感器数据或执行器状态。
     - PDO的配置是通过**对象字典**中的PDO通信参数对象完成的，其中包括COB-ID等信息。
  2. **SDO：设备数据对象**
     - SDOs用于在设备之间请求和传输服务数据。用于在设备之间传输大的低优先级数据，并且通常用于配置 CANopen 网络上的设备。
     - 它们是一种非周期性的数据传输机制，用于配置、诊断和管理CANopen设备。
     - SDO的传输通常包括读取或写入设备参数的请求和响应。每个SDO传输都与一个唯一的COB-ID相关联。

![can](../../%25E6%25A1%258C%25E9%259D%25A2/%25E8%2587%25AA%25E5%25B7%25B1%25E6%2595%25B4%25E7%2590%2586/%25E5%259B%25BE%25E7%2589%2587/can.png)



#### **CAN通信搭建方式**

- 工控机和运动控制之间采用 **USB 转 CAN 模块。**USB 转 CAN 模块兼容周立功 API 及 CANTest 软件。**上位机软件开发 CAN 通信采用周立功 API**。上位机的通信功能主要为**编码发送信息和解码接收信息**。
- 接收功能采用 **VCI_Receive** 实现，发送功能采用 **VCI_Transmit** 实现，将数据发送到CAN总线，**周立功 API** 中用于实现CAN数据接收和发送的函数。
- **上位机软件**通过**CAN总线**发送给数据 id 号（0x01-0x06)、8位字节数、关节1-6阀口开度（三种模式信号）、运动控制（模式切换）**给控制器**。
- 上位机通过**CAN总线**收到传感器（0x181-0x186）和控制器数据 id 号、4或8位字节数、关节1-6角度（控制器信号、遥控器按钮、摇杆信号）、类型（传感器1-6数据，遥控器数据）。
- 工控机和外挂控制器的 CAN 通信通道为 1，外挂控制器和原车载控制器的CAN 通信通道为 0，传感器与外挂控制器的通信通道为 0，外挂控制器要接原车载控制器的遥控器信号接收器，原车载控制器不接。





### 坐标统一

- 坐标装换确定喷浆**车辆相对于隧道的位置**，实现自动轨迹规划。涉及三坐标系：**隧道坐标系、车辆坐标系、机械臂坐标系。**
- 两个依赖坐标转换的功能：**曲线拟合、自动轨迹规划。**



**坐标转换流程：**

- 1.采集机械臂末端的位置点。
- 2.通过**坐标变换转到隧道坐标系**。从机械臂基坐标系转换到车辆坐标系，车辆坐标系转换到隧道坐标系。
- 3.利用这些描述**隧道几何轮廓的点拟合出隧道轮廓线**。
- 4.利用**隧道轮廓线生成一个喷浆轨迹曲面**，计算出喷浆轨迹路径点。
- 5.这些**路径点是在隧道坐标系下**，再转换到**机械臂坐标系**下。



**确定车辆坐标系在隧道坐标系下的位置：**

- 位置包含(X, Y, Z)和(Roll, Pitch, Yaw)。Roll、Pitch 可以通过水平仪获取，Yaw可以通过测量车辆纵轴线与隧道轴线的夹角获取。

### **传感器标定**

- 传感器标定主要确定传感器值和实际关节角度值之间的关系。
- 在标定时，只需将传感器的值和对应的真实关节角度值输入，就可以确定两者之间的关系。机械臂只需要进行一次标定即可，以后重新打开软件时，会默认加载标定好的关系。
- 传感器通过 **CAN** 将信号传给**上位机通讯模块**，处理**传感器数据**并计算出**当前机械臂的位置和姿态**。轨迹规划模块规划出理论轨迹，通过**末端期望轨迹**由运动学求解**每个关节的运动量**，通过闭环的**运动控制模块**将**控制信号**发送SYMC 控制器，并**由 A/D 转换为比例阀阀口开度**，实现机械臂各关节运动，实现末端轨迹跟踪。
- 喷浆机械臂采用了**丹弗斯 PVG32 比例阀**，这是一种液压负载比例阀，其主要功能是通过**与负载相关的控制信号**来实现对**执行器的精确控制**。









### Qt图形界面开发

- Qt 中实现了 OPenGL 的提供的函数接口，以创建具有OpenGL渲染能力的Qt应用程序。
- 使用`QOpenGLWidget`来创建一个**OpenGL渲染窗口**，使用`QOpenGLFunctions`来**调用OpenGL函数**，使用`QOpenGLShader`和`QOpenGLShaderProgram`来**处理着色器**，以及使用`QOpenGLBuffer`来**管理缓冲区对象**。

1. **QOpenGLWidget类：**
   - `QOpenGLWidget`类是Qt部件类，用于在Qt应用程序中**嵌入OpenGL渲染环境**。通过继承`QOpenGLWidget`并重写相关的OpenGL回调函数来实现自定义的OpenGL渲染。
2. **QOpenGLFunctions类：**
   - `QOpenGLFunctions`类是一个用于**封装OpenGL函数的类**。通过继承`QOpenGLFunctions`，在`QOpenGLWidget`中使用OpenGL函数，而不必直接调用OpenGL的C函数。
3. **QOpenGLContext类：**
   - `QOpenGLContext`类表示OpenGL上下文，**封装了与OpenGL相关的状态信息**。您可以使用这个类来管理OpenGL上下文。
4. **QOpenGLShader和QOpenGLShaderProgram类：**
   - 这两个类分别用于处理OpenGL**着色器和着色器程序**。`QOpenGLShader`类用于加载和编译着色器，而`QOpenGLShaderProgram`类用于**链接和管理多个着色器**，创建OpenGL着色器程序。
5. **QOpenGLBuffer类：**
   - `QOpenGLBuffer`类用于创建和管理OpenGL缓冲区对象，这在OpenGL中是**存储顶点数据、颜色数据**等的一种方式。



#### 模型预处理过程

- 利用 Solidworks 画出机械臂的三维模型，把机械臂分成几个相对运动的模块输出为零件体。然后将其格式变为 STL，最后把各个模块导入到 Blender 软件中，调整好坐标系的位置同时将模型进行一定比例的缩放，然后输出为 obj 格式。
- 通过在 QT 中使用 OPenGL 的load函数将模型加载进去，过使用 OpenGL 类库中的 glRotatef和 glTranslatef 函数对每个臂架的坐标系位置和方向进行了改变，
- 同时构建好模型参数和自动化轨迹规划好的关节角参数接口，使得两个能够进行有效的数据交换，这样就能实现离线的三维仿真。同时在**机械臂运动时**可以将**传感器采集的数据交给上位机**然后更新虚拟机械臂的运动。这样**三维实时仿真系统可以实时监测**机械臂的运动情况。



#### 控制软件架构

- 中央控制模块主要负责处理来自各个模块的信息，然后正确的给出指令；
- 主界面接受来自用户的输入信息并反馈给中央控制模块。
- 主界面中包含了很多个子界面，子界面通过向主界面返回输入的信息，然后再返回给中央处理模块进行处理。

![控制架构](../../%25E6%25A1%258C%25E9%259D%25A2/%25E8%2587%25AA%25E5%25B7%25B1%25E6%2595%25B4%25E7%2590%2586/%25E5%259B%25BE%25E7%2589%2587/%25E6%258E%25A7%25E5%2588%25B6%25E6%259E%25B6%25E6%259E%2584.png)



#### **上位机软件界面内容**

- •**CAN通信格式设置：**设置CAN的通信频率、是否接入终端电阻。
- •**启动CAN：**完成CAN的初始化、CAN通信设备信息读取、CAN通信接口启动。
- •**传感器标定：**读入传感器的值和对应真实关节角值，确定传感器值和关节角度的关系。
- •**坐标系标定：**根据测量得出的位置集合关系，确定隧道坐标系、车辆坐标系、机械臂坐标系之间的关系。
- •**机械臂末端位置和姿态：**表示喷浆机械臂在**运动状态时末端**在机械臂坐标系中的位置。
- •**三维图形显示窗口：**展示**仿真效果和实时的机械臂运动状态**。在仿真状态下，会显示仿真下机械臂的运动状态。在控制机械臂运动时，会根据**传感器传回的参数实时更新**机械臂的三维模型状态。
- •**关节曲线显示：**绘制三维模型机械臂的**每个关节角度值的变化曲线**。
- •**运动轨迹显示：**显示**机械臂末端实时运动的轨迹**和自动轨迹规划下的理论喷浆轨迹。
- •**平台控制：**仿真表示生成一条**自动控制轨迹控制仿真图形**的运动，展示轨迹规划的结果，验证其合理性。**启动**表示将控制指令发送给运动控制器。**暂停**表示停止控制指令的发送。**复位**表示机械臂回到喷射起点的位置。关闭表示结束控制指令的发送，并关闭CAN通信。
- •**喷浆参数输入：**喷浆参数确定了**机械臂自动控制下的运动轨迹**。**喷浆宽度**表示沿隧道轴线方向的距离，**喷射高度**表示沿隧道轮廓的弧线方向距离，**步长**表示机械臂每次末端移动的直线距离。**喷射起点**表示机械臂的初始关节位置。



- •**隧道曲线采样拟合：**通过**机械臂获取隧道轮廓的表示点**，然后**生成一条与隧道形状近似的等距曲线**。

- •**控制模式：**表示三种的不同的控制方式。**手动模式**下，通过遥控器控制独立的关节运动。**XYZ模式**下，通过遥控器直接控制机械臂的末端运动，但目前只支持**直线运动**。全自动模式，不需要人工参与，控制软件生成控制指令控制机械臂的运动。

- •**参数设置完成：**选中后读入喷浆参数，并启动平台控制面板。目的是为了操作的安全性。

- •**控制器连接状态：**表示CAN总线的通信状态。**通信正常**则显示正常，指示灯为绿色，**通信故障**或者CAN连接丢失则显示异常，指示灯为红色。

- •**水平仪倾角：**表示车辆的倾斜程度。

- •**关节传感器数据：**关节表示**实时的机械臂关节角度**，误差表示与理论关节角的差值。

- •**单关节控制：**包含**滑动控制、输入数值、遥控器操作**三种单关节控制方式。。

  





#### Qt界面OpenGL上显示字段UI

1. CAN通信格式设置：

- 使用`QLabel`来显示“CAN通信格式设置”这个标题。
- 使用`QComboBox`或者`QSpinBox`来让用户选择CAN的通信频率。
- 使用`QCheckBox`来让用户选择是否接入终端电阻。
- 使用`QPushButton`提供一个“应用设置”的按钮，点击后将用户的选择应用到系统中。

2. 启动CAN：

- 使用`QPushButton`提供一个“启动CAN”按钮。
- 当用户点击这个按钮时，触发一个槽函数来完成CAN的初始化、CAN通信设备信息读取、CAN通信接口启动的工作。

3. 传感器标定：

- 使用`QLabel`来显示“传感器标定”这个标题。
- 使用`QLineEdit`或者`QLabel`来显示传感器的值。
- 使用`QLineEdit`让用户输入对应的真实关节角值。
- 使用`QPushButton`提供一个“标定”按钮，用于确定传感器值和关节角度的关系。

4. 坐标系标定：

- 使用`QLabel`来显示“坐标系标定”这个标题。
- 提供相应的输入框和按钮，让用户输入测量得出的位置集合，并进行标定。

5. 隧道曲线采样拟合：

- 使用`QLabel`来显示“隧道曲线采样拟合”这个标题。
- 使用`QPushButton`提供一个“采样”按钮，通过机械臂获取隧道轮廓的表示点。
- 使用`QPushButton`提供一个“拟合”按钮，生成一条与隧道形状近似的等距曲线。
- 可以使用`QOpenGLWidget`显示曲线的三维图形。

6. 控制模式：

- 使用`QLabel`来显示“控制模式”这个标题。
- 使用`QRadioButton`或`QComboBox`提供三种不同的控制方式的选择。
- 对于手动模式和XYZ模式，提供相应的控制界面，如使用`QSlider`来控制独立的关节运动，或者提供一个三维的控制杆来控制机械臂的末端运动。



#### Qt界面代码写

Qt Widgets应用程序的主窗口，并展示了如何连接用户界面元素（如按钮、下拉列表和复选框）到代码逻辑。在`applyCANSettings`和`startCAN`函数中

```c++
#include "mainwindow.h"    // 引入主窗口的头文件
#include "ui_mainwindow.h" // 引入UI的头文件，UI文件是通过Qt Designer生成的
#include <QMessageBox>     // 引入消息框类，用于显示信息
// 主窗口的构造函数
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent) // 初始化QMainWindow
    , ui(new Ui::MainWindow) // 创建UI对象
{
    ui->setupUi(this); // 设置UI，这个函数在ui_mainwindow.h中定义
    
    // 初始化界面
    ui->comboBoxBaudRate->addItem("500 kbps", QVariant(500000)); 
        // 添加波特率选项到下拉列表，并存储对应的值
    ui->comboBoxBaudRate->addItem("250 kbps", QVariant(250000));
        // 添加另一个波特率选项
    ui->checkBoxTerminalResistance->setChecked(true); 
        // 默认勾选终端电阻复选框

    // 连接信号和槽
    connect(ui->pushButtonApplySettings, &QPushButton::clicked, this, &MainWindow::applyCANSettings);
        // 当点击“应用设置”按钮时，调用applyCANSettings函数
    connect(ui->pushButtonStartCAN, &QPushButton::clicked, this, &MainWindow::startCAN);
        // 当点击“启动CAN”按钮时，调用startCAN函数
}

// 主窗口的析构函数
MainWindow::~MainWindow()
{
    delete ui; // 删除UI对象
}

// “应用设置”按钮的槽函数
void MainWindow::applyCANSettings()
{
    int baudRate = ui->comboBoxBaudRate->currentData().toInt(); // 获取选择的波特率
    bool useTerminalResistance = ui->checkBoxTerminalResistance->isChecked(); // 获取终端电阻复选框的状态

    // 在这里添加设置CAN通信格式的代码
    // ...

    // 显示一个消息框，告知用户设置已应用
    QMessageBox::information(this, "Settings Applied", "CAN settings have been applied.");
}

// “启动CAN”按钮的槽函数
void MainWindow::startCAN()
{
    // 在这里添加启动CAN通信的代码
    // ...

    // 显示一个消息框，告知用户CAN通信已启动
    QMessageBox::information(this, "CAN Started", "CAN communication has been started.");
}
```





##### openGL 可视化界面

Qt提供了**QOpenGLWidget和QOpenGLWindow**等类，用于在Qt应用程序中集成OpenGL渲染。

**用户界面与交互**

1. **控制界面开发**:

   - 使用Qt创建机械臂的操作面板，包括按钮、滑杆等控件，用户可以通过这些控件发送命令到机械臂。

2. **实时数据可视化**:
   - 利用OpenGL在Qt中渲染实时的机械臂状态，如位置、速度和喷浆状态，提供直观的反馈。


- **在Qt中实现机械臂的实时运动显示，使用`QOpenGLWidget`来创建一个可以绘制OpenGL图形的窗口部件。**

- **步骤1: 创建一个OpenGL窗口部件**

- 在你的Qt项目中，创建一个新的类继承自`QOpenGLWidget`，并重写其`initializeGL`，`resizeGL`，和`paintGL`方法。

- ```c++
  #include <QOpenGLWidget>
  #include <QOpenGLFunctions>
  class GLWidget : public QOpenGLWidget, protected QOpenGLFunctions
  {
      Q_OBJECT
  public:
      GLWidget(QWidget *parent = nullptr) : QOpenGLWidget(parent) {
          // 初始化代码，如设置定时器来更新画面
      }
  protected:
      void initializeGL() override {
          initializeOpenGLFunctions();
          glClearColor(0.0, 0.0, 0.0, 1.0); 
          // 设置背景色为黑色
          // 其他初始化OpenGL的代码，如设置光照、加载着色器等
      }
      void resizeGL(int w, int h) override {
          // 更新视口大小
          glViewport(0, 0, w, h);
      }
      void paintGL() override {
          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
          // 绘制代码，绘制你的机械臂
      }
  };
  ```

- **步骤2: 添加OpenGL窗口部件到主窗口**

- 在你的主窗口（或者任何其他容器内），创建`GLWidget`的实例并将其作为子部件添加进去。

- ```c++
  // 在主窗口构造函数中
  GLWidget *glWidget = new GLWidget(this);
  setCentralWidget(glWidget); 
  // 如果这是一个 QMainWindow 的派生类
  ```

- **步骤3: 实现绘制机械臂**

- 在`GLWidget`类的`paintGL`方法中，实现绘制机械臂的逻辑。这可能包括加载模型、设置变换矩阵以及绘制各个部分。

- ```c++
  void paintGL() override {
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      
      // 设置摄像机和视角
      // ...
  
      // 画机械臂的各个部分
      // ...
  }
  ```

- **步骤4: 实时更新画面**

- 如果机械臂的动作是动态的，你需要定期更新画面，刷新和主界面刷新50ms更新一次。使用`QTimer`来设置一个更新频率，然后在定时器超时的槽函数中调用`update()`，这会导致`paintGL`被调用。

- ```c++
  // 在GLWidget类中
  QTimer *timer = new QTimer(this);
  connect(timer, SIGNAL(timeout()), this, SLOT(update()));
  timer->start(16); // 大约每秒60帧
  ```

- **步骤5: 响应用户输入或数据**

- 需要响应用户输入或者实时数据来动态地显示机械臂的运动，将这些输入或数据传递到`GLWidget`中，并在绘制代码中使用这些数据来调整机械臂的位置和姿态。

- 注意

- - 不要忘记在你的`.pro`文件中添加对OpenGL模块的支持：

- ```c++
  QT += opengl
  ```

- - 对于更复杂的3D渲染，你可能需要使用OpenGL的高级功能，如顶点和片元着色器，以及模型加载库（如Assimp）来导入和渲染3D模型。
  - 你可能需要实现适当的向量和矩阵操作，Qt提供了`QMatrix4x4`和`QVector3D`类，它们可以帮助你进行这些数学计算。
  - 对于实时动画和交互，可能还需要结合使用`QMouseEvent`和`QKeyEvent`来处理鼠标和键盘事件，以允许用户通过



##### Qt 按钮界面什么设计

**1. 创建新的Qt Widgets应用程序**

Qt Creator创建一个新的Qt Widgets应用程序。

**2. 设计用户界面**

在Qt Creator的“设计”模式下，可以通过拖放来设计用户界面。

- **添加按钮**：在工具箱中找到QPushButton，将其拖到主窗口中。
- **设置按钮属性**：可以在属性编辑器中设置按钮的各种属性，如text属性可以定义按钮上显示的文字。
- **调整按钮大小和位置**：可以通过拖动和调整大小控件来设置按钮的准确位置和大小。

**3. 安排布局**

将按钮放入布局中，确保按钮的大小和位置可以随窗口的变化而动态调整。

- 在设计视图中选择按钮。
- 右键点击并选择“Lay Out”选项，可以选择水平布局、垂直布局或网格布局等。

**4. 编写信号和槽**

按钮界面的核心功能是通过信号和槽机制实现的，你需要为按钮的点击事件编写一个槽函数。

- 在设计视图中右键点击按钮，选择“转到槽”。
- 选择`clicked()`信号，并连接到一个新的槽函数，Qt Creator将会自动为你在代码中生成这个槽函数。

**5. 实现槽函数**

在代码编辑器中，找到自动生成的槽函数，并实现它。比如：

```c++
void MainWindow::on_pushButton_clicked()
{
    // 按钮点击时要执行的代码
    QMessageBox::information(this, "标题", "按钮被点击了!");
}
```

**6. 编译和运行**

点击“运行”按钮来编译和运行你的应用程序。如果一切正常，你将看到按钮按照你设计的布局出现在窗口中，并且点击它会出现一个消息框。



###### 按钮功能在QT什么实现的，用到了哪些组件

1. QPushButton

按钮组件，用它创建一个标准的按钮。

```c++
QPushButton *button = new QPushButton("Button Text", parentWidget);
```

2. Signal and Slot

当**按钮被点击时**，它会发出一个信号（signal），将这个**信号连接到一个槽函数**（slot）上，这个槽函数定义了**按钮被点击后将执行**的操作。

```c++
connect(button, &QPushButton::clicked, this, &MyClass::onButtonClicked);
```

在上面的代码中，`onButtonClicked`是一个成员函数，定义了按钮被点击时的操作。

3. QLayout

布局管理器，用于控制按钮的位置和大小。你可能会将按钮放入一个布局管理器中，以便于更灵活地控制其在界面中的位置。

```c++
QVBoxLayout *layout = new QVBoxLayout;
layout->addWidget(button);
parentWidget->setLayout(layout);
```

4. QSignalMapper (Optional)

- 如果你有**多个按钮需要连接到同一个槽函数**，根据是哪个按钮被点击来采取不同的行动，你可以使用`QSignalMapper`来“映射”信号到槽函数，并传递一个标识符。
- 在这个例子中，当`button1`被点击时，`onButtonClicked`槽函数会被调用，并且传递一个字符串"button1"作为参数。

```c++
QSignalMapper *signalMapper = new QSignalMapper(this);
connect(button1, SIGNAL(clicked()), signalMapper, SLOT(map()));
signalMapper->setMapping(button1, "button1");
connect(signalMapper, SIGNAL(mapped(QString)), this, SLOT(onButtonClicked(QString)));
```

5. QAction (Optional)

`QAction`是一个抽象的用户界面动作，它可以与按钮关联。这是一个可选的组件，当你希望同一个动作能够在多个地方被触发时使用，例如在按钮、菜单项和工具栏按钮之间共享同一个动作。







##### CAN通信在QT怎么实现

1. **确保你有Qt Serial Bus模块**： 在开始编程之前，你需要确保你的Qt安装包含了Qt Serial Bus模块。如果你使用的是Qt 5.8或更新版本，该模块应该已经包含在内。

2. **添加必要的模块到你的项目文件**： 在你的`.pro`文件中添加以下行以确保Serial Bus模块被包括：

   ```c++
   QT += serialbus
   ```

3. **包含必要的头文件**： 在你的代码中包含QCanBus和其他可能需要的类。

   ```c++
   #include <QCanBus>
   ```

4. **加载并配置CAN插件**： 你需要加载相应的CAN驱动，并根据你的CAN设备配置参数，例如波特率和通道。

   ```c++
   QString errorString;
   QCanBusDevice *device = QCanBus::instance()->createDevice(
       QStringLiteral("socketcan"), QStringLiteral("can0"), &errorString);
   if (!device) {
       // 处理错误情况
   }
   ```

5. **配置设备参数**： 在连接到CAN总线之前，你可以设置一些设备参数，例如波特率、帧ID过滤等。

   ```c++
   device->setConfigurationParameter(QCanBusDevice::BitRateKey, QVariant(500000));
   ```

6. **连接到CAN总线**： 在配置好设备后，你可以尝试连接到CAN总线。

   ```c++
   if (!device->connectDevice()) {
       // 处理连接失败
   }
   ```

7. **发送CAN帧**： 创建一个QCanBusFrame对象并设置必要的数据，然后通过CAN设备发送出去。

   ```c++
   QCanBusFrame frame;
   frame.setFrameId(0x123);
   QByteArray payload("Hello CAN");
   frame.setPayload(payload);
   device->writeFrame(frame);
   ```

8. **接收CAN帧**： 为了接收CAN帧，通常需要连接一个槽到QCanBusDevice的`framesReceived`信号。

   ```c++
   connect(device, &QCanBusDevice::framesReceived, this, &MyClass::processReceivedFrames);
   ```

   实现处理函数来读取CAN帧：

   ```c++
   void MyClass::processReceivedFrames() {
       while (device->framesAvailable()) {
           const QCanBusFrame frame = device->readFrame();
           // 处理frame
       }
   }
   ```

9. **处理错误**： 还应该连接到错误信号来处理可能出现的任何CAN通信错误。

   ```c++
   connect(device, &QCanBusDevice::errorOccurred, this, &MyClass::processErrors);
   ```

10. **清理**： 当不再需要CAN通信时，应该适当地关闭并清理设备。

    ```c++
    device->disconnectDevice();
    delete device;
    ```















用中文解答

C++做一下，acm模式，根据输入cin，代码每行注释一下，给出思路

代码题输出，准备好IDE测试

简述问的问题，并且回答一下

中文

详细点

## 自我介绍：

面试官你好，我叫彭凯，目前在中南大学读研三，专业排名前10%，我的研究方向主要是机器人控制软件，我有一段实习经历，在深圳汇川技术，主要负责喷涂机器人的上位机软件客户端开发工作，利用C++和Qt做了个控制软件界面。上位机软件逆解6个关节角度的运动控制信息、三种模式切换信号通过CAN通信给控制器。控制器将传感器检测到的6个关节角度，遥控器数据（按钮、摇杆）编码通过CAN线发送给上位机。增加OpenGL可视化界面，实现对机械臂三维模型的运动控制和显示。在实习期间，我也深刻体会到团队合作对于项目推进的重要性，并学到了如何更好地进行团队交流。

然后我还有几个项目经验，有一个是在Linux环境下搭建的轻量级网络服务器，可以支持相对数量的客户端并发访问并及时响应。这个项目是我看书以及结合网络上开源代码完成的，服务器的⽹络模型是主从reactor加线程池的模式，IO处理使用了IO多路复⽤技术，异步日志系统采用双缓冲技术，使用有限状态机和正则表达式解析HTTP请求报文，实现了GET和POST的解析，还可以通过对GET和POST请求的解析，增加了下载文件和上传文件的功能，在这个项目中我做了一些优化，考虑到高并发热点页面频繁访问的问题，加入了缓存机制，最后还做了对⽹络框架的测试，使⽤webbench创建1000个进程对服务器进行60s并发请求，测试结果表明，对于短连接的QPS为1.8万，对于长连接的QPS为5.2万。通过这个项目，我对TCP和网络编程有了一定的理解。

/还有一个项目是在Linux环境下利用C++11实现的简易RPC网络通信框架，实现了服务的发布、注册、远程过程调用等功能，在这个项目中我使用zookeeper的watch/wɑtʃ/观察机制和znode节点实现服务的的分布式部署，利用protobuf进行数据的序列化和反序列化，利用主从Reactor模型（muduo）进行高性能网络发送，利用生产者消费者模型编写异步日志模块。



**还通过CAN通讯协议，主要用来传输传感器的数据、遥控器手柄信号、上下位机之间的通信，上位机实现了编码发送信息函数和解码接收信息函数，**

发送接口函数是将要发送的CAN消息（关节传感器数据）编码添加到发送队列中，定时将其发送到总线上，以避免消息的丢失或冲突。

接收接口函数是将接收到的数据放入接收队列中，作为一个缓存区来存储接收到的CAN数据帧，接收队列采用循环队列的数据结构实现，使用先进先出的原则进行数据帧的存储和管理。CAN总线可能接收到多个节点的数据帧，因此使用接收队列可以帮助系统缓存并按顺序处理这些数据帧，避免数据的丢失或冲突。

主从reactor==多Reactor模型：核心思想是，主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I/O事件交给sub-reactor负责分发。其中 sub-reactor的数量，可以根据CPU的核数来灵活设置。主要就是为了分担单Reactor模型下Reactor模型的压力（一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方）

旷世科技：

专注于提供基于人工智能的解决方案。它是中国四大人工智能巨头之一，以其面部识别技术而闻名，该技术在中国国内的许多应用中被广泛使用，例如在手机支付、身份验证和城市安全监控等领域。

旷视是一家聚焦物联网场景的人工智能公司
基于业界领先的AI科研与工程实力，旷视打造出软硬一体化的AIoT产品体系
面向消费物联网、城市物联网和供应链物联网的核心场景提供解决方案

旷视**人脸识别技术**基于深度学习、海量数据以及自研MegEngine开源框架

**智能视觉传感器（**AI智能测温技术、屏下指纹识别技术）

**机器人导航与定位**（SLAM建图与定位技术、机械臂抓取技术、三维感知技术）



**职位描述：**

1、负责自动驾驶系统中基础服务组件的开发；

2、负责各类传感器的接入及数据流的高效率管理；

3、负责自动驾驶系统级的性能调试和优化。



职位要求：

1、2024届本科及以上学历，计算机相关专业；

2、熟练掌握C/C++语言和计算机基础知识；

3、理解计算机体系结构和操作系统原理；对调度策略，内存管理等有自己的认识。

加分项：

1、有嵌入式电子技术类，计算机类竞赛获奖者；

2、有摄像头图像处理经验者；

3、有机器人或者自动驾驶相关开发经验者；

4、有参与大型软件开发经验者；

5、熟悉ARM架构和linux操作系统，掌握任意一门脚本语言。







经纬恒润：

经纬恒润专注于为汽车、无人运输等领域的客户提供电子产品、研发服务和高级别智能驾驶整体解决方案。技术范围包含智能驾驶、智能座舱、车身、底盘、新能源、人工智能等。





佑驾创新：

基于计算机视觉技术与人工智能算法打造的智能座舱产品，核心功能包括驾驶员监测系统（DMS）、乘客监测系统（OMS）、物体识别与人车交互系统。iCabin特别针对五大应用场景提供“主动式”服务，用户无需给出明确指令，即可“无感”体验先进的智能座舱技术。

无缝入车（支持多角度识别，无需动作配合）

儿童看护（实时情绪检测、危险动作检测、自动紧急报警）

1、协助开发自动驾驶系统相关工具链；
2、协助负责根据产品需求设计、开发和维护，图形化客户端；
3、协助负责产品客户端和主机之间的通信开发。

**道路环境感知**

MINIEYE 自主研发的视觉感知系统，通过对实际路况的分析，能对车辆、行人、车道、信号灯以及交通标志等道路目标和可行驶区域进行精确的检测。 [2] 

**舱内感知**

通过基于神经网络的视觉感知以及多传感器技术，进行眼睑检测、视线追踪、头部姿态识别、肢体检测以及物体检测，智能分析驾乘人员的状态及行为。 [2] 

**多传感器融合**

结合不同传感器的性能特点，通过目标的跟踪、关联及预测等融合方式，为自动驾驶提供更鲁棒的感知结果。

成谷科技：

专注于高速公路自动驾驶、**雷射融合车道天线**、**加油站收费天线**、**汽车电子系列产品**、**前装OBU芯片**、ETC电子不停车收费系统

科曼医疗：

呼吸机，手术灯之类的医疗器械

立芯科技

**什么是EDA**

EDA全称是**Electronic Design Automation**，也就是**电子设计自动化**，是指利用计算机辅助设计（CAD）软件，来完成超大规模集成电路（VLSI）芯片的功能设计、综合、验证、物理设计（包括布局、布线、版图、设计规则检查等）等流程的设计方式。EDA被誉为“芯片之母”，是电子设计的基石产业。

集成电路设计主要分为**模拟电路设计**和**数字电路设计**。我们身处的自然界是一个**模拟信号**的世界。人类感知的声音、图像、温度、压力、运行轨迹以及无法感知但真实存在的电磁波、微波等，都是模拟信号，它反映了我们所处的物理世界。处理模拟信号的芯片称为模拟芯片，它用于产生、放大、滤波、运算、转换、传输或处理模拟信号，如数模/模数转换器芯片、放大器芯片等。

声音、图像等模拟信号经采样量化后即可转换为以0和1表示的**数字信号**。数字信号被存储、处理后就有了丰富多彩的数字世界。处理这些0和1信号的芯片就是数字芯片，如图形处理芯片、微控制器芯片和数字信号处理单元芯片等。

了解

数字电路设计自动化EDA工具软件平台的相关软件开发，参与软件工程系统的设计、开发、测试、优化等过。

立芯软件科技有限公司成立于2020年11月，专注于**集成电路电子设计自动化（EDA）工具的研发工作。立芯以打造数字电路设计可以信赖的工具为宗旨**，致力于国产替代和科技创新，助力中国集成电路产业发展。

​    立芯自成立之初即获得国内知名投资机构和头部企业客户的认可，产品已在客户的多款高性能设计中得到验证，并已开始商用。

​    目前公司已经在上海、北京、福州等地设有分公司及研发中心，并与行业领先企业和国内高校联合承担多项国家重点研发计划。

​    作为技术密集型企业，立芯拥有完全自主研发的技术成果，并已受到国际同行的广泛认可。团队核心技术人员由工业界顶级专家、学术界知名科学家、清华、北大、复旦、交大、UIUC、UCLA、华为天才少年计划人选等尖端人才组成，研发团队硕博人才占比约80%，**曾多次取得中国大陆在国际EDA领域的首次突破。自成立以来，立芯已获得计算机软件著作权32件，申请国家发明专利29件（授权7件）。**





### 多线程使用使用方法

方法一：

①创建一个类从QThread类派生

②在子线程类中重写 run 函数, 将处理操作写入该函数中 

③在主线程中创建子线程对象, 启动子线程, 调用start()函数



方法二：

①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数

②在主线程中创建一QThread类对象 

③在主线程中创建一个业务类对象 

④将业务类对象移动到子线程中 

⑤在主线程中启动子线程

 ⑥通过信号槽的方式, 执行业务类中的业务处理函数。



多线程使用注意事项: 

* 1. 业务对象, 构造的时候不能指定父对象 
* 2. 子线程中不能处理ui窗口(ui相关的类) 
* 3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口



#### Qt多线程之间的通信

1. **信号和槽**:
   - 当一个信号在一个线程中被发射，并且在另一个线程中有一个连接到它的槽，Qt 会自动将其放入接收线程的事件循环中进行处理，确保其线程安全。
   - 这种机制非常方便，因为你不需要明确地使用锁或其他同步原语。
2. **QMutex**:
   - `QMutex` 是互斥锁，它可以确保一次只有一个线程访问特定的代码段或资源。
   - 当多个线程需要访问**共享资源或代码段**时，使用 `QMutex` 可以避免竞态条件。
3. **QWaitCondition**:
   - 这是一个条件变量，它可以使**线程等待某个条件**成立，或者在条件成立时唤醒其他线程。
   - 通常与 `QMutex` 一起使用，以确保线程安全。
4. **QSemaphore**:
   - 信号量是一个计数器，它可以用来控制对资源的访问。例如，如果你有一个有限的资源池，你可以使用 `QSemaphore` 来确保一次只有 N 个线程可以访问资源。



















### Qt信号槽机制与优势与不足

- 优点： 
- ①类型安全。需要关联的信号槽的签名必须是等同的。即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，编译器会报错。
-  ②松散耦合。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是那个对象的那个信号槽接收它发出的信号，它只需在适当的时间发送适当的信号即可，而不需要关心是否被接受和那个对象接受了。Qt就保证了适当的槽得到了调用，即使关联的对象在运行时被删除。程序也不会奔溃。
-  ③灵活性。一个信号可以关联多个槽，或多个信号关联同一个槽。

​          

- 不足：速度较慢。与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍。
- 原因：
- ①需要定位接收信号的对象。
- ②安全地遍历所有关联槽。
- ③编组、解组传递参数。
- ④多线程的时候，信号需要排队等待。（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。）





### 信号和槽的理解

信号和槽机制底层是通过**函数间的相互调用**实现的。**信号函数和槽函数通常位于某个类**

1. **信号 (Signal)**：

   - 是`QObject`类的一个公有成员函数，但你不能直接调用它，也不能实现它。只能使用`emit`关键字发射它。

   - 信号函数用 signals 关键字修饰，槽函数用 public slots、protected slots 或者 private slots 修饰。

   - 当某些事情发生时，例如用户点击了一个按钮，该按钮可以发出一个信号。

   - **信号没有默认的实现，它只是一个函数声明**。实际的功能是由与之连接的槽来实现的。

     

2. **槽 (Slot)**：

   - Qt5 中，槽函数既可以是**普通的全局函数、也可以是类的成员函数、静态成员函数、友元函数、虚函数**，还可以用 lambda 表达式表示。
   - 和信号函数不同，槽函数必须手动定义（实现）。槽函数可以在程序中直接调用，但主要用来响应某个信号。自定义一个槽函数时，需要注意以下几点：
     - 槽函数的返回值必须和信号函数相同，由于信号函数的返回值一定是 void，所以槽函数的返回值也必须为 void；
     - 对于带参的信号函数，槽函数可以选择接收所有参数，则参数的类型、顺序、个数都必须与信号函数相同；也可以选择接收前几个参数，这些参数的类型、顺序都必须与信号函数相同；还可以选择不接受任何参数。
     - 槽函数的参数个数只能比信号函数少，不能比信号函数多；
     - 槽函数的参数不能有默认值。
   - 与普通的C++成员函数相似，但它也是`QObject`类的一个成员函数。
   - **槽可以与一个信号或多个信号连接**，以实现某种功能。
   - 当**关联的信号被发射时，该槽会被自动调用**。
   - 除了与信号连接外，槽也可以像普通的C++函数那样被调用。

3. **连接 (Connect)**：

   - 通过`QObject::connect()`函数可以将特定的信号与特定的槽连接起来。
   - 当发射该信号时，与之连接的所有槽都将被调用。

4. **特点**：

   - **类型安全**：信号和槽的参数类型是确定的，所以在编译时可以进行检查，避免了传统回调可能出现的类型不匹配问题。
   - **松耦合**：发送信号的对象无需知道接收该信号的对象，这意味着代码的耦合度减少，更加模块化。

   

   5.“按钮被按下”这个信号可以用 clicked() 函数表示，“窗口关闭”这个槽可以用 close() 函数表示，信号和槽机制实现“点击按钮会关闭窗口”的功能，其实就是 clicked() 函数调用 close() 函数的效果。

   

   将某个信号函数和某个槽函数关联起来，需要借助 QObject 类提供的 connect() 函数。

   

#### 信号和槽函数代码实现：

**自定义信号函数：**

以定义好的 MySignal 信号为例，修改 MyWidget 类为：

```c++
class MyWidget:public QWidget{
    //Q_OBJECT 是一个宏，添加它才能正常使用 Qt 的信号和槽机制
    Q_OBJECT
//自定义信号函数
signals:
    void MySignal(QString mess);
public:
    void emitSignal(){
        emit MySignal(message);
    }
private:
    QString message;
};
```

我们为 MyWidget 类新增了一个 emitSignal() 方法和一个 message 属性，emitSignal() 方法中的`emit MySignal(message);`语句就表示发射 MySignal 信号。当程序中执行 emitSingal() 函数时，就会发出 MySignal 信号，message 属性的值也会随信号一同发出，对应的槽函数可以接收到 message 的值。

> 对于每一个自定义的信号函数，程序中都应该提供发射该信号的方法（函数），而且这样的方法（函数）可以有多个。



**自定义响应 MySignal 信号的槽函数：**

```c++
class MyWidget:public QWidget{
    //Q_OBJECT 是一个宏，添加它才能正常使用 Qt 的信号和槽机制
    Q_OBJECT
signals:
    void MySignal(QString mess1,QString mess2);
public:
    void emitSignal(){
        emit MySignal(message1,message2);
    }
    //类的成员函数
    void recSlot1(QString mess){
        qDebug() << "执行 recSlot1() 成员函数，输出" << mess;
    }
//指明定义的是槽函数
public slots:
    void recSlot2(QString mess1,QString mess2){
        qDebug() << "执行 recSlot2() 槽函数，输出"<< mess1 << " " << mess2;
    }
public:
    QString message1;
    QString message2;
};
//全局函数
void recSlot3(){
    qDebug() << "执行 recSlot3() 全局函数";
}
```

程序中，重点关注 recSlot1()、recSlot2()、recSlot3() 这 3 个函数：

- recSlot1() 是 MyWidget 类内部的 public 成员函数，可以当做槽函数使用；
- recSlot2() 位于 MyWidget 类的内部，修饰它的关键字是 `public slots`。slots 和 emit 一样，是 Qt 扩展的一个关键字，专门用来修饰槽函数。也就是说，recSlot2() 是 MyWidget 类中的槽函数。
- recSlot3() 是全局函数，可以当做槽函数使用。

>  public 修饰的成员函数可以当做槽函数，为什么还要提供 slots 关键字？Qt4 中的槽函数只能是 slots 修饰的类成员函数，Qt5 中取消了这一限制，但考虑到要兼容旧的 Qt 版本，Qt5 保留了旧版本中 connect() 函数的语法格式，也保留了 slots 关键字。

**自定义信号和槽的完整实例:**

```c++
//main.cpp
#include <QApplication>
#include <QWidget>
#include <QDebug>
class MyWidget:public QWidget{
    //Q_OBJECT 是一个宏，添加它才能正常使用 Qt 的信号和槽机制
    Q_OBJECT
//信号函数
signals:
    void MySignal(QString mess1,QString mess2);
public:
    //发射信号的函数
    void emitSignal(){
        emit MySignal(message1,message2);
    }
    //普通类成员函数
    void recSlot1(QString mess){
        qDebug() << "执行 recSlot1() 成员函数，输出" << mess;
    }
//槽函数
public slots:
    void recSlot2(QString mess1,QString mess2){
        qDebug() << "执行 recSlot2() 槽函数，输出"<< mess1 << " " << mess2;
    }
public:
    QString message1;
    QString message2;
};
//全局函数
void recSlot3(){
    qDebug() << "执行 recSlot3() 全局函数";
}
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    //创建主窗口
    MyWidget mywidget;
    mywidget.message1 = "C语言中文网";
    mywidget.message2 = "http://c.biancheng.net";
    //类的成员函数作为槽函数
    QObject::connect(&mywidget,&MyWidget::MySignal,&mywidget,&MyWidget::recSlot1);
    //信号函数和槽函数相连接
    QObject::connect(&mywidget,&MyWidget::MySignal,&mywidget,&MyWidget::recSlot2);
    //全局函数作为槽函数
    QObject::connect(&mywidget,&MyWidget::MySignal,&recSlot3);
    mywidget.show();
    //发射 Signal 信号
    mywidget.emitSignal();
    return a.exec();
}
//MyWidget类的定义应该放到 .h 文件中，本例中将其写到 main.cpp 中，程序最后需要添加 #include "当前源文件名.moc" 语句，否则无法通过编译。
#include "main.moc"
```

执行程序，会弹出一个 myWidget 空白窗口，同时输出以下信息：

执行 recSlot1() 成员函数，输出 "C语言中文网"
执行 recSlot2() 槽函数，输出 "C语言中文网"  "http://c.biancheng.net"
执行 recSlot3() 全局函数



connect()函数连接信号和槽

connect() 是 QObject 类中的一个静态成员函数，专门用来关联指定的信号函数和槽函数。

Qt4 中的槽函数只能是 slots 修饰的类成员函数，Qt5 中取消了这一限制

**Qt5 版本4：**

connect() 函数最常用的语法格式是：

QObject::connect(const QObject ***sender**, const char ***signal**, const QObject ***receiver**, const char ***method**, Qt::ConnectionType type = Qt::AutoConnection)

各个参数的含义分别是：

- sender：指定信号的**发送者**；
- signal：**指定信号函数**，信号函数必须用 SIGNAL() 宏括起来；
- reveiver：指定**信号的接收者**；
- method：指定**接收信号的槽函数**，槽函数必须用 SLOT() 宏括起来；
- type 用于指定关联方式，默认的关联方式为 Qt::AutoConnection，通常不需要手动设定。

仍以实现“按下按钮后窗口关闭”为例，先创建一个窗口和一个按钮，如下所示：

```
QWidget widget;//定义一个按钮，它位于 widget 窗口中QPushButton But("按钮控件",&widget);
```

信号发送者是 But 按钮对象，要发送的信号是“按钮被点击”，可以用 QPushButton 类提供的 clicked() 信号函数表示；信号的接收者是 widget 主窗口对象，“窗口关闭”作为信号对应的槽，可以用 QWidget 类提供的 close() 函数表示。用 connect() 函数将 But 按钮的 

clicked() 信号函数和 widget 窗口的 close() 槽函数关联起来，实现代码如下：

```
connect(&But, SIGNAL(clicked()), &widget, SLOT(close()));
```

如此就实现了“按下按钮会关闭窗口”的功能。

**Qt5 版本：**

connect() 函数引入了新的用法，常用的语法格式是：

QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection)

和旧版本相比，**新版的 connect() 函数改进了指定信号函数和槽函数的方式**，**不再使用 SIGNAL() 和 SLOT() 宏**。

例如，**用新版 connect() 函数关联 But 按钮的 clicked() 信号函数和 widget 窗口的 close() 槽函数**，实现代码为：

```
connect(&But, &QPushButton::clicked, &widget, &QWidget::close);
```

可以看到，新版 connect() 函数指定信号函数和槽函数的语法格式是`&+函数所在类+函数名`。



一个信号函数关联多个槽函数、多个信号函数关联同一个槽函数

一个 connect() 函数只能关联一个信号函数和一个槽函数，程序中可以包含多个 connect() 函数，能实现以下几种效果：

- 关联多个信号函数和多个槽函数；
- **一个信号函数可以关联多个槽函数**，当信号发出时，与之关联的槽函数会一个接一个地执行，但它们执行的顺序是随机的，无法人为指定哪个先执行、哪个后执行；
- **多个信号函数可以关联同一个槽函数**，无论哪个信号发出，槽函数都会执行。


connect() 函数的 method 参数还可以指定一个信号函数，也就是说，信号之间也可以相互关联，这样当信号发出时，会随之发出另一个信号。



###  Qt信号槽调用流程

- Qt的信号和槽机制是一种类型安全的回调函数机制，并且可以跨线程进行通信。以下是信号和槽调用流程的简化描述：

  1. **定义信号和槽**:
     - 信号在类的私有部分使用`signals:`关键字定义。
     - 槽可以是公有、私有或受保护的成员函数，使用`slots:`关键字定义。
  2. **连接信号和槽**:
     - 使用`QObject::connect()`函数将信号和槽连接起来。当发射信号时，与之连接的槽将被调用。
  3. **发射信号**:
     - 使用`emit`关键字发射信号。例如: `emit mySignal(myParam);`。
  4. **信号处理**:
     - 当信号被发射时，Qt's meta-object system 捕获这个信号并查找与之连接的所有槽。
     - 对于`Qt::DirectConnection`类型的连接，与信号连接的槽将立即被调用，就像直接调用函数一样。
     - 对于`Qt::QueuedConnection`类型的连接（例如，当信号和槽在不同的线程中时），**信号参数被放入事件循环队列中**，接收线程在其事件循环中取出并调用槽。
  5. **参数传递**:
     - 当信号和槽连接时，可以传递参数。信号和槽的参数必须具有兼容的类型或可转换的类型。信号可以有更多的参数而槽可以有更少的参数。
  6. **断开连接**:
     - 使用`QObject::disconnect()`函数断开信号和槽的连接。

  为了支持信号和槽，Qt使用了一种称为“元对象编译器”(MOC)的特殊预处理步骤。MOC读取包含`Q_OBJECT`宏的类的头文件，并生成附加的C++代码。这些附加的代码包括用于支持信号和槽、Qt属性系统、运行时类型信息以及其他Qt特性的函数和数据。

**信号槽的实现：元对象编译器MOC**

元对象编译器MOC负责解析signals、slot、emit等标准C++不存在的关键字，以及处理Q_OBJECT、Q_PROPERTY、Q_INVOKABLE等相关的宏，生成moc_xxx.cpp的C++文件（使用黑魔法来变现语法糖）。比如信号函数只要声明、不需要自己写实现，就是在这个moc_xxx.cpp文件中自动生成的。

**moc的本质就是反射器**。





### 信号槽的连接方式

（connect的第五个参数）

1. `Qt::AutoConnection自动连接`： 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。
2. `Qt::DirectConnection直接连接`：**单线程用**：槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。在多线程环境下比较危险，可能会造成奔溃。
3. `Qt::QueuedConnection队列连接`：**多线程用**：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
4. `Qt::BlockingQueuedConnection`：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。

#### 信号槽在单线程、多线程工作

在Qt中，信号和槽机制可以在单线程和多线程环境中工作。信号和槽之间的交互方式依赖于它们所在的线程。

1. **同一线程中的信号和槽**:
   - 当**发送信号的对象和接收槽的对象**都在同一个线程中时，信号槽调用实际上是一个直接的函数调用。这意味着，当你发射一个信号，连接到这个信号的槽会立即执行，就像直接调用那个函数一样。
   - 默认的连接类型是`Qt::DirectConnection`，这意味着在同一个线程中，除非另有说明，否则信号和槽的交互都是同步的。
2. **不同线程中的信号和槽**:
   - 当**发送信号的对象和接收槽的对象**位于不同的线程中时，Qt会自动将连接类型更改为`Qt::QueuedConnection`。这意味着信号的发送实际上是将**消息放入事件队列**中，而**接收线程的事件循环将在某个时刻处理这些消息并执行相应的槽**。
   - 这种异步方式确保了线程安全，因为槽是在其所属的线程的上下文中执行的，而不是在发出信号的线程中。









## Headers

```c++
/最终将数据写入下位机和从下位机读出数据
//controlcentral   
1.com口的参数设置   
2.读取传感器数据    
3.
//configdialog      1.将面板中设置好的通信格式参数送给controlcentral
//dataexchange      1.将传进来的关节角度值按照通信协议打包好为str类型输出
                   //2.将获得的传感器数据解析为关节角度值和水平仪倾角输出

//机械臂绘制
1.读取模型数据
2.改变每个关节坐标原点的位置和姿态

 //传感器函数关系  传感器的正负方向要和关节运动的正负方向相同
 
 //旋转矩阵与欧拉轴，转角，四元数之间的相互转换
                   
Headers
includes.h  
mainwindow.h
mycanthread.h
robotvisualisationwidget.h
sendmsg.h
sensorfuntion.h
trajectory_plan.h
trajectoryDisplayWindow.h （openGLWindow)
    

```

### Sources

```c++
Sources
AutoGenerateTrajectory.cpp 
//(位移关节的初始值、正运动学解、计算在隧道坐标系下的起始点的初始转角>0、将初始位置进行正和逆运动学计算，然后得到第一个点的位置，后将第二个进行偏移w得到第二个点、偏距w，先计算出单边的点，然后通过偏距将另一边点补齐、再增加一个比d更小距离的路径点,并等距w获得对应的路径点)
//做一些改进，采样点的起始位置和喷浆的起始位置不同时，能够正确处理轨迹规划问题
    //1.记录下初始位置的位置向量和方向向量
    //2.设置好轨迹规划的参数
    //3.按照参数取得u，然后计算出key point，再偏置得到另一个key point
     //计算喷浆起始点的位置向量和方向向量
    //计算喷浆起始点位置偏离采样点集的开始或结束地方的距离
 checkjoint.cpp、checksensor.cpp（关节、传感器）
 coordinatesinfo.cpp（坐标信息）
 curvefit.cpp（曲线拟合）

```

###  controlcentral.cpp

```c++
 controlcentral.cpp
      //系统参数初始化，开启系统运行，系统状态的实时反馈
    //整个系统的执行入口
    //void ControlCentral::trajectoryPlanning()
    //调用轨迹规划程序实现运动仿真
    //1.计算出所有的轨迹点
    //2.求出插值点对应的关节角度值
    //3.将robotModel中的关节值更新
    //在自动轨迹规划内设置采样点
     //刷新斜面基准下的新方向增量,傻瓜半自动
    //刷新斜面基准，根据隧道的半自动
    //Gui->setTCP(jointsPoints);最后一根连杆的末端点位置
    //Gui->setPST(pst);末端点姿态
    //更新传感器数据值，并计算与理论值的误差
    //单位是度(and mm)
    //绘制dynamic关节角曲线图
     //绘制机械臂3D图
    //1.每个关节角的位置，2.每个关节角的RPY值
    //如果是仿真则采用仿真的数据，如果是在实时控制机械臂，则采用真实关节值更新三维动画
    /* 发送数据至下位机代码*/
    //设置一个数据开始发送的标志位，启动数据发送
    // 按一定的控制频率将数据发送给下位机
    //void ControlCentral::getP1()
    //input 关节角度  关节角度值来自于传感器的值
    //output 机械臂末端点
    //再利用坐标系转换  得到隧道坐标系下的位置
    //调用逆运动学引擎提供的正向运动学计算末端点的位置
```

#### glwidget.cpp

```c++
glwidget.cpp  
    //显示OpenGL图形并进行交互。这个类实现了一些基本的OpenGL绘制功能和事件处理，实现图形的渲染和交互操作。
    //void GLWidget::initializeGL() OpenGL初始化设置，包括深度测试、颜色设置、光照设置等。
    //void GLWidget::paintGL()  清空缓冲区，设置视图和光照，绘制3D场景。
    // 鼠标事件处理函数：mousePressEvent、mouseMoveEvent、wheelEvent 函数处理鼠标按下、鼠标移动和滚轮事件，用于进行交互操作，如旋转视图、缩放等。

```

#### gui.cpp

```c++
gui.cpp==看gui.h理解
    //定义了一个名为 gui 的类，它继承自 QObject 类，这意味着这个类可以使用 Qt 的信号和槽机制。这个类似乎与用户界面的操作和控制有关
    //构造函数：
//explicit gui(QObject *parent = nullptr);
这是 gui 类的构造函数，可以传入一个父级对象指针作为参数。

//成员函数：这个类包含了一系列函数，用于获取和设置不同的数据，如机器坐标、传感器值、参数等。这些函数还包括设置一些状态、更新图形、触发信号等操作。

//signals 部分：在这个部分声明了一些信号，这些信号可以在特定条件下被发射（emit）。这些信号与用户界面的事件交互有关，当某些事件发生时，信号会被触发。

//slots 部分：在这个部分声明了一些槽函数，这些函数通常用于响应特定的信号。当信号被触发时，与之相关联的槽函数会被调用。
    //这些槽函数对应于用户界面中的不同操作或按钮点击事件，例如手动模式选择、自动模式选择、XYZ模式选择、参数设置点击等。
    //设置通信格式的槽函数。
    //当机器坐标滑块或文本改变时触发的槽函数。
    //传感器校准的槽函数。
    //设置坐标的槽函数。
    //开启CAN通信的槽函数。
    //设置 传感器 文本的槽函数。
    //设置 点 文本的槽函数。
    // 速度变化的槽函数。

//私有成员变量：在这个类中声明了一些指向其他类的指针，如 MainWindow*、ConfigDialog* 等，这些可能是与用户界面和其他部分相关的类。
    MainWindow* mainWindow;//MainWindow 是应用程序的主窗口，用于显示用户界面。
    ConfigDialog* configDialog;//用于显示和处理配置对话框，允许用户设置一些参数或选项
    Calibration* sensorCalibration;//用于处理传感器的校准操作
    CoordinatesSet* coordinatesSet;//用于管理和处理坐标
    curveFitParameterSet* curfitInterface;//用于管理和处理曲线拟合操作的参数

//总体来说，这个 gui 类似乎用于管理用户界面的各种操作、设置和状态。它通过信号和槽机制实现了用户界面与代码逻辑之间的通信和交互。这个类可能是在Qt框架中用于用户界面设计和操作的一部分。
```

#### inversekinematicsengine.cpp

```c++
inversekinematicsengine.cpp//执行逆向运动学计算
//setTCP(Point newTCP)末端点位置
    //设置机器人的 DH 参数
    //DH 参数是一组数值，用来定义机器人的关节和连杆之间的几何关系，从而建立起机器人的坐标系。每个关节都有自己的 DH 参数，包括以下几个值：
//a： 这是沿着前一个关节 Z 轴的偏移距离。
//alpha： 这是绕前一个关节 Z 轴旋转的角度。
//d： 这是沿着前一个关节 X 轴的偏移距离。
//theta： 这是绕前一个关节 X 轴旋转的角度。
//通过这些参数，可以构建机器人每个关节的坐标系，并通过变换矩阵来描述关节之间的变换关系。DH 参数的使用使得机器人的正向运动学（从关节角度计算末端执行器位置）和逆向运动学（从末端执行器位置计算关节角度）的计算变得相对简单，减少了运动学分析的复杂性。
    //设置末端点的姿态（ApproachVector）
    //当前计算点的前一点的关节角度值
    //根据输入的目标关节角度数组，将其进行处理后赋值给类成员变量 TargetJoint
    //设置当前计算点的前一点的机器坐标值
```

#### joystick.cpp

```c++
joystick.cpp
    // openJoy()打开手柄，开启对手柄的检测功能
    // 轮询检测手柄按键函数
paintTheroyTrajectory(QVector<Point> t)//理论曲线接口
paintpracticeTrajectory(vector<double> p)//实际曲线接口
    
main.cpp
    #include "mainwindow.h"：应用程序的主窗口类的声明。

#include <QApplication>： Qt 框架的应用程序类的头文件。

#include "inversekinematicsengine.h"：逆向运动学引擎类的声明。

#include "trajectoryinterpolator.h"：轨迹插值器类的声明。

#include "AutoGenerateTrajectory.h"：自动生成轨迹的类的声明。

#include "robotmodel.h"：机器人模型类的声明。

#include "gui.h"：图形用户界面（GUI）类的声明。

#include "controlcentral.h"：控制中心类的声明。

int main(int argc, char *argv[])：这是主函数的定义，它接受命令行参数 argc 和 argv[]。

QApplication a(argc, argv);：创建了一个 QApplication 类的实例 a，并传递命令行参数给它，用于初始化 Qt 应用程序。
```

#### mainwindow.cpp

```c++
mainwindow.cpp //初始化主窗口以及主窗口内各个部件的状态、样式、文本
//MainWindow(QWidget *parent): QMainWindow(parent), ui(new Ui::MainWindow)  调用 ui 对象的 setupUi 函数，用于将界面的设计布局应用到当前主窗口对象。
    //滑动条和数值框的值后面应该根据传感器读取的数值进行初始化
    //手动输入值的初始化,这里的值应该设置为传感器获得的数据
    //on_SettingFinish_clicked()自动化轨迹生成参数设置好后，选中设置完成，才能进行仿真和启动
    //如果从手动模式切换到自动控制模式时，参数设置完成按钮已经被按下，参数不能被读入，重新选中才能读入参数
    void MainWindow::on_Simulator_clicked()
{
    //调用函数实现仿真运动
    if(selectSimulator)
    {
        qDebug() << "simulator" << endl;
        selectSimulator = false;
        selectStart = true;
        ui->Simulator->setChecked(true);
        ui->Start->setChecked(false);
        ui->Stop->setChecked(false);
        ui->Reset->setChecked(false);
        ui->Close->setChecked(false);
        emit SimulatorButtonClicked();
    }
}
void MainWindow::on_Start_clicked()
{//读取保存好的关节组数据文件，发送到下位机
    
//包含两个 MainWindow 类的槽函数，分别是 on_Simulator_clicked 和 on_Start_clicked，用于响应名为 Simulator 和 Start 的按钮的点击事件
```

#### mycanthread.cpp

```c++
mycanthread.cpp、mycanthread_recev.cpp(看代码更好)
    //connect(clock, SIGNAL(timeout()), this, SLOT(testConnectStatus())); 连接 clock 的超时信号到 MyCanThread 类的 testConnectStatus() 槽函数。
// ReceiveCANThread();//接收CAN数据
   
    
    #include "mycanthread.h"
#include <QDebug>

MyCanThread::MyCanThread():QThread()
{
    stopped = false;//线程是否停止
    devtype=3;//USBCAN1
    devind=0;//
    res=0;//
    canind=0;//CAN
    reftype=0;//
    bool ok;
    clock = new QTimer;
    clock->setInterval(80);
    VCI_ERR_INFO vei;
    VCI_CAN_OBJ preceive[100];
    VCI_CAN_OBJ psend;
    int baud=0x10000000;//
    openSuccess = false;
    ConnectError = true;
    send_flag = false;
    receData = "38 00 00 00 00 00 00 37";
    clock->start();
    //连接 clock 的超时信号到 MyCanThread 类的 testConnectStatus() 槽函数。
    connect(clock, SIGNAL(timeout()), this, SLOT(testConnectStatus()));
}

void MyCanThread::run()
{
    while(!stopped)
    {
        ReceiveCANThread();//接收CAN数据
    }
    stopped = false;
}

void MyCanThread::testConnectStatus()
{
//    qDebug()<< "探测CAN连接状态";
    VCI_CAN_OBJ psend;
    //
    ULONG Tr;
    psend.ID=id;    //帧 ID
    psend.SendType=0;   //0 时为正常发送（发送失败会自动重发，重发最长时间为 1.5-3 秒）
    psend.RemoteFlag=0; //是否是远程帧。=0 时为为数据帧，=1 时为远程帧（数据段空）
    psend.ExternFlag=0;     //是否是扩展帧。=0 时为标准帧（11 位 ID），=1 时为扩展帧（29 位 ID）
    psend.DataLen=8;    //数据的有效字节长度，最大为8个字节
    VCI_ERR_INFO vei;
//    for (int i=0; i < 8; i++)
//    {
//        psend.Data[i]='00';
//    }

//    Tr=VCI_Transmit(devtype,devind,canind,&psend,1);    //发送数据
//    if(Tr != 1){
//        ConnectError = true;
//        qDebug()<< "发送失败";
//    }else{
//        qDebug()<< "连接正常";
//    }
    VCI_CAN_STATUS vcs;
    //DWORD dwRel;
//    if(VCI_ReadCANStatus(devtype,devind,canind,&vcs) == ERR_CMDFAILED)
//    {
//        qDebug()<< "连接失败";
//    }else{
//        qDebug()<< "连接正常";
//    }
//    if(VCI_ReadErrInfo(devtype,devind,canind,&vei) == ERR_NO_STARTUP)
//    {
//        qDebug()<< "连接失败";
//    }else{
//        qDebug()<< "连接正常";
//    }
}

void MyCanThread::stop()
{
    stopped = true;
}

void MyCanThread::ReceiveCANThread()
{
    VCI_ERR_INFO vei;
    VCI_CAN_OBJ preceive[1000];
    ULONG res = 2;
    //int count;

    res=VCI_GetReceiveNum(devtype,devind,canind);//获取缓冲区中接收但尚未被读取的帧数

    if(res<=0)//未接收到数据或操作失败
    {
//        qDebug() << "未收到下位机数据";
//        ConnectError = true;
        if(VCI_ReadErrInfo(devtype,devind,canind,&vei)!=STATUS_ERR)
        {
            //qDebug()<<QStringLiteral("3-7  1:")<<QString::number(vei.ErrCode,16);
        }
    }else{
        res=VCI_Receive(devtype,devind,canind,preceive,1000,100);//200ms     接收数据

//        qDebug()<<"Frame ID"<<res;
            if(res==4294967295)//4294967295=0xFFFFFFFF
            {
                if(VCI_ReadErrInfo(devtype,devind,canind,&vei)!=STATUS_ERR)
                {
                    qDebug()<<"Read Data failed"<<"Error Data:"<<QString::number(vei.ErrCode,16);
                }
            }else{
                //qDebug() << "接收成功";
                emit my_signal(preceive, res);
            }
    }

}
// 在 CAN 通信中传输数据
void MyCanThread::TransmitCANThread(unsigned int id,unsigned char *ch)
{
    VCI_CAN_OBJ psend;
    //
    ULONG Tr;
    psend.ID=id;    //帧 ID
    psend.SendType=0;   //0 时为正常发送（发送失败会自动重发，重发最长时间为 1.5-3 秒）
    psend.RemoteFlag=0; //是否是远程帧。=0 时为为数据帧，=1 时为远程帧（数据段空）
    psend.ExternFlag=0;     //是否是扩展帧。=0 时为标准帧（11 位 ID），=1 时为扩展帧（29 位 ID）
    psend.DataLen=8;    //数据的有效字节长度，最大为8个字节
    for (int i=0; i < 8; i++)
    {
        psend.Data[i]=ch[i];
    }

    Tr=VCI_Transmit(devtype,devind,canind,&psend,1);    //发送数据
    if(Tr==1){
//        qDebug()<< "发送成功";
    }
}

bool MyCanThread::getOpenStatus()
{
    return this->openSuccess;
}

bool MyCanThread::getConnectStatus()
{
    return this->ConnectError;
}

void MyCanThread::OpenCANThread()
{
//    bool ok;
    VCI_ERR_INFO vei;
//    VCI_CAN_OBJ preceive[100];
//    VCI_CAN_OBJ psend;
    int baud=0x01000000;    //参数有关数据缓冲区地址首指针

//    设置设备参数 canind = 0
//        if(VCI_SetReference(devtype,devind,canind,reftype,&baud)==STATUS_ERR){
//            qDebug("set reference error");
//            VCI_CloseDevice(devtype,devind);
//            return;
//        }

   //打开设备
    if(VCI_OpenDevice(devtype,devind,res)==STATUS_ERR)//
    {
        if(VCI_ReadErrInfo(devtype,devind,canind,&vei)!=STATUS_ERR)
        {
        qDebug()<<"Open failed"<<QString::number(vei.ErrCode,16);
        }else
            qDebug()<<"error";
        return;
    }else{
            qDebug()<<"open successed";
    }


    //初始化
    VCI_INIT_CONFIG init_config;
    init_config.Mode=0;//正常模式，1为只听模式
    init_config.Filter=1;//滤波方式
    //can
    //波特率是250Kbps
    init_config.Timing0=0x01;//定时器0
    init_config.Timing1=0x1c;//定时器1
    //接受的地址
    init_config.AccCode=0x10000000;//验收码
    init_config.AccMask=0xFFFFFFFF;//屏蔽码
    //
    if(VCI_InitCAN(devtype,devind,canind,&init_config)==STATUS_ERR){
        qDebug("Init Error");
        VCI_CloseDevice(devtype,devind);
        return;
    }else
        qDebug()<<"Init successed";


    //读取设备信息
    VCI_BOARD_INFO vbi;
    if(VCI_ReadBoardInfo(devtype,devind,&vbi)!=STATUS_ERR){
        qDebug()<<QStringLiteral("Count_Channel:")<<vbi.can_Num;
        qDebug()<<QStringLiteral("version_hardware:")<<vbi.hw_Version;
        qDebug()<<QStringLiteral("version_APIlib:")<<vbi.in_Version;
        qDebug()<<QStringLiteral("Num_Interrupt:")<<vbi.irq_Num;
        qDebug()<<QStringLiteral("can_Channel:")<<vbi.can_Num;
    }
    //清除缓冲区
    VCI_ClearBuffer(devtype,devind,canind);

    //启动设备
    if(VCI_StartCAN(devtype,devind,canind)==STATUS_ERR){
        qDebug()<<"start fail";
        VCI_CloseDevice(devtype,devind);
        return;
    }else{
        openSuccess = true;
        ConnectError = false;
        qDebug()<<"start successed";
    }
}

void MyCanThread::CloseCANThread()
{
    VCI_CloseDevice(devtype,devind);
    openSuccess = false;
    ConnectError = true;
    qDebug()<<"closed";
}


//        qDebug()<< "id="<< id << endl;

//        //判断ID=16#14的接收缓存，如果是38 22 22 22 22 22 22 37 则发送数据
//        if (id == 20){
//            if (QString::number(preceive[i].Data[0],16) == "38"
//                    and QString::number(preceive[i].Data[1],16) == "22"
//                    and QString::number(preceive[i].Data[2],16) == "22"
//                    and QString::number(preceive[i].Data[3],16) == "22"
//                    and QString::number(preceive[i].Data[4],16) == "22"
//                    and QString::number(preceive[i].Data[5],16) == "22"
//                    and QString::number(preceive[i].Data[6],16) == "22"
//                    and QString::number(preceive[i].Data[7],16) == "37"){
//                send_flag = true;
//                //发送一个信号，开启发送线程
//                emit startSendThread();
//            }
//        }

//        if(id == 20)
//        {
//            qDebug()<< "接收到下位机要求新一组数据的信息";
////            QString s="0x";
////            qDebug()<<QStringLiteral("FtameID:")<<s.append(QString::number(preceive[i].ID,16));
////            qDebug()<<QStringLiteral("FrameData:")<<QString::number(preceive[i].Data[0],16)<<QString::number(preceive[i].Data[1],16)
////                    <<QString::number(preceive[i].Data[2],16)<<QString::number(preceive[i].Data[3],16)
////                    <<QString::number(preceive[i].Data[4],16)<<QString::number(preceive[i].Data[5],16)
////                    <<QString::number(preceive[i].Data[6],16)<<QString::number(preceive[i].Data[7],16);
////            qDebug()<<QStringLiteral("FrameLength:")<<preceive[i].DataLen;
//        }
  }

}
```



#### pwmAndVelocity() .cpp 

用于计算电机的脉宽调制（PWM）信号和速度的函数

#### robotvisualisationwidget.cpp

```c++
robotvisualisationwidget.cpp //机器人的可视化状态
    //绘制机械臂 位置
    // jointsPostures = rot;姿态
    // 更新关节的位置和姿态
    // glRotatef(GLfloat(-(coords.f_1)*180/PI), 0.0, 1.0, 0.0);OpenGL中的旋转函数，根据角度进行旋转操作。实现机器人可视化中的姿态变换，以在三维空间中正确显示机器人的朝向
    //  glTranslatef(340.6f, 0.0, -45.25f);OpenGL中的平移函数，用于在三维空间中平移物体或模型。控制机器人可视化中的位置调整，以便在三维空间中正确放置机器人的位置
    //绘制末段点
    //绘制世界坐标系的XYZ轴
```

#### sendmsg.cpp

```c++
sendmsg.cpp  通信==用于发送 CAN 消息到下位机
   
#include "sendmsg.h"
#include <QCoreApplication>
#include <iostream>
//初始化发送和接收线程，并建立线程之间的通信连接。这样，在实例化 sendMsg 对象时，就可以在合适的时候发送和接收 CAN 消息
sendMsg::sendMsg()
{
    qRegisterMetaType<VCI_CAN_OBJ>("VCI_CAN_OBJ");
    //注册can结构体， 以便在信号和槽之间传递 CAN 数据
    qRegisterMetaType<PVCI_CAN_OBJ>("PVCI_CAN_OBJ");//注册can结构体
    qRegisterMetaType<CAN_SEND_FRAME_STRUCT>("CAN_SEND_FRAME_STRUCT");
    // 连接的 CAN 设备和通道
    deviceTye = 3;
    device = 0;
    chanel = 0;

    makedata = new makeData;
    sendThreadCAN1 = new MyCanThread;
    //处理发送 CAN 消息的线程。然后将该线程移到一个独立线程 sendThread 中执行
    sendThreadCAN1->moveToThread(&sendThread);
    processMsg = new MyCanThread_recev;
    //处理接收 CAN 消息的线程。然后将该线程移到一个独立线程 processThread 中执行
    processMsg->moveToThread(&processThread); 
 
    connect(sendThreadCAN1,SIGNAL(my_signal(PVCI_CAN_OBJ,int)),processMsg,SLOT(ReceiveCANThread(PVCI_CAN_OBJ,int)));
    //使用 connect 函数将 sendThreadCAN1 的信号连接到 processMsg 的槽，用于将接收到的 CAN 消息传递给消息处理线程。
    connect(processMsg, SIGNAL(startSendThread()), this, SLOT(transmitSendInfo()));
    //使用 connect 函数将 processMsg 的信号连接到 this 的槽 transmitSendInfo()，以便在消息处理线程接收到信息后触发一个发送信号。
}


void sendMsg::setJoints(QVector<int> joints)
{
    this->joints = joints;
}

void sendMsg::setPWM(QVector<int> pwm)
{
    this->pwm = pwm;
}

// 此处对于模式切换有改动，主要适应于半自动和手动模式，如果使用全自动模式请使用
// 根据所选的运动模式，发送控制模式的命令到下位机。根据不同的模式，发送相应的数据帧，以告知下位机切换到对应的控制模式。
void sendMsg::sendSelectMode(KinematicsMode mode)
{
    unsigned char data_from_text[8];
    unsigned int start_id = 400;//0x190
    QString start_char;
    //当控制模式为自动模式时，代码向 start_char 字符串中追加了一串表示 CAN 数据帧内容的固定十六进制数字。这个字符串可能在后续的 CAN 通信中被使用，可能是作为控制信息发送给下位机。
    if(mode == KinematicsMode::Automation)
    {
        std::cout << "Automation" << std::endl;
        start_char.append("37 01 01 01 01 01 01 38");
    }
    else if(makedata->getchangemode() == true)
    {
        std::cout << "XYZ" << std::endl;
        start_char.append("37 02 02 02 02 02 02 38");
    }
    else if(makedata->getchangemode() == false)
    {
        std::cout << "manual" << std::endl;
        start_char.append("37 03 03 03 03 03 03 38");
    }

     //告诉下位机 机械臂的控制模式
     for(int i = 0; i < 8; i++)
     {
         data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
     }
     \
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
     QThread::msleep(5);
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
          QThread::msleep(5);
sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
}

void sendMsg::sensorCalibration(){
     makedata->savepos();
}

void sendMsg::sendEndFlag()
{
}
// 启动发送线程和处理线程，用于处理发送和接收 CAN 消息
void sendMsg::start()
{
    sendThreadCAN1->OpenCANThread();//打开 CAN 设备
    sendThreadCAN1->start();//启动 CAN 发送线程
    sendThread.start();//启动 sendThread 和 processThread 线程
    processThread.start();
}
void sendMsg::stopSendAndRecv()
{
    sendThreadCAN1->stop();   //停止从 CAN 总线接收数据
}
void sendMsg::close()//关闭和终止与 CAN 通信相关的线程
{
    sendThread.quit();//停止发送线程
    processThread.quit();//停止接收线程
    sendThreadCAN1->stop();//停止 CAN 接收线程
    sendThreadCAN1->CloseCANThread();//关闭 CAN 设备
}
//发送一个信号，表示开始发送消息。该信号会被连接到相应的槽函数，以实现数据的发送
void sendMsg::transmitSendInfo()
{
    emit start_sendMessage();
}
bool sendMsg::getOpenStatus()//CAN 设备是否已打开
{
    return sendThreadCAN1->getOpenStatus();
}
bool sendMsg::getConnectStatus()// CAN 设备是否已连接
{
    return sendThreadCAN1->getConnectStatus();
}





重点：




//发送 CAN 消息
void sendMsg::sendMessage()
{
    //采用事件触发机制，而不是盲等
    //如果上位机接收到下位机的信息，需要发送下一组关节角数据，则开启线程，启动数据发送

    //1.写明ID地址    2.制造数据
    //下位机发送了启动信号,则改变send_flag = true;while send_flag =true {发送数据,改变send_flag=flase,等待下位机通知再次发送} //停止发送按钮也可以直接改变send_flag=false
    QString transmit_str = QStringLiteral("ID:");
    unsigned int id = 0, start_id=16;

    unsigned char data_from_text[8];
    QStringList list1;
    QString start_char;
    start_char.append("38 33 33 33 33 33 33 37");
    //当没有发送完计算出的所有关节角组，一直等待发送

    //将关节角和 PWM 数据发送到 CAN 总线上，以便与下位机进行通信和控制。每个数据包的格式都经过了转换，然后通过 sendThreadCAN1 对象的方法进行发送
    // PWM=脉冲宽度调制数据，用于控制电机的速度或位置
    
     //先发送一帧数据给下位机，告诉下位机要开始接收数据，38 33 33 33 33 33 33 37
     for(int i = 0; i < 8; i++)
     {
         data_from_text[i] = hex_str_to_int((unsigned char *)start_char.section(' ',i,i).trimmed().toStdString().c_str());
     }
     sendThreadCAN1->TransmitCANThread(start_id,(unsigned char *)data_from_text);
    //将 data_from_text 数组中的数据发送到 CAN 总线上，使用 ID start_id

     unsigned int pwm_ID = 10;//构造 PWM 数据的 ID
     for (int i=0;i < 6;i++) {
        id = static_cast<unsigned int>(i + 1);        //ID: 1~6
        pwm_ID++;
        sendData = makedata->rawData2sendData(joints[i]);//将关节角数据转换为发送给下位机的格式
        sendData_pwm = makedata->rawData2sendData(pwm[i]);//将 PWM 数据转换为发送给下位机的格式
        //qDebug() << "sendData " << sendData << endl;
        //makedata->receData2realData(sendData);
        //qDebug() << "realJoint " << makedata->getRealValue();

        //发送关节角
        for(int j = 0; j < 8; j++)
        {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(id,(unsigned char *)data_from_text);//将关节角数据发送到 CAN 总线上，使用相应的 ID

        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear();
        sendData_pwm.clear();
    }


}
// 发送 PWM 数据到下位机的代码块
void sendMsg::sendMessages(){
     //作为新的发送器
    QString sendData_pwm;


    unsigned char data_from_text[8];

     unsigned int pwm_ID = 0x191;
    sendData_pwm = makedata->rawData6sendData(pwm);
//    qDebug() << "sendData_pwm:" << sendData_pwm<<endl;
//从 pwm 数组中获取 PWM 数据，并将其转换为一种适合发送给下位机的格式

        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);
//将转换后的 PWM 数据以指定的 ID (pwm_ID) 发送到 CAN 总线上
        sendData.clear();
        sendData_pwm.clear();
}

//发送 XYZ 模式的消息。它包括创建用于发送数据的缓冲区、将 PWM 数据转换为适合发送的格式，以及通过 sendThreadCAN1->TransmitCANThread 方法将数据发送到 CAN 总线上。
void sendMsg::sendXYZmess(){
    QString sendData_pwm;


    unsigned char data_from_text[8];

     unsigned int pwm_ID = 0x191;
    sendData_pwm = makedata->rawData6sendData(pwm);
//    qDebug() << "sendData_pwm:" << sendData_pwm<<endl;


        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear();
        sendData_pwm.clear();
}


//发送自动模式的消息。与 sendXYZmess() 函数类似，它也包括创建缓冲区、转换 PWM 数据并发送数据
void sendMsg::sendAUTOmess(){
    QString sendData_pwm;


    unsigned char data_from_text[8];

     unsigned int pwm_ID = 0x191;
    sendData_pwm = makedata->rawData6sendData(pwm);
//    qDebug() << "sendData_pwm:" << sendData_pwm<<endl;


        //发送PWM
        for (int j = 0; j < 8; j++) {
            data_from_text[j] = hex_str_to_int((unsigned char *)sendData_pwm.section(' ',j,j).trimmed().toStdString().c_str());
        }
        sendThreadCAN1->TransmitCANThread(pwm_ID,(unsigned char *)data_from_text);

        sendData.clear();
        sendData_pwm.clear();
}
//根据十六进制表示将字符转换为整数
int sendMsg::hex_str_to_int(unsigned char *ch)
```

#### timingtransmitter.cpp

```c++
timingtransmitter.cpp 定时发送控制信号
#include "timingtransmitter.h"
#include "QDebug"
#include "math.h"
#include <QDateTime>
#define PI 3.14159265358979323846
    //TimingTransmitter 类是一个继承自 QThread 的类，用于实现定时发送控制信号
TimingTransmitter::TimingTransmitter():QThread()
{
    alarm = new QTimer;
    alarm->setInterval(25);//定时器的间隔为 25 毫秒
    alarm->start();
    connect(alarm,SIGNAL(timeout()),this,SLOT(onTransmitter()));
    //连接定时器的 timeout 信号到 onTransmitter 槽函数，实现定时触发
}
//设置控制模式，即切换控制模式。根据不同的模式，定时器的触发行为可能会改变
void TimingTransmitter::modeselect(KinematicsMode kinematicsmode){
    this->kinematicsmode = kinematicsmode;
}


//onTransmitter 槽函数是定时触发的主要处理逻辑。根据当前的控制模式，它会发射不同的信号，即 start_XYZ 或 start_auto，从而触发相关的控制操作
void TimingTransmitter::onTransmitter(){

    if((this->kinematicsmode == KinematicsMode::manual)) {
//        qDebug() << "定时器发送成功！" << "manual" << endl;
    }
    else if(this->kinematicsmode == KinematicsMode::Automation){
//        qDebug() << "定时器发送成功！" << "Automation" << endl;
        AUTOcontrol();
    }else {
//        qDebug() << "定时器发送成功！" << "XYZ" << endl;
        XYZcontrol();
    }
}

//在控制模式为 XYZ 时执行的操作。它会通过 emit start_XYZ() 发射一个信号，可能是用来触发某些与 XYZ 控制相关的操作
void TimingTransmitter::XYZcontrol(){
        emit start_XYZ();
}


//控制模式为 Automation 时执行的操作。它会通过 emit start_auto() 发射一个信号，可能是用来触发某些与自动化控制
void TimingTransmitter::AUTOcontrol(){
            emit start_auto();
```

#### sensorFunction.cpp

```C++ 
sensorFunction.cpp //对传感器数据和关节数据进行处理
//设置传感器数据、关节数据和一个参数 k
//getJointValue(int sensor)：函数用于返回一个传感器值作为关节数
    //fixFun()：修正操作，根据传感器数据计算 tmpJoint 并更新 offset 的值  == 根据基准值调整传感器数据
```

#### trajectory_plan.cpp

```c++
trajectory_plan.cpp、trajectoryDisplayWindow.cpp、trajectoryinterpolator.cpp
    // 直线路径插补相关函数
    // 将姿态插补和直线路径插补封装在一起
    // 窗口类，用于显示轨迹（或路径）的信息
    
    
    //生成机械臂运动的轨迹点和姿态，可以根据提供的点、姿态和参数进行固定步长插值或时间插值。这些插值方法可以用于控制机械臂在特定路径上的运动
    //轨迹插值器。这个类的作用是计算和生成机械臂运动的轨迹点和姿态，以便控制机械臂在特定路径上进行运动。它可以使用固定步长插值或时间插值的方法来生成轨迹点和姿态，以实现机械臂的运动规划和控制。
trajectoryinterpolator.h
  //class trajectoryinterpolator : public QObject
    //继承自 QObject，具有信号和槽的特性，用于轨迹的插值计算和规划
    成员函数：
void setStepLength(double step);：设置固定步长插值中的步长。
void setStartPoint(Point p);：设置轨迹的起始点。
void setFinishPoint(Point p);：设置轨迹的结束点。
void setStartPosture(ApproachVector posture);：设置轨迹起始点的姿态。
void setFinishPosture(ApproachVector posture);：设置轨迹结束点的姿态。
void setTimeInterPara(double v, double r, double w, double n_segment);：设置时间插值所需的参数，包括机械臂喷头移动速度、过渡圆弧半径、轨迹宽度和弧线段数量。
void stepInterpolator();：进行固定步长插值，用于生成轨迹点，但不能控制喷头的移动速度。
void timeInterpolator();：进行时间插值，计算生成插值点，可以控制喷头的移动速度。
void calculate();：根据设置的参数计算轨迹和姿态。
QVector<Point> getTrajectory();：获取生成的轨迹点。
QVector<ApproachVector> getPosture();：获取生成的轨迹姿态。
    
```

#### trajectoryDisplayWindow.cpp

```c++
trajectoryDisplayWindow.cpp
    //承自 QGLWidget 的自定义 OpenGL 窗口类，用于在 GUI 中显示 3D 图形
OpenGLWindow :: OpenGLWindow(QWidget *parent)
       :QGLWidget(parent)
{
    m_scloe = -30;//缩放参数
    m_rotx = 5;//绕 X、Y、Z 轴的旋转角度，用于控制模型的旋转效果
    m_roty = 5;
    m_rotz = 5;
    m_count = 0;//跟踪绘制次数
    m_isize = 0;//控制渲染的某些元素的大小
    m_anglev = 8;//控制渲染中的角度

}

OpenGLWindow::~OpenGLWindow()
{
}

void OpenGLWindow::initializeGL()
{
    glClearColor(1, 1, 1, 1.0);//GL背景色=白色
    glShadeModel(GL_SMOOTH);//着色模式==平滑着色模
    glEnable(GL_DEPTH);//启用深度测试。深度测试是OpenGL中用来控制绘制顺序的一个重要机制，确保远处的对象不会遮挡近处的对象。
}

//用于在OpenGL窗口大小改变时重新配置OpenGL的视口设置和投影矩阵配置，以适应新的窗口尺寸
void OpenGLWindow::resizeGL(int w, int h)
{
    if (h == 0)//防止height为0
    {
        h = 1;
    }
    glViewport(0, 0, w, h);//重置当前的视口 ==指定了渲染窗口中可以用来显示图形的区域

    glMatrixMode(GL_PROJECTION);//选择投影矩阵  ==选择投影矩阵模式，以便设置透视投影矩阵
    glLoadIdentity();//重置投影矩阵
    gluPerspective(45.0, w / h, 0.1, 1000.0);//建立透视投影矩阵 ==四个参数：视场角、宽高比、近裁剪面和远裁剪面

    glMatrixMode(GL_MODELVIEW);//选择模型观察矩阵
    glLoadIdentity();//重置模型观察矩阵

}
//OpenGL窗口中绘制3D场景，包括坐标轴、网格、圆柱体等元素。
//这些元素的绘制是通过OpenGL的绘制函数和变换函数来实现的，以达到在3D空间中可视化显示场景的效果
void OpenGLWindow::paintGL()
{
    //qDebug() << "paintGL with t_vetorx.size() = " << t_vetorx.size();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//清除屏幕和深度缓存
    glLoadIdentity();//重置当前的模型观察矩阵。在glLoadIdentity()调用之后，函数返回之前，添加代码来创建基本的形
                     //目前所做的就是将屏幕清除成前面所决定的颜色，清除深度缓存并且重置场景，仍然没绘制任何东西。
                     //glPolygonMode(GL_FRONT_AND_BACK ,GL_LINE );
                     //前后面，填充方式（点point、线line、FILL）

    //OpenGL 的平移、旋转函数显示窗口 
    glTranslatef(-1, -4,m_scloe);
    glRotatef(m_rotx, 1.0, 0.0, 0.0);
    glRotatef(m_roty-40, 0.0, 1, 0.0);
    glRotatef(m_rotz-2, 0.0, 0.0, 1);
    GLUquadricObj *objCylinder = gluNewQuadric();//创建一个新的二次曲面对象，这里用于绘制圆柱体

    int pt = 12;//xyz轴的长度
    int num = 12;//控制网格疏密

    //Y轴
    glColor3f(0, 1, 0);
    glLineWidth(5);
    glBegin(GL_LINES);//开始绘制线段。
        glVertex3f(0,0,0);// 绘制线段的顶点坐标
        glVertex3f(pt,0,0);
    glEnd();              // 结束绘制线段

    //网格
    //Y
    glPushMatrix();

    glColor3f(0.8, 0.8, 0.8);
    glTranslatef(-m_isize, -m_isize, -m_isize);
    GLGrid(0, 0, 0, pt, 0, pt, num);//绘制网格
    glPopMatrix();

    glPushMatrix();
    glColor3f(0, 1, 0);
    glTranslatef(pt, -m_isize, -m_isize);
    glRotatef(90, 0, 1, 0.0);
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);//绘制圆柱体
    glPopMatrix();

    //Z
    glPushMatrix();
    glTranslated(-m_isize, m_isize, -m_isize);
    glRotatef(-90, 1.0, 0.0, 0.0);
    glColor3f(0.8, 0.8, 0.8);
    GLGrid(0, 0, 0, pt, 0, pt, num);
    glPopMatrix();

    glPushMatrix();
    glColor3f(0, 0, 1);
    glTranslatef(-m_isize, pt, -m_isize);
    glRotatef(-90, 1, 0, 0);
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);
    glRasterPos3d(5.0,5.0,5.0);//设置光栅位置，用于在场景中绘制文字
    glPopMatrix();

    //X
    glPushMatrix();                           //push,pop栈使用
    glTranslatef(-m_isize, -m_isize, -m_isize);
    glRotatef(90, 0.0, 0.0, 1.0);              //网格所在空间位置
    glColor3f(0.8, 0.8, 0.8);                  //网格颜色
    GLGrid(0, 0, 0, pt, 0, pt, num);
    glPopMatrix();

    glPushMatrix();
    glColor3f(1, 0, 0);                         //箭头颜色
    glTranslatef(-m_isize, -m_isize, pt);
    glRotatef(90, 0, 0, 1);
    gluCylinder(objCylinder, 0.5, 0.0, 1, 100, 1);//小箭头
    glPopMatrix();

    LabelXYZ();

/*
 * 调用时只需将下两个接口进行调用，出入具体的嵌套接口即可
*/
    updateTheroyTraj();
    updatePracticeTraj();
}

//绘制坐标轴标签的函数 LabelXYZ()，它绘制了X、Y和Z轴上的字母标签
void OpenGLWindow::LabelXYZ()
{
    /*********************X,Y,Z字母***************************************/
        GLfloat size2 = 2.0;
        glLineWidth(size2);
        //通过一系列的数组定义（a1、b1、c1、a2、b2、c2、a3、b3、c3）定义了每个轴上的标签的位置
        double a1[3]= {6.5,6.75,7};
        vector<double> n1_vetorx(a1,a1+3);
        double b1[3]= {13.0,13.0,13.0};
        vector<double> n1_vetory(b1,b1+3);
        double c1[3]= {-0.75,-0.5,-0.25};
        vector<double> n1_vetorz(c1,c1+3);
        //调用OpenGL的绘制函数来绘制每个轴上的标签
        if (n1_vetorx.size() >= 2) {                              //X
            glBegin(GL_LINE_STRIP);//开始绘制线段，依次添加顶点坐标
            glTranslatef(-m_isize, -m_isize, -m_isize);
            glColor3f(1, 0, 0);//置颜色为红色

     //Y
            glBegin(GL_LINE_STRIP);
            glTranslatef(-m_isize, -m_isize, -m_isize);//对每个轴上的标签进行平移，以适应场景中的位置
            glColor3f(0, 1, 0);

            glVertex3f(n2_vetorx[0], n2_vetorz[0], n2_vetory[0]);
            glEnd();
            glFlush();
        }

        double a3[3]= {0.0,0.0,0.5};
        vector<double> n3_vetorx(a3,a3+3);
        double b3[3]= {0.0,0.0,0.0};
        vector<double> n3_vetory(b3,b3+3);
        double c3[3]= {12.75,13.00,13.25};
        vector<double> n3_vetorz(c3,c3+3);
        if (n3_vetorx.size() >= 2) {                              //Z
            glBegin(GL_LINE_STRIP);
            glTranslatef(-m_isize, -m_isize, -m_isize);
            glColor3f(0, 0, 1);

            glVertex3f(n3_vetorx[2], n3_vetorz[0], n3_vetory[0]);
            glVertex3f(n3_vetorx[0], n3_vetorz[0], n3_vetory[0]);
            glVertex3f(n3_vetorx[2], n3_vetorz[2], n3_vetory[0]);
            glVertex3f(n3_vetorx[0], n3_vetorz[2], n3_vetory[0]);


            glEnd();
            glFlush();
        }
}

//用于处理鼠标滚轮事件和鼠标按下事件
//用户通过鼠标滚轮来控制场景的缩放效果
void OpenGLWindow::wheelEvent(QWheelEvent *event)//处理鼠标滚轮事件
    update();//实现场景的缩放效果。调用 update() 来重新绘制场景
}

void OpenGLWindow::mousePressEvent(QMouseEvent *event)//处理鼠标按下事件。当用户按下鼠标按钮时，会触发这个函数
void OpenGLWindow::mouseMoveEvent(QMouseEvent *event)


//绘制OpenGL中的网格
void OpenGLWindow::GLGrid(float pt1x, float pt1y, float pt1z, float pt2x, float pt2y, float pt2z, int num)

{
    const float _xLen = (pt2x - pt1x) / num;
    const float _yLen = (pt2y - pt1y) / num;
    const float _zLen = (pt2z - pt1z) / num;
    glLineWidth(0.01f);
    glLineStipple(1, 0x0303);//线条样式

    glBegin(GL_LINES);
    glEnable(GL_LINE_SMOOTH);

    int xi = 0;
    int yi = 0;
    int zi = 0;
    //绘制平行于X的直线
    for (zi = 0; zi <= num; zi++) {
        float z = _zLen * zi + pt1z;
        for (yi = 0; yi <= num; yi++) {
            float y = _yLen * yi + pt1y;
            glVertex3f(pt1x, y, z);//指定每个线段的两个端点坐标，从而构成直线段
            glVertex3f(pt2x, y, z);

        }
    }
    //绘制平行于Y的直线
    for (zi = 0; zi <= num; zi++) {
        float z = _zLen * zi + pt1z;
        for (xi = 0; xi <= num; xi++) {
            float x = _xLen * xi + pt1x;
            glVertex3f(x, pt1y, z);
            glVertex3f(x, pt2y, z);
        }
    }
    //绘制平行于Z的直线
    for (yi = 0; yi <= num; yi++) {
        float y = _yLen * yi + pt1y;
        for (xi = 0; xi <= num; xi++) {
            float x = _xLen * xi + pt1x;
            glVertex3f(x, y, pt1z);
            glVertex3f(x, y, pt2z);
        }
    }
    glEnd();
}


//用于绘制理论轨迹
void OpenGLWindow::updateTheroyTraj()
//绘制实际轨迹
void OpenGLWindow::updatePracticeTraj()

```























####  `OpenGLWindow` 的类

这段代码展示了一个名为 `OpenGLWindow` 的类，该类继承自 `QGLWidget` 并用于创建OpenGL窗口。它用于显示3D图形并处理相关的OpenGL绘图和事件。

```c++
using namespace std;  // 使用标准C++命名空间

class OpenGLWindow : public QGLWidget
{
    Q_OBJECT  // 使用Qt元对象宏，启用Qt的信号和槽机制
public:
    explicit OpenGLWindow(QWidget *parent = nullptr);  // 构造函数
    ~OpenGLWindow();  // 析构函数
    void GLGrid(float pt1x, float pt1y, float pt1z, float pt2x, float pt2y, float pt2z, int num);  // 绘制网格的函数

private:
    void LabelXYZ();  // 标注坐标轴的函数

protected:
    void initializeGL();  // 初始化OpenGL上下文
    void resizeGL(int w, int h);  // 在窗口大小变化时调整OpenGL视口
    void paintGL();  // 绘制OpenGL场景
    void mousePressEvent(QMouseEvent *event);  // 处理鼠标按下事件
    void mouseMoveEvent(QMouseEvent *event);  // 处理鼠标移动事件
    void wheelEvent(QWheelEvent *event);  // 处理鼠标滚轮事件

private:
    void updateTheroyTraj();  // 更新理论轨迹
    void updatePracticeTraj();  // 更新实际轨迹

    // 一些私有成员变量，用于存储不同数据
};
这个类似乎定义了一个用于展示3D图形的OpenGL窗口，其中包含了许多用于初始化、绘制、处理事件等的函数。这个类可能会在Qt框架中使用，用于创建一个3D可视化的窗口，并通过继承自 QGLWidget 来实现与OpenGL的交互。
```

